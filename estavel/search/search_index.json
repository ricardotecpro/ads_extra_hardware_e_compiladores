{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#curso-hardware-para-programadores-cc","title":"\ud83c\udf93 Curso: Hardware para Programadores (C/C++)","text":"<p>\"N\u00e3o basta o c\u00f3digo compilar; \u00e9 preciso entender como o sil\u00edcio e os el\u00e9trons o executam na pr\u00e1tica.\"</p> <p>Bem-vindo \u00e0 sua jornada no cora\u00e7\u00e3o da tecnologia. Este curso foi projetado para capacitar desenvolvedores a compreender como o hardware influencia performance, paralelismo, uso de mem\u00f3ria e efici\u00eancia em software, com \u00eanfase pr\u00e1tica em C/C++.</p>"},{"location":"#atalhos-rapidos","title":"\u26a1 Atalhos R\u00e1pidos","text":"<ul> <li> <p> Trilha de Aulas     ---     16 li\u00e7\u00f5es modernas englobando arquitetura, CPU, mem\u00f3ria e I/O.      Iniciar Jornada</p> </li> <li> <p> Slides Interativos     ---     Material visual otimizado com transi\u00e7\u00f5es e suporte Reveal.js.      Ver Slides</p> </li> <li> <p> Quizzes e Pr\u00e1tica     ---     Avalie seu progresso com 160 quest\u00f5es t\u00e9cnicas exclusivas.      Testar Conhecimento</p> </li> <li> <p> Laborat\u00f3rios e Projetos     ---     Aplique conceitos de baixo n\u00edvel em C/C++.      Ver Projetos</p> </li> <li> <p> Exerc\u00edcios Progressivos     ---     Das quest\u00f5es conceituais ao desafio pr\u00e1tico de c\u00f3digo.      Praticar Agora</p> </li> <li> <p> Setup e Ferramentas     ---     Configura\u00e7\u00f5es essenciais para ecossistema C/C++ (GCC/G++).      Configurar</p> </li> </ul>"},{"location":"#mapa-da-jornada-modulos","title":"\ud83d\uddfa\ufe0f Mapa da Jornada (M\u00f3dulos)","text":"<p>O curso est\u00e1 estruturado em 4 M\u00f3dulos cruciais para desenvolvedores backend/sistemas:</p>"},{"location":"#modulo-1-fundamentos-de-arquitetura-de-computadores","title":"\ud83d\udce6 M\u00f3dulo 1: Fundamentos de Arquitetura de Computadores","text":"<p>Como transformar instru\u00e7\u00f5es l\u00f3gicas em pulso el\u00e9trico. - Aulas 01 a 04: Software x Hardware, Representa\u00e7\u00e3o de Dados, Estrutura de CPU e RISC vs CISC.</p>"},{"location":"#modulo-2-memoria-e-performance","title":"\ud83d\udcd0 M\u00f3dulo 2: Mem\u00f3ria e Performance","text":"<p>A anatomia do estado: velocidade versus capacidade. - Aulas 05 a 08: Hierarquia de Mem\u00f3ria, Cache e Localidade, Stack vs Heap, e Mem\u00f3ria Virtual.</p>"},{"location":"#modulo-3-concorrencia-e-paralelismo","title":"\ud83e\udde0 M\u00f3dulo 3: Concorr\u00eancia e Paralelismo","text":"<p>Vencendo as limita\u00e7\u00f5es do chip \u00fanico. - Aulas 09 a 12: Processos e Threads, Sincroniza\u00e7\u00e3o, Paralelismo no Hardware e Modelo de Mem\u00f3ria.</p>"},{"location":"#modulo-4-armazenamento-io-e-pratica","title":"\ud83d\udcbb M\u00f3dulo 4: Armazenamento, I/O e Pr\u00e1tica","text":"<p>Onde a velocidade despenca e integrando todos os conceitos. - Aulas 13 a 16: Dispositivos de Armazenamento, Sistemas de Arquivos, I/O e Projeto Final Anal\u00edtico.</p>"},{"location":"#dicas-de-sucesso","title":"\ud83d\udca1 Dicas de Sucesso","text":"<ol> <li>Entenda os Ponteiros: No M\u00f3dulo 2, faremos intenso uso do entendimento de Heap e Call Stack.</li> <li>Observe o Compilador: Use o Terminal e veja suas sa\u00eddas; entenda como o c\u00f3digo compila nativamente.</li> <li>Diagramas s\u00e3o o Guia: Utilize as tabelas verdade e fluxogramas para visualizar as decis\u00f5es arquiteturais.</li> </ol> <p>Pronto para entender o Hardware?  Ir para Aula 01</p>"},{"location":"materiais/","title":"Materiais","text":""},{"location":"materiais/#materiais","title":"Materiais","text":"<p>Bem-vindo \u00e0 se\u00e7\u00e3o de materiais complementares do curso. Aqui voc\u00ea encontra recursos adicionais para apoiar seus estudos.</p> <ul> <li> <p> Slides</p> <ul> <li>Acesse os slides de todas as aulas para revis\u00e3o.</li> </ul> </li> <li> <p> Exerc\u00edcios</p> <ul> <li>Pratique com listas de exerc\u00edcios para cada m\u00f3dulo.</li> </ul> </li> <li> <p> Quizzes</p> <ul> <li>Teste seus conhecimentos com quizzes interativos.</li> </ul> </li> <li> <p> Projetos</p> <ul> <li>Desenvolva projetos pr\u00e1ticos para aplicar o que aprendeu.</li> </ul> </li> <li> <p> Setup</p> <ul> <li>Guias de instala\u00e7\u00e3o e configura\u00e7\u00e3o do ambiente.</li> </ul> </li> </ul>"},{"location":"plano-ensino/","title":"Plano de Ensino: Hardware para Programadores (C/C++)","text":""},{"location":"plano-ensino/#plano-de-ensino-hardware-para-programadores-cc","title":"Plano de Ensino: Hardware para Programadores (C/C++)","text":""},{"location":"plano-ensino/#1-identificacao","title":"1. Identifica\u00e7\u00e3o","text":"<ul> <li>Curso: Hardware para Programadores</li> <li>Carga Hor\u00e1ria Estimada: 40 a 60 horas</li> <li>P\u00fablico-Alvo: Desenvolvedores de Software, Engenheiros Backend e Estudantes Intermedi\u00e1rios</li> </ul>"},{"location":"plano-ensino/#2-ementa","title":"2. Ementa","text":"<p>A disciplina aborda a arquitetura de baixo n\u00edvel da computa\u00e7\u00e3o e seu vi\u00e9s no desenvolvimento de software de alta performance, especialmente em C/C++. Envolve representa\u00e7\u00e3o de dados, fluxo de processamento e RISC/CISC, modelamento de Hierarquia de Mem\u00f3ria (Heap, Stack, Mem\u00f3ria Virtual), processamento Concorrente e Paralelo (Threads, Condition Variables e Mutex), e Armazenamentos (I/O, File System, Dispositivos).</p>"},{"location":"plano-ensino/#3-objetivos","title":"3. Objetivos","text":""},{"location":"plano-ensino/#objetivo-geral","title":"Objetivo Geral","text":"<p>Transmitir de forma pr\u00e1tica como a l\u00f3gica de constru\u00e7\u00e3o e execu\u00e7\u00e3o de hardware afeta a camada de software.</p>"},{"location":"plano-ensino/#objetivos-especificos","title":"Objetivos Espec\u00edficos","text":"<ul> <li>Diagnosticar e aplicar as melhores pr\u00e1ticas de gerenciamento de mem\u00f3ria em linguagens de baixo n\u00edvel.</li> <li>Desenhar arquiteturas multithread eficientes.</li> <li>Mitigar bottlenecks e vazamentos de mem\u00f3ria (Memory Leaks).</li> </ul>"},{"location":"plano-ensino/#4-conteudo-programatico","title":"4. Conte\u00fado Program\u00e1tico","text":"<ul> <li>M\u00f3dulo 1: Fundamentos de Arquitetura de Computadores (Aulas 01 a 04)</li> <li>M\u00f3dulo 2: Mem\u00f3ria e Performance (Aulas 05 a 08)</li> <li>M\u00f3dulo 3: Concorr\u00eancia e Paralelismo (Aulas 09 a 12)</li> <li>M\u00f3dulo 4: Armazenamento e I/O (Aulas 13 a 15)</li> <li>M\u00f3dulo 5: Integra\u00e7\u00e3o Pr\u00e1tica e Profiling (Aula 16)</li> </ul>"},{"location":"plano-ensino/#5-metodologia","title":"5. Metodologia","text":"<p>Abordagem pragm\u00e1tica. Os alunos executar\u00e3o diagn\u00f3sticos com ferramentas nativas do sistema Linux e da cadeia de compila\u00e7\u00e3o GNU (GCC e GDB). Leituras guiadas via portal MkDocs, seguidas por intera\u00e7\u00f5es e quizzes, e projetos hands-on a cada etapa.</p>"},{"location":"plano-ensino/#6-avaliacao","title":"6. Avalia\u00e7\u00e3o","text":"<p>Aferi\u00e7\u00e3o sistem\u00e1tica, considerando o percentual de acerto sobre os 16 quizzes previstos (10 quest\u00f5es de m\u00faltipla escolha cada), bem como submiss\u00e3o dos exerc\u00edcios propostos com solu\u00e7\u00f5es em tempo de execu\u00e7\u00e3o submetidas aos gabaritos.</p>"},{"location":"plano-ensino/#7-bibliografia-recomendada","title":"7. Bibliografia Recomendada","text":"<ul> <li>Patterson, D. A., &amp; Hennessy, J. L. (2014). Computer Organization and Design: The Hardware/Software Interface.</li> <li>Silberschatz, A., Galvin, P. B., &amp; Gagne, G. (2018). Operating System Concepts.</li> <li>Stroustrup, B. (2013). The C++ Programming Language.</li> </ul>"},{"location":"print_page/","title":"Impress\u00e3o","text":""},{"location":"print_page/#versao-para-impressao","title":"Vers\u00e3o para Impress\u00e3o","text":"<p>Esta p\u00e1gina foi gerada automaticamente para impress\u00e3o.</p>"},{"location":"project_roadmap/","title":"Roadmap do Projeto: Hardware para Programadores","text":""},{"location":"project_roadmap/#roadmap-do-projeto-hardware-para-programadores","title":"Roadmap do Projeto: Hardware para Programadores","text":"<p>Este documento rastreia o progresso da refatora\u00e7\u00e3o e desenvolvimento do curso de Hardware voltado a C/C++ e arquitetura.</p>"},{"location":"project_roadmap/#fase-1-estruturacao-e-setup","title":"\u2705 Fase 1: Estrutura\u00e7\u00e3o e Setup","text":"<ul> <li>[x] Atualiza\u00e7\u00e3o de configura\u00e7\u00f5es (<code>pyproject.toml</code> e <code>mkdocs.yml</code>).</li> <li>[x] Limpeza de arquivos de log.</li> <li>[x] Adi\u00e7\u00e3o do novo tema (Light/Dark mode) com <code>accent: amber</code>.</li> <li>[x] Corre\u00e7\u00e3o do versionamento nativo Mermaid para <code>11.12.3</code> (evitando erro SyntaxError in text).</li> </ul>"},{"location":"project_roadmap/#fase-2-correcao-de-componentes-ui-e-scripts-em-andamento","title":"\ud83d\udea7 Fase 2: Corre\u00e7\u00e3o de Componentes UI e Scripts (Em andamento)","text":"<ul> <li>[ ] Conversor Autom\u00e1tico de Fragmentos (SlideReveal): Atualiza\u00e7\u00e3o da transi\u00e7\u00e3o no script.</li> <li>[ ] Retificar layout de Quizzes (interface circlar CSS para radio buttons e isolamento dos feedbacks).</li> <li>[ ] Termynal.js: Inserir atributos Markdown para correta compila\u00e7\u00e3o e parsing interno.</li> </ul>"},{"location":"project_roadmap/#fase-3-conteudo-e-refatoracao-intelectual-em-andamento","title":"\ud83d\udea7 Fase 3: Conte\u00fado e Refatora\u00e7\u00e3o Intelectual (Em andamento)","text":"<ul> <li>[ ] Aulas (01 a 16): Re-desenho e fundamenta\u00e7\u00e3o C/C++ da ementa (Processos, Diagramas de Mem\u00f3ria).</li> <li>[ ] Exerc\u00edcios (16 listas): 5 exerc\u00edcios progressivos.</li> <li>[ ] Projetos (16 desafios): Profiling, medi\u00e7\u00f5es de Cache, Multithreading Mutex.</li> <li>[ ] Quizzes (16 question\u00e1rios): 10 perguntas estritas focados na din\u00e2mica de CPU e SO.</li> </ul>"},{"location":"project_roadmap/#fase-4-automacao-e-validacao-final","title":"\ud83d\ude80 Fase 4: Automa\u00e7\u00e3o e Valida\u00e7\u00e3o Final","text":"<ul> <li>[ ] Build de Valida\u00e7\u00e3o Rigorosa: <code>mkdocs build --strict</code>.</li> <li>[ ] Validar compatibilidade dos scripts transicionais em localhost (<code>mkdocs serve</code>).</li> <li>[ ] Deploy Final Est\u00e1vel no reposit\u00f3rio GitHub (<code>branch gh-pages</code>).</li> <li>[ ] Remo\u00e7\u00e3o de artefatos obsoletos e garantia do \"estado da arte\".</li> </ul> <p>Status Atual: Fase 1 Finalizada / Fase 2 em Andamento. \u00daltima Atualiza\u00e7\u00e3o: Fevereiro/2026</p>"},{"location":"sobre/","title":"Sobre","text":""},{"location":"sobre/#sobre-o-curso","title":"Sobre o Curso","text":""},{"location":"sobre/#hardware-para-programadores-a-ponte-entre-silicio-e-software","title":"\ud83c\udf93 Hardware para Programadores - A Ponte Entre Sil\u00edcio e Software","text":"<p>Este curso foi idealizado para preencher a lacuna entre c\u00f3digo abstrato e os processadores que o executam. Durante 16 aulas focadas, especialmente ricas em exemplos C/C++, voc\u00ea aprender\u00e1 a dominar performance, concorr\u00eancia, otimiza\u00e7\u00e3o de Cache e uso eficiente de Mem\u00f3ria.</p>"},{"location":"sobre/#objetivos-do-curso","title":"\ud83c\udfaf Objetivos do Curso","text":"<ul> <li> <p> Performance e Arquitetura</p> <p>Compreender a diferen\u00e7a pr\u00e1tica das arquiteturas RISC e CISC, pipeline, ciclo de instru\u00e7\u00e3o e como isso impacta seu c\u00f3digo compilado.</p> </li> <li> <p> Uso Avan\u00e7ado de Mem\u00f3ria</p> <p>Dominar a din\u00e2mica entre Stack e Heap, evitar vazamentos (Memory Leaks), dominar ponteiros e entender como o SO gerencia a mem\u00f3ria virtual.</p> </li> <li> <p> Concorr\u00eancia e Paralelismo</p> <p>Aprender a operar m\u00faltiplos cores com Threads e Processos, tratando condi\u00e7\u00f5es de corrida com Mutex, Sem\u00e1foros e conhecendo o Memory Consistency Model.</p> </li> <li> <p> I/O e Armazenamento</p> <p>Lidar com a lat\u00eancia de discos (SSD vs HDD vs NVMe), interrup\u00e7\u00f5es, system calls e as caracter\u00edsticas cr\u00edticas da persist\u00eancia em Bancos de Dados / Backend.</p> </li> </ul>"},{"location":"sobre/#o-que-voce-vai-aprender","title":"\ud83d\udcda O Que Voc\u00ea Vai Aprender","text":""},{"location":"sobre/#modulo-1-fundamentos-de-arquitetura-de-computadores","title":"M\u00d3DULO 1 \u2013 Fundamentos de Arquitetura de Computadores","text":"<ul> <li>Como o Software Roda no Hardware.</li> <li>Representa\u00e7\u00e3o de Dados (Bin\u00e1rio, Hex, IEEE 754).</li> <li>Estrutura e Ciclo de CPU (Control Unit e ALU).</li> <li>RISC vs CISC (ARM vs x86).</li> </ul>"},{"location":"sobre/#modulo-2-memoria-e-performance","title":"M\u00d3DULO 2 \u2013 Mem\u00f3ria e Performance","text":"<ul> <li>Hierarquia de Mem\u00f3ria.</li> <li>Cache, Localidade (Temporal e Espacial) e False Sharing.</li> <li>Stack vs Heap e Aloca\u00e7\u00f5es em C/C++.</li> <li>Mem\u00f3ria Virtual, TLB e Pagina\u00e7\u00e3o.</li> </ul>"},{"location":"sobre/#modulo-3-concorrencia-e-paralelismo","title":"M\u00d3DULO 3 \u2013 Concorr\u00eancia e Paralelismo","text":"<ul> <li>Diferen\u00e7as entre Processos e Threads.</li> <li>Mutex, Sem\u00e1foros e Preven\u00e7\u00e3o de Deadlocks.</li> <li>Paralelismo no Hardware (Hyper-threading e GPUs).</li> <li>Modelo de Mem\u00f3ria e Barrier de Instru\u00e7\u00f5es.</li> </ul>"},{"location":"sobre/#modulo-4-armazenamento-e-io","title":"M\u00d3DULO 4 \u2013 Armazenamento e I/O","text":"<ul> <li>Lat\u00eancia em Dispositivos de Armazenamento.</li> <li>Sistemas de Arquivos e Journaling.</li> <li>I/O, Interrupts e DMA.</li> </ul>"},{"location":"sobre/#modulo-5-integracao-pratica","title":"M\u00d3DULO 5 \u2013 Integra\u00e7\u00e3o Pr\u00e1tica","text":"<ul> <li>Projeto Final: Profiling e An\u00e1lise de Gargalos.</li> </ul>"},{"location":"sobre/#metodologia","title":"\ud83d\udee0\ufe0f Metodologia","text":"<ul> <li> <p> Aulas Did\u00e1ticas</p> <p>Teoria fundamentada, mesclada com anima\u00e7\u00f5es e slides constru\u00eddos com Reveal.js.</p> </li> <li> <p> Exerc\u00edcios Progressivos</p> <p>Listas que abordam problemas te\u00f3ricos e implementa\u00e7\u00f5es obrigat\u00f3rias em C/C++.</p> </li> <li> <p> Projetos Pr\u00e1ticos</p> <p>Aplica\u00e7\u00f5es diretas para solidificar os desafios e observar melhorias tang\u00edveis no tempo de execu\u00e7\u00e3o.</p> </li> <li> <p> Quizzes Interativos</p> <p>Avalia\u00e7\u00f5es modulares formatadas com feedback instant\u00e2neo para mensurar a reten\u00e7\u00e3o do saber.</p> </li> </ul>"},{"location":"sobre/#para-quem-e-este-curso","title":"\ud83d\udc68\u200d\ud83c\udf93 Para Quem \u00e9 Este Curso","text":"<ul> <li>Desenvolvedores Intermedi\u00e1rios a Avan\u00e7ados querendo melhorar a efici\u00eancia do seu c\u00f3digo em linguagens de baixo n\u00edvel ou alto n\u00edvel.</li> <li>Engenheiros Backend / Software.</li> <li>Entusiastas de C e C++ e programadores que almejam desenvolver embarcados, games e sistemas cr\u00edticos.</li> </ul>"},{"location":"sobre/#pre-requisitos","title":"\ud83d\udccb Pr\u00e9-requisitos","text":"<ul> <li>Experi\u00eancia pr\u00e9via em programa\u00e7\u00e3o (vari\u00e1veis, loops, condicionais, fun\u00e7\u00f5es).</li> <li>\u00c9 recomend\u00e1vel (embora n\u00e3o obrigat\u00f3rio) ter lido ou estudado C/C++.</li> <li>Um sistema ou m\u00e1quina virtual Linux (Ubuntu/Debian) configurada para compiladores e debugging.</li> </ul>"},{"location":"sobre/#o-que-voce-recebera","title":"\ud83c\udf96\ufe0f O Que Voc\u00ea Receber\u00e1","text":"<ul> <li>\u2705 Dom\u00ednio do funcionamento da CPU e mem\u00f3ria (Cache Hit, Profiling).</li> <li>\u2705 Escrita de scripts eficientes e multi-processamento em sintonia fina com hardware.</li> <li>\u2705 Autonomia em diagn\u00f3sticos de performance.</li> </ul>"},{"location":"sobre/#comece-agora","title":"\ud83d\ude80 Comece Agora","text":"<p>Pronto para entender o sil\u00edcio?</p> <p> Ir para Aula 01  Configurar Ambiente</p>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tags","title":"Tags","text":"<p>Explore as aulas por tema:</p>"},{"location":"aulas/","title":"Aulas do Curso","text":""},{"location":"aulas/#aulas-do-curso","title":"Aulas do Curso","text":"<p>Bem-vindo \u00e0 se\u00e7\u00e3o de aulas! Aqui voc\u00ea encontra todo o conte\u00fado do curso organizado por m\u00f3dulos.</p>"},{"location":"aulas/#modulos-do-curso","title":"\ud83d\udcda M\u00f3dulos do Curso","text":"<ul> <li> <p> M\u00f3dulo 1: Fundamentos de Arquitetura de Computadores     ---</p> <ul> <li>Aula 01 - Como o Software Roda no Hardware</li> <li>Aula 02 - Representa\u00e7\u00e3o de Dados</li> <li>Aula 03 - CPU: Estrutura e Funcionamento</li> <li>Aula 04 - Arquiteturas RISC vs CISC</li> </ul> </li> <li> <p> M\u00f3dulo 2: Mem\u00f3ria e Performance     ---</p> <ul> <li>Aula 05 - Hierarquia de Mem\u00f3ria</li> <li>Aula 06 - Cache e Localidade</li> <li>Aula 07 - Stack vs Heap</li> <li>Aula 08 - Mem\u00f3ria Virtual</li> </ul> </li> <li> <p> M\u00f3dulo 3: Concorr\u00eancia e Paralelismo     ---</p> <ul> <li>Aula 09 - Processos e Threads</li> <li>Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia</li> <li>Aula 11 - Paralelismo no Hardware</li> <li>Aula 12 - O Modelo de Mem\u00f3ria</li> </ul> </li> <li> <p> M\u00f3dulo 4: Armazenamento, I/O e Pr\u00e1tica     ---</p> <ul> <li>Aula 13 - Dispositivos de Armazenamento</li> <li>Aula 14 - Sistemas de Arquivos</li> <li>Aula 15 - Entrada e Sa\u00edda (I/O)</li> <li>Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware</li> </ul> </li> </ul>"},{"location":"aulas/aula-01/","title":"Aula 01 - Como o Software Roda no Hardware","text":""},{"location":"aulas/aula-01/#aula-01-como-o-software-roda-no-hardware","title":"Aula 01 - Como o Software Roda no Hardware","text":"<p>Nesta aula introdut\u00f3ria, faremos a descida do n\u00edvel abstrato (c\u00f3digo-fonte) at\u00e9 a realidade el\u00e9trica (processador). A compreens\u00e3o cl\u00e1ssica da interface Hardware/Software \u00e9 o que difere programadores comuns de engenheiros com vis\u00e3o arquitetural.</p>"},{"location":"aulas/aula-01/#1-o-abismo-entre-codigo-e-silicio","title":"\ud83c\udfd7\ufe0f 1. O Abismo entre C\u00f3digo e Sil\u00edcio","text":"<p>Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, Bin\u00e1rios (0 e 1).</p> <p>Como a sua frase <code>printf(\"Hello World\");</code> chega aos pinos do processador? Atrav\u00e9s de uma cadeia de ferramentas (Toolchain).</p>"},{"location":"aulas/aula-01/#o-processo-de-compilacao-cc","title":"O Processo de Compila\u00e7\u00e3o (C/C++)","text":"<p>Linguagens compiladas de baixo n\u00edvel seguem um caminho determin\u00edstico. Veja o diagrama abaixo de como um arquivo <code>.c</code> \u00e9 fatiado:</p> <pre><code>graph TD\n    A([\"C\u00f3digo Fonte (hello.c)\"]) --&gt; B(\"Pr\u00e9-processador\")\n    B --&gt; C(\"Compilador\")\n    C --&gt; D(\"Assembly (hello.s)\")\n    D --&gt; E(\"Assembler\")\n    E --&gt; F(\"C\u00f3digo de M\u00e1quina / Objeto (hello.o)\")\n    F --&gt; G{\"Linker\"}\n    H([\"Bibliotecas (libc.a, libc.so)\"]) --&gt; G\n    G --&gt; I((Execut\u00e1vel Bin\u00e1rio))</code></pre> <p>[!INFO] Voc\u00ea sabia? O compilador (ex: GCC) traduz o C/C++ n\u00e3o para 0s e 1s de imediato, mas para Assembly \u2014 a representa\u00e7\u00e3o textual do c\u00f3digo de m\u00e1quina, \u00fanica para cada arquitetura.</p>"},{"location":"aulas/aula-01/#2-compiladores-vs-interpretadores","title":"\ud83d\udee0\ufe0f 2. Compiladores vs Interpretadores","text":"<p>A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance:</p> Linguagens Compiladas (C/C++, Rust, Go)Linguagens Interpretadas (Python, Ruby)Linguagens H\u00edbridas (Java, C#) <p>O c\u00f3digo \u00e9 100% transformado em bin\u00e1rio antes de executar (AOT - Ahead of Time). Pr\u00f3: Alta velocidade de execu\u00e7\u00e3o. Hardware direto. Contra: O execut\u00e1vel constru\u00eddo em Linux-x86 n\u00e3o roda nativamente em Windows-ARM sem ser recompilado.</p> <p>Um programa (Interpretador) l\u00ea o seu c\u00f3digo fonte em tempo de execu\u00e7\u00e3o e executa as a\u00e7\u00f5es simulando o comando subjacente para o S.O. Pr\u00f3: Roda em qualquer SO que tiver o interpretador. Contra: Muito mais lento, por sofrer overhead da interpreta\u00e7\u00e3o.</p> <p>Compilam para um formato intermedi\u00e1rio (Bytecode), e a JVM ou CLR as compila JIT (Just-In-Time) na m\u00e1quina cliente no instante de executar.</p>"},{"location":"aulas/aula-01/#3-isa-o-contrato-do-processador","title":"\ud83d\udcd0 3. ISA: O Contrato do Processador","text":"<p>ISA (Instruction Set Architecture) \u00e9 o dicion\u00e1rio de um processador. \u00c9 o conjunto de comandos num\u00e9ricos que o CPU sabe, fisicamente, executar:</p> <ul> <li>Puxar da Mem\u00f3ria (LOAD)</li> <li>Somar (ADD)</li> <li>Gravar na Mem\u00f3ria (STORE)</li> </ul> <p>Todo c\u00f3digo, por mais sofisticado que seja, precisa ser reduzido a estas poucas opera\u00e7\u00f5es ditadas pela ISA para rodar.</p> <pre><code>$ gcc -O2 -S hello.c\n$ cat hello.s\nmain:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    leaq    .LC0(%rip), %rdi\n    call    puts@PLT\n</code></pre> <p>Acima, o output \u00e9 o assembly x86 do seu C. \u00c9 a representa\u00e7\u00e3o literal da s\u00e9rie de instru\u00e7\u00f5es que formar\u00e3o a ISA do seu microprocessador Intel/AMD.</p>"},{"location":"aulas/aula-01/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Ao usar C/C++, voc\u00ea n\u00e3o lida com um motor intermedi\u00e1rio te cobrindo (como a JVM), voc\u00ea escreve algoritmos cuja gest\u00e3o \u00e9 delegada ao S.O. e rodada pura em metal.</li> <li>O programador backend / performance critica deve inspecionar eventuais outputs em Assembly para verificar se a abordagem da linguagem otimiza tempo de registrador.</li> </ul> <p>Pronto para entender profundamente os dados no M\u00f3dulo Bin\u00e1rio?</p>"},{"location":"aulas/aula-01/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 02</p>"},{"location":"aulas/aula-02/","title":"Aula 02 - Representa\u00e7\u00e3o de Dados","text":""},{"location":"aulas/aula-02/#aula-02-representacao-de-dados","title":"Aula 02 - Representa\u00e7\u00e3o de Dados","text":"<p>Ao cruzar a fronteira entre software e a CPU, descobrimos que n\u00e3o existem \"Strings\" ou \"Imagens\", existem apenas correntes el\u00e9tricas ligadas ou desligadas (1s e 0s). Vamos analisar a estrutura sob a \u00f3tica de C/C++.</p>"},{"location":"aulas/aula-02/#1-sistema-binario-e-hexadecimal","title":"\ud83d\udd22 1. Sistema Bin\u00e1rio e Hexadecimal","text":"<p>O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal).</p> <ul> <li>Bit: 0 ou 1</li> <li>Byte: 8 bits (<code>00000000</code> a <code>11111111</code>, indo de 0 a 255 no decimal)</li> </ul> <p>Por que <code>Hexadecimal</code> \u00e9 amado pelos desenvolvedores C/C++? Um Byte (8 bits) pode ser perfeitamente representado por exatos dois caracteres Hexadecimais. <code>FF</code> \u00e9 o mesmo que <code>11111111</code>.</p> <pre><code>$ # Como voc\u00ea lida com Hex no C++?\n$ cat var.cpp\nint mascara_de_bits = 0xFF; // Representa 255\n</code></pre>"},{"location":"aulas/aula-02/#2-inteiros-com-e-sem-sinal-unsigned","title":"\ud83d\udd0b 2. Inteiros com e sem Sinal (Unsigned)","text":"<p>Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware:</p> <pre><code>int x = 255;           // Geralmente um int \u00e9 32 bits, comportando valores grandes, podendo ser negativo (signed).\nunsigned char y = 255; // 8 bits sem sinal (0 a 255)\nsigned char z = -1;    // 8 bits com sinal (-128 a 127)\n</code></pre> <p>No hardware, inteiros negativos s\u00e3o representados usando a regra de Complemento de 2. Para obtermos o bin\u00e1rio do <code>-1</code>, invertemos todos os bits de <code>1</code> e somamos <code>1</code>.</p> <p>[!WARNING] Sempre avalie Overshoot. Um loop usando <code>unsigned int i = 10; while(i &gt;= 0)</code> ser\u00e1 um loop infinito, porque quando <code>i</code> atingir 0 e for subtra\u00eddo, ele NUNCA ficar\u00e1 negativo; ele executar\u00e1 o \"Wrap-around\" arquitetural, voltando ao valor limite de (<code>4.294.967.295</code>).</p>"},{"location":"aulas/aula-02/#3-ponto-flutuante-ieee-754","title":"\ud83e\uddee 3. Ponto Flutuante (IEEE 754)","text":"<p>Os famosos tipos <code>float</code> e <code>double</code>. O processador possui normalmente um setor dedicado de FPU (Floating Point Unit) para eles.</p> <p>A representa\u00e7\u00e3o oficial IEEE 754 os divide em 3 por\u00e7\u00f5es:</p> <pre><code>flowchart LR\n    A[\"Sinal (1 bit)\"] --- B[\"Expoente (8 bits)\"] --- C[\"Fra\u00e7\u00e3o/Mantissa (23 bits)\"]\n    style A fill:#ff9999\n    style B fill:#99ccff\n    style C fill:#ccffcc</code></pre>"},{"location":"aulas/aula-02/#o-perigo-da-precisao","title":"O Perigo da Precis\u00e3o!","text":"<p>[!CAUTION] Ao somar decimais repetidamente, as varia\u00e7\u00f5es de mantissa geram margens de erro: <code>0.1 + 0.2</code> raramente \u00e9 exatamente <code>0.3</code> na FPU, mas sim <code>0.30000000000000004</code>! Evite comparadores igualit\u00e1rios (<code>==</code>) em floats. Jamais use floats transacionando valores banc\u00e1rios estritos em backend, use estruturas customizadas dimensionais inteiras.</p>"},{"location":"aulas/aula-02/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<p>A maneira como voc\u00ea escolhe o tipo primitivo da vari\u00e1vel modela a fisionomia do registrador acionado na m\u00e1quina durante o fetch. Entender o Overflow \u00e9 a prote\u00e7\u00e3o b\u00e1sica contra corrup\u00e7\u00e3o l\u00f3gica do c\u00f3digo.</p>"},{"location":"aulas/aula-02/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 03</p>"},{"location":"aulas/aula-03/","title":"Aula 03 - CPU: Estrutura e Funcionamento","text":""},{"location":"aulas/aula-03/#aula-03-cpu-estrutura-e-funcionamento","title":"Aula 03 - CPU: Estrutura e Funcionamento","text":"<p>Como as opera\u00e7\u00f5es chegam e s\u00e3o tratadas pela verdadeira mente do computador? A CPU (Unidade Central de Processamento) n\u00e3o \u00e9 m\u00e1gica, ela segue um ciclo de pulso r\u00edgido orquestrado pelo Clock.</p>"},{"location":"aulas/aula-03/#1-o-triangulo-de-ouro-alu-cu-e-registradores","title":"\ud83c\udfd7\ufe0f 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores","text":"<p>A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais:</p> <ol> <li>ALU (Unidade L\u00f3gica e Aritm\u00e9tica): O m\u00fasculo. Onde as somas, subtra\u00e7\u00f5es e portas l\u00f3gicas (AND/OR/XOR) acontecem fisicamente usando transistores.</li> <li>CU (Unidade de Controle): O supervisor. Ela diz \u00e0 ALU o que fazer lendo os \"Opcodes\" (comandos bin\u00e1rios ISA).</li> <li>Registradores: Pequenos e ultra-r\u00e1pidos blocos de mem\u00f3ria embutidos diretamente no chip. (ex: EAX, EBX, RSP).</li> </ol> <pre><code>$ # Como voc\u00ea l\u00ea valores do processador direto em C?\n$ cat register.c\nint main() {\n    register int i = 10; // \"Dica\" para o compilador usar um registrador direto!\n    return i;\n}\n</code></pre>"},{"location":"aulas/aula-03/#2-o-ciclo-de-instrucao-fetch-decode-execute","title":"\ud83d\udd04 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute)","text":"<p>Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do Clock pelo ciclo cl\u00e1ssico:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Fetch\n    Fetch --&gt; Decode\n    Decode --&gt; Execute\n    Execute --&gt; Store\n    Store --&gt; Fetch</code></pre> <ol> <li>Fetch (Busca): A CU vai na Mem\u00f3ria RAM e busca qual o pr\u00f3ximo byte de comando, guiando-se pelo Program Counter (PC).</li> <li>Decode (Decodifica): A CU traduz o comando para entender o que \u00e9 (\"Ah, \u00e9 para Somar 5!\").</li> <li>Execute: A ALU recebe os par\u00e2metros e faz a conta f\u00edsica el\u00e9tron a el\u00e9tron.</li> <li>Store (Armazena): O resultado volta para um registrador ou para a Mem\u00f3ria RAM.</li> </ol>"},{"location":"aulas/aula-03/#3-pipeline-e-previsao-de-desvio-branch-prediction","title":"\u26a1 3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction)","text":"<p>Seu processador n\u00e3o faz essas 4 etapas de forma burra (uma por vez). Ele usa Pipelining: Enquanto a Instru\u00e7\u00e3o A est\u00e1 em Execute, a Instru\u00e7\u00e3o B j\u00e1 est\u00e1 em Decode e a Instru\u00e7\u00e3o C est\u00e1 em Fetch!</p>"},{"location":"aulas/aula-03/#o-perigo-do-if","title":"O perigo do \"IF\"","text":"<p>Quando voc\u00ea usa muitos <code>if()</code>, o processador tenta \"Adivinhar\" o lado do if usando heur\u00edsticas para n\u00e3o frear o Pipeline (Isso \u00e9 o Branch Prediction).</p> <p>[!WARNING] Errar a adivinha\u00e7\u00e3o do <code>if</code> corrompe todo o Pipeline que foi pr\u00e9-carregado. Em c\u00f3digo de alta performance C++, tentamos escrever loops minimizando saltos condicionais imprevistos.</p>"},{"location":"aulas/aula-03/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<p>Registradores s\u00e3o seus maiores amigos de performance. C\u00f3digos C++ que permitem ao compilador prender c\u00e1lculos pesados 100% dentro dos Registradores rodam em Nanossegundos, contra Milissegundos lendo sempre pela RAM.</p>"},{"location":"aulas/aula-03/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 04</p>"},{"location":"aulas/aula-04/","title":"Aula 04 - Arquiteturas RISC vs CISC","text":""},{"location":"aulas/aula-04/#aula-04-arquiteturas-risc-vs-cisc","title":"Aula 04 - Arquiteturas RISC vs CISC","text":"<p>Por muito tempo, o ecossistema PC foi dominado pela Intel (CISC), enquanto celulares e embarcados (Raspberry Pi/STM32) focavam em ARM (RISC). Mas as linhas se cruzam hoje, especialmente com hardwares como a linha M da Apple operando em RISC com performance alt\u00edssima.</p>"},{"location":"aulas/aula-04/#1-entendendo-a-batalha","title":"\ud83e\udd4a 1. Entendendo a Batalha","text":"<p>A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas?</p> CISC (Complex Instruction Set Computer)RISC (Reduced Instruction Set Computer) <p>Fios de Cabelo: Possui instru\u00e7\u00f5es complexas que podem realizar tarefas gigantescas de uma vez (ex: \"Leia da mem\u00f3ria X, mude o bit Y, grave em Z\" em apenas UMA instru\u00e7\u00e3o assembly). Reis do peda\u00e7o: Processadores Intel e AMD (x86_64). Caracter\u00edsticas: Hardware muito complexo, consome mais energia para decodificar instru\u00e7\u00f5es multiformes.</p> <p>L\u00e2mina Fina: Possui pouqu\u00edssimas instru\u00e7\u00f5es, todas r\u00e1pidas, simples e uniformes. Fazer \"Leia da mem\u00f3ria X, mude o bit Y, grave em Z\" leva 3 a 4 comandos curtos no assembly. Reis do peda\u00e7o: Arquitetura ARM (Snapdragon, Apple Silicon M1-M3, AWS Graviton). Caracter\u00edsticas: Consome pouca bateria e se destaca muito em Pipelines agressivos.</p>"},{"location":"aulas/aula-04/#2-como-isso-afeta-o-compilador-cc","title":"\ud83d\udda8\ufe0f 2. Como isso afeta o Compilador C/C++?","text":"<p>Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas:</p> <pre><code>$ # Compilando para a m\u00e1quina local (digamos, x86_64 CISC)\n$ gcc app.c -o app\n$ # Compilando Cruzado (Cross-Compiling) de um PC x86 para rodar num Raspberry Pi (ARMv8):\n$ aarch64-linux-gnu-gcc app.c -o app_arm\n</code></pre> <p>O c\u00f3digo C++ original <code>app.c</code> n\u00e3o muda! Quem rala \u00e9 o compilador, que na vers\u00e3o ARM gera dezenas de pequenas instru\u00e7\u00f5es curtas RISC, e na vers\u00e3o local gera um op-code gigante com microc\u00f3digos CISC internos da Intel.</p> <p>[!TIP] Na nuvem: A maioria dos servi\u00e7os modernos baseados no Docker \u00e9 Cross-Platform, mas as imagens cont\u00ednuas n\u00e3o! Seu <code>Dockerfile</code> ou sua build em Go e Rust deve explicitamente compilar para as duplas natividades quando for fazer Load Balancer entre inst\u00e2ncias AWS Graviton (ARM) e Padr\u00e3o (x86).</p>"},{"location":"aulas/aula-04/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Historicamente, servidores eram puramente CISC (Intel).</li> <li>Hoje, o mercado clama por RISC gra\u00e7as \u00e0 sustentabilidade t\u00e9rmica (menos energia e calor).</li> <li>Um bom engenheiro percebe que a ISA (aula anterior) CISC vai conter milhares de comandos Assembly, requerendo compiladores muito agressivos, enquanto a ISA RISC exigir\u00e1 compiladores muito detalhistas e otimizados linearmente na aloca\u00e7\u00e3o de registradores C/C++.</li> </ul> <p>Caminho livre at\u00e9 aqui? Ent\u00e3o agora vamos adentrar nas dores da \"Mem\u00f3ria\".</p>"},{"location":"aulas/aula-04/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 05</p>"},{"location":"aulas/aula-05/","title":"Aula 05 - Hierarquia de Mem\u00f3ria","text":""},{"location":"aulas/aula-05/#aula-05-hierarquia-de-memoria","title":"Aula 05 - Hierarquia de Mem\u00f3ria","text":"<p>A mem\u00f3ria \u00e9 o maior gargalo oculto no software moderno de alta concorr\u00eancia. Quanto mais pr\u00f3ximo o dado est\u00e1 da CPU, mais r\u00e1pido \u00e9 o acesso. Mas a velocidade custa dinheiro e escala t\u00e9rmica.</p>"},{"location":"aulas/aula-05/#1-a-piramide-de-alta-performance","title":"\ud83c\udfdb\ufe0f 1. A Pir\u00e2mide de Alta Performance","text":"<p>Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda:</p> <pre><code>graph TD\n    A(\"Registradores&lt;br/&gt;(1 Ciclo - Alguns Bytes)\") --&gt; B[\"Cache L1&lt;br/&gt;(~4 Ciclos - ~64KB a 128KB)\"]\n    B --&gt; C[\"Cache L2 e L3&lt;br/&gt;(~12 a ~40 Ciclos - Megabytes)\"]\n    C --&gt; D[[\"RAM (Mem\u00f3ria Principal)&lt;br/&gt;(~200 a ~300 Ciclos - Gigabytes)\"]]\n    D --&gt; E[(\"Armazenamento (SSD / HDD)&lt;br/&gt;(Milh\u00f5es de Ciclos - Terabytes)\")]\n\n    style A fill:#ff9999\n    style B fill:#ffcc99\n    style C fill:#ffff99\n    style D fill:#ccffcc\n    style E fill:#99ccff</code></pre> <p>[!IMPORTANT] A lat\u00eancia \u00e9 o tempo que demora da CPU pedir um dado at\u00e9 ele chegar. Buscar um byte da RAM demora ~200 ciclos. Buscar do SSD demora centenas de milhares. Essa diferen\u00e7a grotesca \u00e9 mitigada pelo uso de Caches.</p>"},{"location":"aulas/aula-05/#2-os-impactos-da-latencia-lado-do-codigo","title":"\u23f3 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo)","text":"<p>Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty.</p> <pre><code>$ # Como consultar as camadas do processador Linux\n$ lscpu | grep Cache\nL1d cache:                       64 KiB\nL1i cache:                       64 KiB\nL2 cache:                        1 MiB\nL3 cache:                        12 MiB\n</code></pre> <p>A instru\u00e7\u00e3o e os dados descem da L3, saltam para L2, descem para L1 e se acoplam na ALU.</p>"},{"location":"aulas/aula-05/#3-optimizando-uso","title":"\ud83c\udfaf 3. Optimizando Uso","text":"<p>Por que linguagens como C e C++ dominam infraestrutura de servidores High Frequency Trading? Porque elas permitem <code>Aloca\u00e7\u00e3o Est\u00e1tica e Constante</code> que \u00e9 perfeitamente \"encaixada\" pelo compilador diretamente na mem\u00f3ria Cache.</p> <p>Ao inv\u00e9s de carregar gigabytes de Strings na lenta RAM, as linguagens de baixo n\u00edvel incentivam o uso de matrizes de tamanho delimitado (arrays fixos), cujo agrupamento cont\u00edguo for\u00e7a a arquitetura de Hardware Prefetching a adiantar os bytes do Array para a Cache nativamente, antes mesmo de voc\u00ea rodar a linha do c\u00f3digo!</p>"},{"location":"aulas/aula-05/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se processadores hoje s\u00e3o m\u00edsseis atingindo +4GHz, a RAM parou no tempo (Lat\u00eancia de CAS n\u00e3o baixa proporcionalmente).</li> <li>Tudo recai na t\u00e9cnica humana de amarrar dados juntos (Caches L1 e L2) e escrever data-oriented code se quiser ultra-lat\u00eancia C++.</li> </ul>"},{"location":"aulas/aula-05/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 06</p>"},{"location":"aulas/aula-06/","title":"Aula 06 - Cache e Localidade","text":""},{"location":"aulas/aula-06/#aula-06-cache-e-localidade","title":"Aula 06 - Cache e Localidade","text":"<p>Se a Cache L1/L2 \u00e9 t\u00e3o cr\u00edtica, como o Hardware adivinha o que o programador vai pedir? A CPU n\u00e3o l\u00ea bytes individuais da RAM; ela traz \"blocos\" cont\u00edguos chamados de Cache Lines (geralmente de 64 bytes).</p>"},{"location":"aulas/aula-06/#1-cache-hit-e-cache-miss","title":"\u2705 1. Cache Hit e Cache Miss","text":"<p>O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate.</p> <ul> <li>Cache Hit: Acerto! A CPU pediu a posi\u00e7\u00e3o <code>[1]</code>, ela j\u00e1 estava na Cache e a conta foi resolvida quase imediatamente.</li> <li>Cache Miss: Erro! O processador precisou parar o Pipeline, ir at\u00e9 a RAM lenta, injetar o bloco de bytes na lenta escalada D-Cache/L3/L2/L1 e prosseguir.</li> </ul> <pre><code>sequenceDiagram\n    participant P as Programador\n    participant C as Cache L1\n    participant R as RAM\n\n    P-&gt;&gt;C: Quero array[0]!\n    Note right of C: \"Cache Hit\" (Sucesso imediato)\n\n    P-&gt;&gt;C: Quero NodeLink-&gt;prox!\n    Note right of C: N\u00e3o est\u00e1 aqui...\n    C-&gt;&gt;R: Buscar Posi\u00e7\u00e3o Lenta na RAM...\n    R--&gt;&gt;C: Traz o bloco de 64bytes inteiro\n    Note right of C: \"Cache Miss\" (Atraso)</code></pre>"},{"location":"aulas/aula-06/#2-localidade-espacial-vs-temporal","title":"\ud83d\uddfa\ufe0f 2. Localidade Espacial vs Temporal","text":"<p>As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada):</p> Localidade EspacialLocalidade Temporal <p>Se o programa acessou a vari\u00e1vel na posi\u00e7\u00e3o de mem\u00f3ria <code>X</code>, h\u00e1 extrema probabilidade de que no ciclo de CPU seguinte ele acesse a vari\u00e1vel de mem\u00f3ria <code>X + 1</code>. O cl\u00e1ssico caso dos Arrays Continuos (std::vector), garantindo varredura limpa em Hit sequencial absoluto de 64 em 64 bytes.</p> <p>Se o programa visitou a vari\u00e1vel <code>Y</code> agora, h\u00e1 enorme probabilidade dele visit\u00e1-la nos pr\u00f3ximos ms. O cl\u00e1ssico caso das Vari\u00e1veis Locais e Contadores Padr\u00f5es (<code>int i = 0</code>) retidos brutalmente no Registrador ou na L1.</p>"},{"location":"aulas/aula-06/#3-false-sharing-e-logica-invertida-a-morte-do-c","title":"\ud83e\udde8 3. False Sharing e L\u00f3gica Invertida (A Morte do C++)","text":"<p>[!WARNING] O vil\u00e3o m\u00e1ximo da performance: Iterar sobre matrizes pela Coluna ao inv\u00e9s da Linha. A imagem matriz na RAM C/C++ (Row-major order) exige saltos. E False Sharing ocorre quando threads isoladas atualizam vari\u00e1veis cont\u00edguas da mesma linha de Cache de 64 bytes, for\u00e7ando o Hardware (Cache Coherence Protocol) a invalidar repetitivas vezes L1/L2, triturando toda m\u00e9trica.</p> <p>A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo.</p>"},{"location":"aulas/aula-06/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 07</p>"},{"location":"aulas/aula-07/","title":"Aula 07 - Stack vs Heap","text":""},{"location":"aulas/aula-07/#aula-07-stack-vs-heap","title":"Aula 07 - Stack vs Heap","text":"<p>Agora mergulhamos no cora\u00e7\u00e3o cir\u00fargico da engenharia C/C++: \"Onde o S.O. decide alocar e liberar a sua vari\u00e1vel f\u00edsica real na mem\u00f3ria?\". Essa escolha define vida, morte e performance do algoritmo em tempo real.</p>"},{"location":"aulas/aula-07/#1-a-pilha-stack","title":"\ud83e\uddf1 1. A Pilha (Stack)","text":"<p>A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out). </p> Vantagens C/C++ da Pilha <ul> <li>Performance Imediata: N\u00e3o sofre do atraso monumental do Sistema Operacional rodando scripts para achar buracos vazios. A CPU avan\u00e7a 1 pino de hardware no SP (Stack Pointer) e empilha na RAM. Retirou, ele decrementa. Super r\u00e1pido.</li> <li>Anti-Vazamento Autom\u00e1tico: Fun\u00e7\u00f5es extintas s\u00e3o imediatamente retiradas (popped) num clique at\u00f4mico LIFO e as fatias voltam a uso global. Mem\u00f3ria protegida contra vazamentos l\u00f3gicos (memory leaks) por defini\u00e7\u00e3o estrita.</li> <li>Quente da CPU: Frequentemente preza por Cache Hit. A Stack costuma viver majoritariamente no limiar da L1 Data Cache.</li> </ul> <p>[!CAUTION] Stack Overflow! A Pilha nunca \u00e9 infinita, sendo tipicamente restrita pelo S.O. Windows/Linux (geralmente entre 1MB a 8MB max num Kernel Padr\u00e3o X86). Tentar criar um <code>int array[9999999]</code> puro no escopo sem aloca\u00e7\u00e3o din\u00e2mica explodir\u00e1 a Pilha e esmagar\u00e1 cruelmente (o temido <code>Segmentation Fault (core dumped)</code>).</p>"},{"location":"aulas/aula-07/#2-o-monte-heap","title":"\ud83d\udce6 2. O Monte (Heap)","text":"<p>Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o Din\u00e2mica).</p> <pre><code>$ # Como voc\u00ea interage em baixo n\u00edvel (C/C++)\n$ cat code.c\n#include &lt;stdlib.h&gt;\n\nint main() {\n    // malloc vai no Sistema Operacional e chora pedindo: \"Me d\u00ea 10 inteiros!\"\n    int* array_gigante_dinamico = (int*)malloc(10 * sizeof(int));\n\n    // Se voc\u00ea n\u00e3o limpar usando free(), a RAM apodrecer\u00e1 lentamente (LEAK)\n    free(array_gigante_dinamico);\n}\n</code></pre> Diferenciais do C/C++ <p>Voc\u00ea \u00e9 o \u00fanico \u00e1rbitro. Diferente de Java, Python ou C# que usam complexos rob\u00f4s vasculhadores ocultos (Garbage Collectors) na sombra consumindo at\u00e9 20% do processador para auditar seu Heap e limpar os lixos. O Rust automatiza e barra aloca\u00e7\u00f5es indevidas usando Ownership sem o robozinho. O C++ fornece ferramentas novas e maduras (<code>std::unique_ptr</code> ou <code>std::shared_ptr</code>) baseadas na contagem de refer\u00eancia.</p>"},{"location":"aulas/aula-07/#3-memory-leaks-vazamentos-de-memoria","title":"\ud83d\udc80 3. Memory Leaks (Vazamentos de Mem\u00f3ria)","text":"<p>Um cl\u00e1ssico e letal bug de engenharia C++. Quando o desenvolvedor executa <code>new</code> ou <code>malloc</code> solicitando mem\u00f3ria do Heap, mas quebra regras do fluxo perdendo o contato formal do ponteiro retornado do hardware sem antes ter reportado o fim via <code>delete</code> ou <code>free</code>. Resultado?  Aquela fatia na RAM f\u00edsica do servidor Linux ficar\u00e1 congelada, cega, retida unicamente pro seu app at\u00e9 que a nuvem AWS exaure toda a m\u00e1quina do container num erro de Kernel <code>OOM Killer (Out Of Memory)</code>.</p> <p>Em contra-partida: Dangling Pointers. Usar a \u00e1rea que o ponteiro apontava depois da liberta\u00e7\u00e3o formal do free provoca instabilidade instant\u00e2nea e corrup\u00e7\u00e3o silenciosa nos endere\u00e7os da placa-m\u00e3e.</p>"},{"location":"aulas/aula-07/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se n\u00e3o sabe onde colocar: Bote no STACK.</li> <li>\u00c9 muito grande pra caber (Strings longas ou Arrays): Invoque HEAP com o <code>std::vector</code> (ele gerencia o malloc e free na destrui\u00e7\u00e3o de escopo).</li> </ul>"},{"location":"aulas/aula-07/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 08</p>"},{"location":"aulas/aula-08/","title":"Aula 08 - Mem\u00f3ria Virtual","text":""},{"location":"aulas/aula-08/#aula-08-memoria-virtual","title":"Aula 08 - Mem\u00f3ria Virtual","text":"<p>Se voc\u00ea pedir ao seu S.O. no Task Manager por quantos Gigabytes os aplicativos rodam, ver\u00e1 que a soma ultrapassa facilmente a capacidade real f\u00edsica do pente de RAM DDR inserido na placa m\u00e3e. Como isso \u00e9 magicamente contido?</p>"},{"location":"aulas/aula-08/#1-o-abismo-logico-a-memoria-virtual","title":"\ud83d\udd73\ufe0f 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual","text":"<p>Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center.</p> <p>Todo processo que o Linux constr\u00f3i roda dentro de uma gigante Ilus\u00e3o. O endere\u00e7o do seu ponteiro <code>0x7ffeeB...</code> em C++ \u00e9 falso (Endere\u00e7o L\u00f3gico).</p> <p>O HW (Hardware MMU no processador) mais as planilhas do Sistema Operacional (Page Tables) formencem a liga\u00e7\u00e3o din\u00e2mica e escondida pra sua aplica\u00e7\u00e3o.</p> <pre><code>graph LR\n    A[\"Ponteiro em C++&lt;br/&gt;(Virtual 0x01)\"] --&gt; B{\"MMU e&lt;br/&gt;Page Table\"}\n    B --&gt; C(\"Mem\u00f3ria RAM&lt;br/&gt;(F\u00edsica Pente 1)\")\n    B -. \"Se n\u00e3o houver espa\u00e7o\" .-&gt; D(\"Swap / Pagefile&lt;br/&gt;(SSD)\")</code></pre> <p>A Mem\u00f3ria Virtual (VM) \u00e9 um sandu\u00edche mental e isolador protetor usado pelo S.O. Ela entrega para o ponteiro do processo o pretexto visual de que ele tem toda a mem\u00f3ria que ele quiser num universo cont\u00ednuo livre.</p>"},{"location":"aulas/aula-08/#2-tlb-mmu-e-a-traducao-da-pagina","title":"\ud83d\udcc4 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina","text":"<p>Cada tradu\u00e7\u00e3o do falso ponteiro visual com base nas tabelas em RAM \u00e9 custoso (Cycle Penalty).</p> <p>Para driblar isso, a arquitetura moderna usa a TLB (Translation Lookaside Buffer). A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso vira bloco 344 do pente de DDR5 real\".</p> Page Hit e Page Fault <ul> <li>Page Hit: A tradu\u00e7\u00e3o ocorreu instat\u00e2neamente pela cache veloz na CPU (a TLB validou o ponteiro do C++ localizando logo onde est\u00e1 no metal a vari\u00e1vel no chip Kingston).</li> <li>Page Fault Limitrofico: A TLB errou e teve que rolar pra Main RAM puxando o endere\u00e7o mapeado localizando num novo cluster na pilha. (100+ ciclos)</li> <li>Page Fault Cr\u00edtico (SWAP): A m\u00e1quina n\u00e3o acha e entra em Swapping com o SSD (SSD Swap). \u00c9 ali que ocorre as quedas colossais para \"Travamento de Janela\", a CPU foi pro SSD buscar um arquivo gigante que o Linux ejetou l\u00e1, pra trazer e rebotar pra cima pra Mem\u00f3ria RAM f\u00edsica real, jogando pro seu c\u00f3digo que achava estar \"na mem\u00f3ria\" e dormiu (Milh\u00f5es de ciclos).</li> </ul>"},{"location":"aulas/aula-08/#3-driblando-a-paginacao-como-programador","title":"\ud83d\udcaa 3. Driblando a Pagina\u00e7\u00e3o como Programador","text":"<p>Ao iterarmos matrizes massivas (Matrizes 2D em C++) na ordem invertida ou em l\u00f3gicas dispersas <code>LinkedList-&gt;prox</code>, voc\u00ea n\u00e3o causa apenas Cache Miss da Aula 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes TLB Misses! Voc\u00ea induzir\u00e1 Page Faults insanos que derrubar\u00e3o o throughput (taxa de transfer\u00eancia de dados) em N fatores.</p> <p>Portanto: Localidade Espacial \u00e9 sagrada em Dados C/C++.</p>"},{"location":"aulas/aula-08/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>O ponteiro que o dev manipula com um <code>int *ptr = &amp;value</code> em qualquer IDE \u00e9 puramente 100% Virtual. \u00c9 o passaporte intermedi\u00e1rio.</li> <li>Nunca dependa da pagina\u00e7\u00e3o e arquivo local de Swap do Disco: os mil\u00e9simos de segundo viram minutos na Nuvem se o app \"estourar a cota da cloud\", sofrendo <code>Thrashing</code> com o Disco local para falsificar a RAM que ele acreditou ter num loop mal codificado ou em Leaks do M\u00f3dulo/Aula anterior.</li> </ul>"},{"location":"aulas/aula-08/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 09</p>"},{"location":"aulas/aula-09/","title":"Aula 09 - Processos e Threads","text":""},{"location":"aulas/aula-09/#aula-09-processos-e-threads","title":"Aula 09 - Processos e Threads","text":"<p>\u00c9 vital dominar como espalhar execu\u00e7\u00f5es concorrentes na topologia de m\u00faltiplos n\u00facleos nos processadores de hoje. Caso contr\u00e1rio, um computador com 32 cores rodar\u00e1 seu backend Python (que possui GIL) de alt\u00edssima lat\u00eancia amargando 31 n\u00facleos ociosos gastando energia.</p>"},{"location":"aulas/aula-09/#1-processos-isolamento-forte","title":"\ud83c\udfc3 1. Processos (Isolamento Forte)","text":"<p>O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>).</p> <ul> <li>O S.O. d\u00e1 ao Processo sua pr\u00f3pria e exclusiva Mem\u00f3ria Virtual (visto na Aula 8).</li> <li>O Processo tem sua exclusiva Pilha e n\u00e3o se mistura nunca. E isso isola falhas: se um Chrome (processo isolado) trava, n\u00e3o d\u00e1 tela azul na outra aba.</li> <li>A comunica\u00e7\u00e3o entre Processos (IPC - Inter-process Communication) \u00e9 pesada e necessita do S.O. atrav\u00e9s de Pipes ou Redes. </li> </ul>"},{"location":"aulas/aula-09/#2-threads-isolamento-fraco-partilha","title":"\ud83e\uddf5 2. Threads (Isolamento Fraco / Partilha)","text":"<p>Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para Multithreading!</p> <pre><code>graph TD\n    A(\"Processo (ID: 5599) - Backend Web\") --&gt; B[(\"Heap Memory (Compartilhado)\")]\n    A --&gt; C[\"Thread 01 (Rota A)\"]\n    A --&gt; D[\"Thread 02 (Rota B)\"]\n    A --&gt; E[\"Thread 03 (Pool C)\"]\n\n    C --&gt; F((Stack Exclusiva T1))\n    D --&gt; G((Stack Exclusiva T2))\n    E --&gt; H((Stack Exclusiva T3))\n\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E</code></pre> <p>Uma Thread \u00e9 simplesmente uma subdivis\u00e3o leve controlada do processo. Elas todas orbitam e vivem na exata MESMA MEM\u00d3RIA VIRTUAL (Heap) DO PROCESSO MESTRE.</p> Benef\u00edcioCat\u00e1strofe <p>Duas <code>std::thread</code> manipulando os ponteiros apontam rigorosamente r\u00e1pido ao mesmo endere\u00e7o na RAM sem nenhuma barreira do S.O., o que traz milisegundos imbat\u00edveis versus IPC!</p> <p>Como ambas alteram ativamente a mesm\u00edssima RAM viva desprotegidas, se elas lerem/sobreescreverem juntas o mesmo byte int da Conta Banc\u00e1ria C++, ocorre o let\u00edfero e maldoso Data Race (Condi\u00e7\u00e3o de Corrida de Dados).</p>"},{"location":"aulas/aula-09/#3-context-switch-a-faca-de-dois-gumes","title":"\u2699\ufe0f 3. Context Switch (A Faca de Dois Gumes)","text":"<p>Quando escrevemos <code>\"Hello World\"</code>, achamos que a CPU roda por horas sem interrup\u00e7\u00f5es. Engano.</p> <p>O S.O. possui um n\u00facleo (Kernel Scheduler) que fatia mil\u00e9simos de mil\u00e9simos de segundos distribuindo uma core <code>i7-P</code> para a aba do Google, logo retira o Google e taca nos frames do VS-Code, em micro-loop alternante de Context Switches. O problema? Puxar e devolver o estado (registradores, program counter) na cache \u00e9 hiper custoso e derruba o Pipeline se abusado (overhead em CPU bound apps).</p>"},{"location":"aulas/aula-09/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se a tarefa for CPU-Bound (requerer Matem\u00e1tica Bruta Massiva / Machine Learning), voc\u00ea cria Threads numerando-as pr\u00f3ximo n\u00famero oficial de n\u00facleos estritos da CPU, evitando desperd\u00edcio de overhead com Context Switches ilus\u00f3rios.</li> <li>\u00c9 muito f\u00e1cil em C/C++ estragar a vida financeira do cliente numa Race Condition compartilhada pelo Heap se n\u00e3o protegida... mas isso \u00e9 o tema da pr\u00f3xima aula!</li> </ul>"},{"location":"aulas/aula-09/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 10</p>"},{"location":"aulas/aula-10/","title":"Aula 10 - Sincroniza\u00e7\u00e3o","text":""},{"location":"aulas/aula-10/#aula-10-sincronizacao-e-concorrencia","title":"Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":"<p>Como abordado na Aula 09, a vantagem da extrema performance das Threads nativas possu\u00edrem acesso irrestrito e descontrolado \u00e0 mesma Mem\u00f3ria do processo C++ pode culminar na trag\u00e9dia iminente conhecida como de Condi\u00e7\u00e3o de Corrida (Race Condition). </p>"},{"location":"aulas/aula-10/#1-o-data-race-uma-colisao-inevitavel","title":"\ud83c\udfce\ufe0f 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel","text":"<p>Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\". O HW (Processador) traduz internamente num RMW: Read (Puxa os 100 da RAM para o Registrador EAX), Modify (Adiciona +10 e vira 110 na ALU), e Write (Substitui na RAM os antigos 100 por 110).</p> <p>Se na fresta entre a Thread 1 preencher o EAX e depois descer ao RAM o valor 110... a Thread 2 rodar e \"puxar os mesm\u00edssimos originais 100\" para outro registrador (Context Switch), quando abas enviarem pra RAM final as sobreposi\u00e7\u00f5es as contas, um dos <code>10</code> desvanecer\u00e1, o banco perde e a vari\u00e1vel fica logicamente corrompida.</p>"},{"location":"aulas/aula-10/#2-mutex-e-the-critical-section","title":"\ud83d\udee1\ufe0f 2. Mutex e The Critical Section","text":"<p>A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As Locks (Travas) como padr\u00e3o Ouro C++: <code>std::mutex</code> (Mutual Exclusion).</p> <pre><code>$ # Em C++, protege-se a vari\u00e1vel central assim:\n$ cat bank.cpp\nstd::mutex portaCorredor;\n\nvoid adiciona_10() {\n    portaCorredor.lock();   // O Hardware garante atomicamente exclus\u00e3o\n    balance += 10;          // Apenas UM transita aqui adentro. \n    portaCorredor.unlock(); // O primeiro sai da sala, e notifica o Kernel\n}\n</code></pre> <p>A \u00e1rea demarcada pelo lock a unlock \u00e9 intitulada Se\u00e7\u00e3o Cr\u00edtica. O poder e o problema do design residem a\u00ed: Se voc\u00ea for pregui\u00e7oso e prender 10.000 linhas da sua transa\u00e7\u00e3o atr\u00e1s da Se\u00e7\u00e3o Cr\u00edtica Mestre, o teu glorioso Processador Multicore Ultra de 32 cores se comportar\u00e1 como um rid\u00edculo e solit\u00e1rio Processador Antigo Pentium de 1 core single Threaded, derrubando teu design ao zero! Tudo vai rodar Enfileirado (Serializado). O bom C++ trava com extrema granuladidade e rapid\u00edssimo na vari\u00e1vel.</p>"},{"location":"aulas/aula-10/#3-o-dilema-deadlock","title":"\ud83d\udea6 3. O Dilema: Deadlock","text":"<p>Mas e se o programador de Backend C/C++ prender (usou lock() ou Mutex) em A esperando que B seja terminado.. mas B s\u00f3 termina porque B precisa pegar lock() em A que t\u00e1 bloqueado?</p> <p>Ambos processos morrem na tela, dormindo inertes (Blocked State), enquanto a barra de % CPU despenca lentamente para ZERO! Seu Sistema Paralelo entrou em Deadlock. (O Abra\u00e7o Mortal Padr\u00e3o The Dining Philosophers). Um design multi-thread exige uma heuristica sagrada de adquirir as trancas Lock C++ em id\u00eantica e constante ordem arquitetural atrav\u00e9s dos sistemas, ou apelar a mec\u00e2nicas <code>std::lock()</code> que aplicam garantias subjacentes do Kernel.</p>"},{"location":"aulas/aula-10/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Mutex: Usa o sistema do n\u00facleo para trancar \u00e1reas exclusivas do Hardware (RAM).</li> <li>Se a concorr\u00eancia n\u00e3o tiver \"Se\u00e7\u00e3o Cr\u00edtica\" que lida com Grava\u00e7\u00e3o e tiver \"S\u00f3 Read-only\", n\u00e3o aplique trancas (Mutex) para n\u00e3o serializar as Threads da m\u00e1quina.</li> </ul>"},{"location":"aulas/aula-10/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 11</p>"},{"location":"aulas/aula-11/","title":"Aula 11 - Paralelismo em Hardware","text":""},{"location":"aulas/aula-11/#aula-11-paralelismo-no-hardware","title":"Aula 11 - Paralelismo no Hardware","text":"<p>O c\u00f3digo Multithreading (visto na Aula 09 e 10) \u00e9 uma abstra\u00e7\u00e3o do Sistema Operacional. Mas como a f\u00edsica do processador de fato abra\u00e7a m\u00faltiplas frentes de execu\u00e7\u00e3o sim\u00e9trica simult\u00e2nea?</p>"},{"location":"aulas/aula-11/#1-multi-core-multiplos-nucleos","title":"\ud83c\udfd7\ufe0f 1. Multi-Core (M\u00faltiplos N\u00facleos)","text":"<p>Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip).</p> <ul> <li>Core F\u00edsico: \u00c9 uma CPU completa e independente, com sua pr\u00f3pria ALU, Unidade de Controle e Caches L1/L2 particulares.</li> <li>Cache L3 Compartilhado: Na maioria dos designs AMD e Intel reais, os M\u00faltiplos Cores (Ex: 8 Cores) conversam e trocam estados atrav\u00e9s de uma suntuosa e lenta \u00e1rea comum L3 que circunda todos os processadores ali impressos no wafer.</li> </ul> <p>[!TIP] Em Backend pesado: Se o banco mapear duas Threads puras <code>backend</code> em dois Cores puramente isolados (Ex: Core 0 e Core 1), e elas lerem/trabalharem na mesma matriz cont\u00ednua, o Hardware for\u00e7ar\u00e1 interc\u00e2mbios el\u00e9tricos no Cache Coherence Protocol (MESI) rodando por toda placa m\u00e3e. Fiquem espertos com o False Sharing! </p>"},{"location":"aulas/aula-11/#2-hyper-threading-smt-symmetrical-multi-threading","title":"\ud83e\uddec 2. Hyper-Threading (SMT - Symmetrical Multi-Threading)","text":"<p>A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux?</p> <p>Na aula 03, vimos que a execu\u00e7\u00e3o cruza pelo Pipeline ou pode esbarrar em ciclos ociosos na CU aguardando a Mem\u00f3ria Principal. O Hyper-Threading espeta um Segundo conjunto de Registradores e Hardware de Estado no mesmo Core. Enquanto o c\u00f3digo da Thread \"A\" est\u00e1 0.5 nanosegundo travada esperando chegar o dado lento da L3, o Core troca instantaneamente para o contexto da Thread \"B\", executando-o usando as mesmas Unidades L\u00f3gicas (ALU) num aproveitamento fabril monstruoso de 100%.</p> <pre><code>$ # Lendo o processador em Linux (Ex: i7 4-Core com HyperThreading)\n$ lscpu\nCPU(s):                  8\nOn-line CPU(s) list:     0-7\nThread(s) per core:      2\nCore(s) per socket:      4\n</code></pre> <p>Vemos 8 CPUs acima, mas fisicamente a m\u00e1quina tem 4 motores reais. </p>"},{"location":"aulas/aula-11/#3-gpus-o-paralelismo-macico","title":"\ud83c\udfae 3. GPUs: O Paralelismo Maci\u00e7o","text":"<p>CPUs (Processadores) foram feitos para \"Serem R\u00e1pidos executando sequ\u00eancias l\u00f3gicas e IFs complexos\". Possuem Caches gigantes. GPUs (Placas de V\u00eddeo) foram feitas para \"Executar a MESM\u00cdSSIMA MIN\u00daSCULA matem\u00e1tica simultaneamente em milhares de pixels fracos\". Sem grandes condicionais, focando no Throughput. </p> <p>NVIDIA e CUDA (plataforma de C++) reinam supremas em Deep Learning e Criptografia exatamente porque pegam Loops For gigantescos de \u00c1lgebra Linear, e fracionam em 8.000 mini-n\u00facleos (CUDA cores) esmagando qualquer Intel Core i9 na lat\u00eancia matem\u00e1tica cont\u00ednua pura.</p>"},{"location":"aulas/aula-11/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Task Paralelism: Se tens l\u00f3gica variada, use a CPU Multi-Core C++ thread pool.</li> <li>Data Paralelism: Se a conta for a repeti\u00e7\u00e3o retumbante de um algoritmo id\u00eantico sobre 2 milh\u00f5es de dados sem depend\u00eancia de saltos complexos, mova-a da RAM \u00e0 VRAM da GPU via CUDA/OpenCL. A m\u00e9trica vai das horas paras os d\u00e9cimos de segundo.</li> </ul>"},{"location":"aulas/aula-11/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 12</p>"},{"location":"aulas/aula-12/","title":"Aula 12 - Modelo de Mem\u00f3ria","text":""},{"location":"aulas/aula-12/#aula-12-o-modelo-de-memoria","title":"Aula 12 - O Modelo de Mem\u00f3ria","text":"<p>Ao nos aventurarmos com <code>C/C++</code> moderno em sistemas de Alta-Concorr\u00eancia, a pr\u00f3pria sanidade da ordem do c\u00f3digo \u00e9 subvertida e o que julg\u00e1vamos executar \"em sequ\u00eancia\", esfacela-se nos pipelines de CPU. Bem-vindos ao labirinto da Reordena\u00e7\u00e3o.</p>"},{"location":"aulas/aula-12/#1-a-reordenacao-do-compilador-e-cpu-out-of-order-execution","title":"\ud83d\udd00 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution)","text":"<p>Voc\u00ea codifica: </p><pre><code>int x = 0;\nint FLAG = false;\n\n// Em uma Thread Secund\u00e1ria\nx = 42;         // PASSO A\nFLAG = true;    // PASSO B\n</code></pre><p></p> <p>Um programador esperan\u00e7oso diz: \"Vou ler a v\u00e1riavel na Thread Oposta (Main)... e quando <code>FLAG</code> for true, sei que <code>X</code> \u00e9 impreterivelmente 42 pois executei a linha acima primeiro na tela!\"</p> <p>FALSO! MORTALMENTE FALSO!</p> <ol> <li>O Compilador C++ (GCC -O3) pode achar que o PASSO B \u00e9 irrelevante para o PASSO A (n\u00e3o usam das mesmas m\u00e9tricas) e reordenar por conta pr\u00f3pria o seu execut\u00e1vel para gravar a FLAG e depois o 42 nas linhas do assembly.</li> <li>O CISC (Intel x86) Processador Superscalar Out-Of-Order percebe que a posi\u00e7\u00e3o de <code>x</code> estava fria na Cache L3, mas a vari\u00e1vel <code>FLAG</code> estava quente presa na L1D. Ele salva na FLAG imediatamente (Store Buffers), adiantando a etapa 2, antes da 1, para n\u00e3o morrer de \u00f3cio no Pipeline. E seu c\u00f3digo multi-thread infarta com B chegando a ser lido remotamente como TRUE com A ainda em <code>0</code> (zero)!!</li> </ol>"},{"location":"aulas/aula-12/#2-o-memory-model-consistencias-e-barreiras","title":"\ud83d\udea7 2. O Memory Model (Consist\u00eancias e Barreiras)","text":"<p>O C++11 emitiu formalmente o seu universal Memory Model definindo atrav\u00e9s da biblioteca <code>std::atomic</code> o que o Hardware tem permi\u00e7\u00f5es para Adiantar vs Trancar.</p> <ol> <li>Relaxed Consistensy (<code>std::memory_order_relaxed</code>): A CPU \u00e9 dona, reordene como quiser em torno da sua vizinhan\u00e7a na RAM, apenas aplique na thread isolada em seguran\u00e7a. Performance brutal.</li> <li>Release / Acquire (<code>std::memory_order_acquire / release</code>): O padr\u00e3o para transferir fardos (como ler a Fila sem locks e sem medo da Out-Of-Order embaralhar flags finalizadoras de Loop C++ no hardware alheio do *Core 2).</li> <li>Sequential Consistency (<code>std::memory_order_seq_cst</code>): O C++ por default invoca barreiras completas absolutas el\u00e9tricas. For\u00e7a todas as cores (L1/L2) da CPU e do compilador a n\u00e3o alterarem NADA a ordem que seu texto determinou. Seguro, mas castrador de velocidade em processadores ARM.</li> </ol>"},{"location":"aulas/aula-12/#3-memory-barriers-fences-nas-cpus","title":"\ud83e\uddf1 3. Memory Barriers (Fences) nas CPUs","text":"<p>Se n\u00e3o tivessemos essa lei <code>std::atomic</code> no standard oficial do GCC, program\u00e1vamos via \"Gambiarra Intrinseca\" de Processador (Ex: Comando Assembler MFENCE ou SFENCE no Intel). Os Fences pro\u00edbem categoricamente a travessia de saltos das sub-opera\u00e7\u00f5es em Assembly, estancando a execu\u00e7\u00e3o como um sinaleiro fechado.</p> <p>[!INFO] \u00c9 por isso que programar Software Infra-estrutural de Baixo N\u00edvel (Databases, Motores de Redes Socket, SO Kernel Driver) \u00e9 extremamente dif\u00edcil: As reordena\u00e7\u00f5es da CPU nunca acontecem quando voc\u00ea depura linha a linha na IDE (pois a paralela n\u00e3o \u00e9 instigada). Elas s\u00f3 geram corrup\u00e7\u00f5es bizarras rand\u00f4micas 1x na vida e morrem meses na escura neblina de servidores reais operando 100 mil Requests por Minuto no DataCenter. Onde a press\u00e3o el\u00e1stica exaure as Caches e exp\u00f5e seus Bugs de Memory Models relaxados.</p>"},{"location":"aulas/aula-12/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se duas \"Threads\" conversam atrav\u00e9s das mesmas vari\u00e1veis limpas de C e n\u00e3o possuam <code>std::mutex</code> da aula 10 as blindando, USE <code>std::atomic&lt;bool&gt;</code>. Do contr\u00e1rio voc\u00ea \u00e9 uma v\u00edtima da Superscalar Out Of Order Intel Architecture Pipeline (a reordena\u00e7\u00e3o el\u00e9trica).</li> </ul> <p>Isso enterra as nuances sombrias das mem\u00f3rias RAM + Cache. Agora mergulhemos no escuro do \"Lento Discovoador\": Os Armazenamentos (Avan\u00e7ar).</p>"},{"location":"aulas/aula-12/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 13</p>"},{"location":"aulas/aula-13/","title":"Aula 13 - Dispositivos de Armazenamento","text":""},{"location":"aulas/aula-13/#aula-13-dispositivos-de-armazenamento","title":"Aula 13 - Dispositivos de Armazenamento","text":"<p>Descendo a pir\u00e2mide de mem\u00f3ria, deixamos a r\u00e1pida (por\u00e9m vol\u00e1til) RAM e ca\u00edmos no dom\u00ednio da persist\u00eancia permanente. O armazenamento \u00e9 inerentemente mais lento, e sua taxonomia dita o Design do seu Banco de Dados Central.</p>"},{"location":"aulas/aula-13/#1-hdd-hard-disk-drive-vs-ssd-sata","title":"\ud83d\udcbd 1. HDD (Hard Disk Drive) vs SSD (SATA)","text":"HDD Magn\u00e9ticoSSD (Solid State Drive SATA) <p>O disco de pratos girat\u00f3rios com uma agulha f\u00edsica.  Lat\u00eancia: O motor precisa literalmente girar (Seek Time e Lat\u00eancia Rotacional) at\u00e9 o bloco desejado. As leituras sequenciais (filmes grandes cont\u00ednuos) s\u00e3o aceit\u00e1veis, mas Random Access (leitura rand\u00f4mica de pequenos arquivos) \u00e9 catastr\u00f3fica, beirando a eternidade computacional.</p> <p>Armazenamento em chips de mem\u00f3ria Flash (NAND). Zero partes m\u00f3veis. Lat\u00eancia: Mil vezes superior ao HDD em acesso Rand\u00f4mico. Seu Banco de Dados Relacional MySQL renasce num SSD porque consegue varrer os \u00edndices disparatadamente sem esperar \"O disco girar\". Ele satura, por\u00e9m, a banda do Barramento SATA (m\u00e1x. 600 MB/s).</p>"},{"location":"aulas/aula-13/#2-nvme-o-limite-pcie","title":"\u26a1 2. NVMe (O Limite PCIe)","text":"<p>Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em que passam Gigabytes por segundo (ex: Gen4 cruza 7.000 MB/s).</p> <p>Isto alterou para sempre o Backend moderno: Os Softwares de Mem\u00f3ria In-Memory (Redis) est\u00e3o repensando paradigmas pois o Disco NVMe moderno \u00e0s vezes responde com velocidade que ro\u00e7a a velha mem\u00f3ria RAM DDR3!</p>"},{"location":"aulas/aula-13/#3-iops-a-metrica-real-do-servidor","title":"\ud83d\udcc8 3. IOPS - A M\u00e9trica Real do Servidor","text":"<p>Se a banda (MB/s) diz o volume da mangueira, os IOPS (Input/Output Operations Per Second) dizem quantos golpes a mangueira d\u00e1 por segundo. </p> <ul> <li>Quando voc\u00ea hospeda um App Node/Python que grava 1 milh\u00e3o de pequenos logs <code>.txt</code> de 1KB, n\u00e3o importa se voc\u00ea tem 7000 MB/s. Voc\u00ea precisa de IOPS Alt\u00edssimos, para que a fila matem\u00e1tica de Write Requests n\u00e3o trave seu servidor (<code>I/O Wait / Blocked</code>). </li> </ul> <p>[!CAUTION] Ao configurar a AWS (Amazon Cloud), inst\u00e2ncias EBS (Discos el\u00e1sticos anexados) cobram mais caro pela volumetria de IOPS. O gargalo da sua API lenta de CRUD nunca \u00e9 a CPU, geralmente \u00e9 porque o Disco Estourou sua cota de Burst de IOPS. </p>"},{"location":"aulas/aula-13/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<p>O desenvolvedor C++ entende isso programando a I/O por grandes lotes (<code>Buffers</code>). N\u00e3o escreva no disco <code>1 byte</code> no la\u00e7o for por <code>1 milh\u00e3o de vezes</code> (Destrui\u00e7\u00e3o de IOPS). Acumule os dados num Buffer gig\u00e2ntico de <code>1 MB</code> na RAM, e comande gravar os dados no SSD em \u00fanico e massivo Request! (Otimiza\u00e7\u00e3o m\u00e1xima de Throughput).</p>"},{"location":"aulas/aula-13/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 14</p>"},{"location":"aulas/aula-14/","title":"Aula 14 - Sistemas de Arquivos","text":""},{"location":"aulas/aula-14/#aula-14-sistemas-de-arquivos","title":"Aula 14 - Sistemas de Arquivos","text":"<p>Um Hardware (SSD vazio) nada mais \u00e9 que um deserto de bilh\u00f5es de celulas sil\u00edcio aptas a guardar carga est\u00e1tica. Sem um <code>Software Organizador</code>, \u00e9 indom\u00e1v\u00e9l. O File System (Sistema de Arquivos) \u00e9 esse gerenciador fornecido pelo Sistema Operacional.</p>"},{"location":"aulas/aula-14/#1-o-v-node-inode","title":"\ud83d\uddc2\ufe0f 1. O V-Node / Inode","text":"<p>Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster.  O FS usa de \u00edndices num\u00e9ricos ultra-r\u00e1pidos: os Inodes. </p> <pre><code>graph LR\n    A[\"Diret\u00f3rio /Docs\"] --&gt;|12345| B(\"Inode 12345\")\n    B --&gt; C[\"Tamanho: 2MB\"]\n    B --&gt; D[\"Permiss\u00f5es: rwxr-xr-x\"]\n    B --&gt; E[\"Blocos F\u00edsicos de Dados\"]\n    E --&gt; F[\"Cluster 80 no SSD\"]\n    E --&gt; G[\"Cluster 89 no SSD\"]</code></pre> <p>[!INFO] Por que o comando de Deletar (rm) um arquivo grande \u00e9 quase instant\u00e2neo, mas copiar \u00e9 lento? O <code>rm</code> apaga apenas a entrada no \u00cdndice (Inode), fingindo pro SO que o espa\u00e7o t\u00e1 livre. O dado mesmo ainda t\u00e1 l\u00e1 magnetizado at\u00e9 algo escrever por cima (Por isso existem softwares de recupera\u00e7\u00e3o de dados!)</p>"},{"location":"aulas/aula-14/#2-journaling-a-prova-contra-quedas","title":"\ud83d\udee1\ufe0f 2. Journaling (A Prova contra Quedas)","text":"<p>Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode. E se faltar luz na etapa 2? A parti\u00e7\u00e3o corromperia inteiramente para sempre (Problema antigo do FAT32).</p> <p>FSs modernos (NTFS, EXT4) usam Journaling. Antes de aplicar qualquer mudan\u00e7a no Inode oficial, eles \"anotam a inten\u00e7\u00e3o do que v\u00e3o fazer\" num Di\u00e1rio Oculto (Journal). Se a luz cai, ao ligar o PC, ele l\u00ea o di\u00e1rio oculto incompleto, reverte o estrago e devolve sua m\u00e1quina salva! \u00c9 a ess\u00eancia do conceito Atomicidade.</p>"},{"location":"aulas/aula-14/#3-buffers-e-page-cache-por-que-linux-e-rapido","title":"\ud83d\ude84 3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido)","text":"<p>\"Escrever no disco\" via SysCall C++ <code>write()</code> ou <code>fwrite()</code> raramente vai pro HD! O Linux usa de forma abusiva toda a RAM ociosa do seu computador como um gigantesco Cache File. Ele capta suas writes e diz \"Gravei amig\u00e3o!\" mas jogou na RAM (Page Cache). Posteriormente ele realiza os envios reais para o Hardware agrupados (Flush / Sync).</p> <p>Essa m\u00e1gica salva a Morte do seu SSD (menos grava\u00e7\u00f5es simult\u00e2neas em desgaste das celulas NAND) e simula uma ilus\u00e3o de lentid\u00e3o zero ao usu\u00e1rio.</p>"},{"location":"aulas/aula-14/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Ao usar C/C++, chame o instr\u00ednseco <code>fsync()</code> se seu App for um Banco de Dados ou Software Cr\u00edtico Banc\u00e1rio for\u00e7ando a Cache RAM descarregar a for\u00e7a e salvar permanentemente no sil\u00edcio do disco.</li> <li>Nunca dependa da nomenclatura C: <code>/usr/foto.jpg</code>. Leia descritores de arquivo, file-pointers e fluxos bin\u00e1rios se for transitar redes em baixo n\u00edvel.</li> </ul>"},{"location":"aulas/aula-14/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 15</p>"},{"location":"aulas/aula-15/","title":"Aula 15 - Entrada e Sa\u00edda (I/O)","text":""},{"location":"aulas/aula-15/#aula-15-entrada-e-saida-io","title":"Aula 15 - Entrada e Sa\u00edda (I/O)","text":"<p>Se o Processador e a Mem\u00f3ria trabalham num rel\u00f3gio bilion\u00e1rio (GHz), como eles se comunicam com o Teclado USB do seu usu\u00e1rio ou sua Placa de Rede cuja resposta se mede nas lentas m\u00e9tricas de milissegundos?</p>"},{"location":"aulas/aula-15/#1-system-calls-o-pedagio-do-kernel","title":"\ud83d\udeaa 1. System Calls (O Ped\u00e1gio do Kernel)","text":"<p>Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminante encerramento compuls\u00f3rio pelo Processador atrav\u00e9s do bloqueio de An\u00e9is de Prote\u00e7\u00e3o.</p> <p>Para acionar a Rede, o C++ precisa paralisar, invocar a sagrada System Call (Syscall, ex: write, sendto, read) que abre o portal para o S.O (Kernel Space). \u00c9 o Kernel Linux quem vai orquestrar a placa C de Ethernet.</p>"},{"location":"aulas/aula-15/#2-interrupcoes-vs-polling","title":"\u26a0\ufe0f 2. Interrup\u00e7\u00f5es vs Polling","text":"<p>Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\". 1. Polling (Desastroso): A CPU fica travada rodando <code>while(mouse_is_empty) {}</code> perguntando de nano em nanosegundo \"Chegou? E agora? E Agora?\". (Suga 100% da CPU por um mouse inerte). 2. Interrupts (Moderno): A CPU delega para o controlador USB rodar a escuta passiva, e a CPU volta a fechar os frames de Game. Quando o usu\u00e1rio clica com o dedo, o Controlador injeta um choque el\u00e9trico no pino do Processador. Interrupt request (IRQ)! A CPU congela subitamente o Game, salva o contexto, trata o clique do Mouse rapidamente, e exuma a cena do Game novamente do congelamento.</p>"},{"location":"aulas/aula-15/#3-dma-memoria-com-acesso-direto","title":"\ud83d\ude80 3. DMA (Mem\u00f3ria com Acesso Direto)","text":"<p>Mesmo com as Interrup\u00e7\u00f5es ajudando a n\u00e3o ficar paralisado Polling... Fazer a Placa de Rede encher a placa RAM transitando Bit a Bit passando pelo miolo doloroso da CPU era impratic\u00e1vel em Gigabit Ethernets.</p> <p>A revolu\u00e7\u00e3o moderna chama-se Direct Memory Access (DMA). Placas de Captura, NVMe e Placas de Rede conversam Diretamente com a Mem\u00f3ria RAM por vias de bypass.</p> <pre><code>graph BT\n    A[\"Placa de Rede\"] -- \"Caminho Direto (DMA)\" --&gt; B[\"Mem\u00f3ria RAM\"]\n    A -. \"Aviso via IRQ\\n(Terminei!)\" .-&gt; C[\"CPU\"]\n    C -. \"Ordens Lentas\" .-&gt; B</code></pre> <p>A CPU diz: \"Placa, baixe o NetFlix do Ponto P pro Q na RAM\". A Placa faz todo os trabalho violento por tr\u00e1s. A CPU usa seu pipeline pra c\u00e1lculos e matem\u00e1tica puros, enquanto sua mem\u00f3ria vai sendo injetada pela placa de v\u00eddeo via t\u00faneis secretos pelas pontes.</p>"},{"location":"aulas/aula-15/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se a sua aplica\u00e7\u00e3o Web Framework ass\u00edncrona (como NodeJS ou Nginx C++) trava muito com \"I/O\", isso significa que o Sistema delega opera\u00e7\u00f5es custosas pelo DMA ao Kernel, enquanto orquestra Event-Loops aguardando os famigerados Interrupts de retorno. </li> </ul> <p>Fim do estudo base te\u00f3rico, chegamos ao final. \u00c9 hora de compilar conhecimento na Otimiza\u00e7\u00e3o Pura (Aula Final).</p>"},{"location":"aulas/aula-15/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul> <p> Avan\u00e7ar para Aula 16</p>"},{"location":"aulas/aula-16/","title":"Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o","text":""},{"location":"aulas/aula-16/#aula-16-projeto-final-otimizacao-baseada-em-hardware","title":"Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":"<p>A teoria desacompanhada de medi\u00e7\u00f5es emp\u00edricas se torna pura ret\u00f3rica. A maturidade no universo Hardware/Software Interface em C/C++ ocorre ao expormos nosso c\u00f3digo compilado aos utilit\u00e1rios pesados de medi\u00e7\u00e3o (Profiling).</p>"},{"location":"aulas/aula-16/#1-profiling-classico-a-vida-real","title":"\u23f1\ufe0f 1. Profiling Cl\u00e1ssico (A Vida Real)","text":"<p>Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. Usamos ferramentas robustas para que a Arquitetura Linux diga-nos onde os gargalos fervem a CPU.</p> <ul> <li>gprof: O padr\u00e3o antigo C++. Ele recompila injetando marca\u00e7\u00f5es cont\u00e1beis nas idas e vindas de fun\u00e7\u00f5es, revelando \"Quais chamadas consumiram O Tempo Global\".</li> <li>Valgrind (Callgrind / Cachegrind): Ferramenta extrema rodando seu execut\u00e1vel numa sandbox virtual que mapeia cada instru\u00e7\u00e3o assembly. Traz gr\u00e1ficos massivos de onde Ocorreram os Caches Misses da Mem\u00f3ria L1 de nossa Aula 06!</li> <li>Perf: O utilit\u00e1rio nativo dos programadores Linux Kernel, extraindo informa\u00e7\u00f5es m\u00e9tricas em Eventos de Desvio (Branch Mispired da Aula 03) usando rel\u00f3gios internos dos registradores ocultos <code>PMU</code> do seu pr\u00f3prio Processador em tempo real, sem overhead sint\u00e9tico.</li> </ul>"},{"location":"aulas/aula-16/#2-o-grande-desafio-mini-projeto-pratico","title":"\ud83d\udd2c 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico)","text":"<p>O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware:</p> <pre><code>$ # Desafio do Iterador de Matriz Cont\u00ednua\n$ g++ matriz_opt.cpp -O3 -o matriz\n$ ./matriz \nItera\u00e7\u00e3o Horizontal (Hit L1): Tempo 140ms\nItera\u00e7\u00e3o Vertical (Miss L1): Tempo 2100ms\n</code></pre> <p>Requisitos do Projeto: 1. Alocar um Array gigantesco Massivo no Heap Din\u00e2mico via <code>malloc()</code> C (N\u00e3o use vectors prontos para sentir a dor no bra\u00e7o). 2. Criar duas l\u00f3gicas for(). 3. A primeira varre a matriz na exata sequencia alg\u00e9brica Row-Major. Explorando a TLB/Localidade da Aula 08 e 06. 4. O segundo For varre as colunas saltando a intervalos gigantescos. Omiss\u00f5es grotescas de Cache Miss. 5. Invoquem o <code>std::chrono</code> em volta das fun\u00e7\u00f5es, me\u00e7am os Mils e relatem num documento Markdown o porqu\u00ea de um Software ser 10 vezes mais r\u00e1pido que o outro mesmo usando \"a c\u00f3pia mental perfeitamente id\u00eantica das mesm\u00edssimas opera\u00e7\u00f5es de if e soma na ALU\".</p>"},{"location":"aulas/aula-16/#3-conclusao-da-trilha","title":"\ud83c\udfc6 3. Conclus\u00e3o da Trilha","text":"<p>Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada. Um engenheiro de Backend jamais olhar\u00e1 para <code>int x;</code> ou <code>for()</code> sem recordar os impactos t\u00e9rmicos, cache hits mortais de linha, L1 local, reordena\u00e7\u00f5es do std::atomic Memory Model ou Page Faults nos clusters de Sistema e Processos em Swap.</p> <p>Parab\u00e9ns pela resili\u00eancia no vale do Sil\u00edcio e da Matem\u00e1tica discreta profunda. Nunca pare de medir e Otimizar. O Hardware dita as leis; o Software obedece.</p> <p> Finalizar e Visitar Projetos</p>"},{"location":"aulas/aula-16/#proximos-passos","title":"\ud83c\udfaf Pr\u00f3ximos Passos","text":"<ul> <li> <p> Acessar Slides</p> <p>Reveja a apresenta\u00e7\u00e3o visual desta aula.</p> <p> Ver Slides da Aula</p> </li> <li> <p> Quiz</p> <p>Teste seu entendimento b\u00e1sico com perguntas r\u00e1pidas.</p> <p> Responder Quiz</p> </li> <li> <p> Exerc\u00edcios</p> <p>Pr\u00e1tica avan\u00e7ada e dissertativa com consulta.</p> <p> Lista de Exerc\u00edcios</p> </li> <li> <p> Projeto</p> <p>Laborat\u00f3rio pr\u00e1tico de codifica\u00e7\u00e3o em C/C++.</p> <p> Mini Projeto</p> </li> </ul>"},{"location":"exercicios/","title":"Listas de Exerc\u00edcios Pr\u00e1ticos","text":""},{"location":"exercicios/#listas-de-exercicios-praticos","title":"Listas de Exerc\u00edcios Pr\u00e1ticos","text":"<p>Cada sess\u00e3o de atividades progressivas envolve as din\u00e2micas mais comuns em arquitetura de baixo n\u00edvel C/C++.</p>"},{"location":"exercicios/#modulo-1-fundamentos-de-arquitetura-de-computadores","title":"M\u00f3dulo 1 \u2013 Fundamentos de Arquitetura de Computadores","text":"<ul> <li> Pr\u00e1tica 01 - Como o Software Roda no Hardware</li> <li> Pr\u00e1tica 02 - Representa\u00e7\u00e3o de Dados</li> <li> Pr\u00e1tica 03 - CPU: Estrutura e Funcionamento</li> <li> Pr\u00e1tica 04 - Arquiteturas RISC vs CISC</li> </ul>"},{"location":"exercicios/#modulo-2-memoria-e-performance","title":"M\u00f3dulo 2 \u2013 Mem\u00f3ria e Performance","text":"<ul> <li> Pr\u00e1tica 05 - Hierarquia de Mem\u00f3ria</li> <li> Pr\u00e1tica 06 - Cache e Localidade</li> <li> Pr\u00e1tica 07 - Stack vs Heap</li> <li> Pr\u00e1tica 08 - Mem\u00f3ria Virtual</li> </ul>"},{"location":"exercicios/#modulo-3-concorrencia-e-paralelismo","title":"M\u00f3dulo 3 \u2013 Concorr\u00eancia e Paralelismo","text":"<ul> <li> Pr\u00e1tica 09 - Processos e Threads</li> <li> Pr\u00e1tica 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia</li> <li> Pr\u00e1tica 11 - Paralelismo no Hardware</li> <li> Pr\u00e1tica 12 - O Modelo de Mem\u00f3ria</li> </ul>"},{"location":"exercicios/#modulo-4-armazenamento-io-e-pratica","title":"M\u00f3dulo 4 \u2013 Armazenamento, I/O e Pr\u00e1tica","text":"<ul> <li> Pr\u00e1tica 13 - Dispositivos de Armazenamento</li> <li> Pr\u00e1tica 14 - Sistemas de Arquivos</li> <li> Pr\u00e1tica 15 - Entrada e Sa\u00edda (I/O)</li> <li> Pr\u00e1tica 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware</li> </ul>"},{"location":"exercicios/exercicio-01/","title":"Exerc\u00edcios: Aula 01 - Como o Software Roda no Hardware","text":""},{"location":"exercicios/exercicio-01/#exercicios-aula-01-como-o-software-roda-no-hardware","title":"Exerc\u00edcios: Aula 01 - Como o Software Roda no Hardware","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 01.</p>"},{"location":"exercicios/exercicio-01/#questao-1-1-o-abismo-entre-codigo-e-silicio-basico-1","title":"Quest\u00e3o 1 - 1. O Abismo entre C\u00f3digo e Sil\u00edcio (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, Bin\u00e1rios (0 e 1).</p> <p>Pergunta: Descreva o conceito fundamental de 1. O Abismo entre C\u00f3digo e Sil\u00edcio e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-01/#questao-2-2-compiladores-vs-interpretadores-basico-2","title":"Quest\u00e3o 2 - 2. Compiladores vs Interpretadores (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance:</p> <p>Pergunta: Descreva o conceito fundamental de 2. Compiladores vs Interpretadores e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-01/#questao-3-3-isa-o-contrato-do-processador-intermediario-1","title":"Quest\u00e3o 3 - 3. ISA: O Contrato do Processador (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Todo c\u00f3digo, por mais sofisticado que seja, precisa ser reduzido a estas poucas opera\u00e7\u00f5es ditadas pela ISA para rodar.</p> <p>Pergunta: Analisando o funcionamento de 3. ISA: O Contrato do Processador, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-01/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <ul> <li>Ao usar C/C++, voc\u00ea n\u00e3o lida com um motor intermedi\u00e1rio te cobrindo (como a JVM), voc\u00ea escreve algoritmos cuja gest\u00e3o \u00e9 delegada ao S.O. e rodada pura em metal.</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-01/#questao-5-1-o-abismo-entre-codigo-e-silicio-desafio","title":"Quest\u00e3o 5 - 1. O Abismo entre C\u00f3digo e Sil\u00edcio (Desafio)","text":"<p>Contexto: </p> <p>Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, Bin\u00e1rios (0 e 1).</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. O Abismo entre C\u00f3digo e Sil\u00edcio cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-02/","title":"Exerc\u00edcios: Aula 02 - Representa\u00e7\u00e3o de Dados","text":""},{"location":"exercicios/exercicio-02/#exercicios-aula-02-representacao-de-dados","title":"Exerc\u00edcios: Aula 02 - Representa\u00e7\u00e3o de Dados","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 02.</p>"},{"location":"exercicios/exercicio-02/#questao-1-1-sistema-binario-e-hexadecimal-basico-1","title":"Quest\u00e3o 1 - 1. Sistema Bin\u00e1rio e Hexadecimal (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal).</p> <p>Pergunta: Descreva o conceito fundamental de 1. Sistema Bin\u00e1rio e Hexadecimal e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-02/#questao-2-2-inteiros-com-e-sem-sinal-unsigned-basico-2","title":"Quest\u00e3o 2 - 2. Inteiros com e sem Sinal (Unsigned) (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware:</p> <p>Pergunta: Descreva o conceito fundamental de 2. Inteiros com e sem Sinal (Unsigned) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-02/#questao-3-3-ponto-flutuante-ieee-754-intermediario-1","title":"Quest\u00e3o 3 - 3. Ponto Flutuante (IEEE 754) (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Os famosos tipos <code>float</code> e <code>double</code>. O processador possui normalmente um setor dedicado de FPU (Floating Point Unit) para eles.</p> <p>Pergunta: Analisando o funcionamento de 3. Ponto Flutuante (IEEE 754), como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-02/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <p>A maneira como voc\u00ea escolhe o tipo primitivo da vari\u00e1vel modela a fisionomia do registrador acionado na m\u00e1quina durante o fetch. Entender o Overflow \u00e9 a prote\u00e7\u00e3o b\u00e1sica contra corrup\u00e7\u00e3o l\u00f3gica do c\u00f3digo.</p> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-02/#questao-5-1-sistema-binario-e-hexadecimal-desafio","title":"Quest\u00e3o 5 - 1. Sistema Bin\u00e1rio e Hexadecimal (Desafio)","text":"<p>Contexto: </p> <p>O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal).</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. Sistema Bin\u00e1rio e Hexadecimal cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-03/","title":"Exerc\u00edcios: Aula 03 - CPU: Estrutura e Funcionamento","text":""},{"location":"exercicios/exercicio-03/#exercicios-aula-03-cpu-estrutura-e-funcionamento","title":"Exerc\u00edcios: Aula 03 - CPU: Estrutura e Funcionamento","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 03.</p>"},{"location":"exercicios/exercicio-03/#questao-1-1-o-triangulo-de-ouro-alu-cu-e-registradores-basico-1","title":"Quest\u00e3o 1 - 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais:</p> <p>Pergunta: Descreva o conceito fundamental de 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-03/#questao-2-2-o-ciclo-de-instrucao-fetch-decode-execute-basico-2","title":"Quest\u00e3o 2 - 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute) (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do Clock pelo ciclo cl\u00e1ssico:</p> <p>Pergunta: Descreva o conceito fundamental de 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-03/#questao-3-3-pipeline-e-previsao-de-desvio-branch-prediction-intermediario-1","title":"Quest\u00e3o 3 - 3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction) (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Seu processador n\u00e3o faz essas 4 etapas de forma burra (uma por vez). Ele usa Pipelining: Enquanto a Instru\u00e7\u00e3o A est\u00e1 em Execute, a Instru\u00e7\u00e3o B j\u00e1 est\u00e1 em Decode e a Instru\u00e7\u00e3o C est\u00e1 em Fetch!</p> <p>Pergunta: Analisando o funcionamento de 3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction), como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-03/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <p>Registradores s\u00e3o seus maiores amigos de performance. C\u00f3digos C++ que permitem ao compilador prender c\u00e1lculos pesados 100% dentro dos Registradores rodam em Nanossegundos, contra Milissegundos lendo sempre pela RAM.</p> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-03/#questao-5-1-o-triangulo-de-ouro-alu-cu-e-registradores-desafio","title":"Quest\u00e3o 5 - 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores (Desafio)","text":"<p>Contexto: </p> <p>A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais:</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-04/","title":"Exerc\u00edcios: Aula 04 - Arquiteturas RISC vs CISC","text":""},{"location":"exercicios/exercicio-04/#exercicios-aula-04-arquiteturas-risc-vs-cisc","title":"Exerc\u00edcios: Aula 04 - Arquiteturas RISC vs CISC","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 04.</p>"},{"location":"exercicios/exercicio-04/#questao-1-1-entendendo-a-batalha-basico-1","title":"Quest\u00e3o 1 - 1. Entendendo a Batalha (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas?</p> <p>Pergunta: Descreva o conceito fundamental de 1. Entendendo a Batalha e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-04/#questao-2-2-como-isso-afeta-o-compilador-cc-basico-2","title":"Quest\u00e3o 2 - 2. Como isso afeta o Compilador C/C++? (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas:</p> <p>Pergunta: Descreva o conceito fundamental de 2. Como isso afeta o Compilador C/C++? e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-04/#questao-3-resumo-pratico-intermediario-1","title":"Quest\u00e3o 3 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <ul> <li>Historicamente, servidores eram puramente CISC (Intel).</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-04/#questao-4-1-entendendo-a-batalha-intermediario-2","title":"Quest\u00e3o 4 - 1. Entendendo a Batalha (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <p>A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas?</p> <p>Pergunta: Analisando o funcionamento de 1. Entendendo a Batalha, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-04/#questao-5-2-como-isso-afeta-o-compilador-cc-desafio","title":"Quest\u00e3o 5 - 2. Como isso afeta o Compilador C/C++? (Desafio)","text":"<p>Contexto: </p> <p>Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas:</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 2. Como isso afeta o Compilador C/C++? cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-05/","title":"Exerc\u00edcios: Aula 05 - Hierarquia de Mem\u00f3ria","text":""},{"location":"exercicios/exercicio-05/#exercicios-aula-05-hierarquia-de-memoria","title":"Exerc\u00edcios: Aula 05 - Hierarquia de Mem\u00f3ria","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 05.</p>"},{"location":"exercicios/exercicio-05/#questao-1-1-a-piramide-de-alta-performance-basico-1","title":"Quest\u00e3o 1 - 1. A Pir\u00e2mide de Alta Performance (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda:</p> <p>Pergunta: Descreva o conceito fundamental de 1. A Pir\u00e2mide de Alta Performance e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-05/#questao-2-2-os-impactos-da-latencia-lado-do-codigo-basico-2","title":"Quest\u00e3o 2 - 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo) (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty.</p> <p>Pergunta: Descreva o conceito fundamental de 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-05/#questao-3-3-optimizando-uso-intermediario-1","title":"Quest\u00e3o 3 - 3. Optimizando Uso (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Por que linguagens como C e C++ dominam infraestrutura de servidores High Frequency Trading?</p> <p>Pergunta: Analisando o funcionamento de 3. Optimizando Uso, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-05/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <ul> <li>Se processadores hoje s\u00e3o m\u00edsseis atingindo +4GHz, a RAM parou no tempo (Lat\u00eancia de CAS n\u00e3o baixa proporcionalmente).</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-05/#questao-5-1-a-piramide-de-alta-performance-desafio","title":"Quest\u00e3o 5 - 1. A Pir\u00e2mide de Alta Performance (Desafio)","text":"<p>Contexto: </p> <p>Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda:</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. A Pir\u00e2mide de Alta Performance cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-06/","title":"Exerc\u00edcios: Aula 06 - Cache e Localidade","text":""},{"location":"exercicios/exercicio-06/#exercicios-aula-06-cache-e-localidade","title":"Exerc\u00edcios: Aula 06 - Cache e Localidade","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 06.</p>"},{"location":"exercicios/exercicio-06/#questao-1-1-cache-hit-e-cache-miss-basico-1","title":"Quest\u00e3o 1 - 1. Cache Hit e Cache Miss (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate.</p> <p>Pergunta: Descreva o conceito fundamental de 1. Cache Hit e Cache Miss e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-06/#questao-2-2-localidade-espacial-vs-temporal-basico-2","title":"Quest\u00e3o 2 - 2. Localidade Espacial vs Temporal (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada):</p> <p>Pergunta: Descreva o conceito fundamental de 2. Localidade Espacial vs Temporal e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-06/#questao-3-3-false-sharing-e-logica-invertida-a-morte-do-c-intermediario-1","title":"Quest\u00e3o 3 - 3. False Sharing e L\u00f3gica Invertida (A Morte do C++) (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo.</p> <p>Pergunta: Analisando o funcionamento de 3. False Sharing e L\u00f3gica Invertida (A Morte do C++), como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-06/#questao-4-1-cache-hit-e-cache-miss-intermediario-2","title":"Quest\u00e3o 4 - 1. Cache Hit e Cache Miss (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <p>O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate.</p> <p>Pergunta: Analisando o funcionamento de 1. Cache Hit e Cache Miss, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-06/#questao-5-2-localidade-espacial-vs-temporal-desafio","title":"Quest\u00e3o 5 - 2. Localidade Espacial vs Temporal (Desafio)","text":"<p>Contexto: </p> <p>As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada):</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 2. Localidade Espacial vs Temporal cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-07/","title":"Exerc\u00edcios: Aula 07 - Stack vs Heap","text":""},{"location":"exercicios/exercicio-07/#exercicios-aula-07-stack-vs-heap","title":"Exerc\u00edcios: Aula 07 - Stack vs Heap","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 07.</p>"},{"location":"exercicios/exercicio-07/#questao-1-1-a-pilha-stack-basico-1","title":"Quest\u00e3o 1 - 1. A Pilha (Stack) (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out).</p> <p>Pergunta: Descreva o conceito fundamental de 1. A Pilha (Stack) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-07/#questao-2-2-o-monte-heap-basico-2","title":"Quest\u00e3o 2 - 2. O Monte (Heap) (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o Din\u00e2mica).</p> <p>Pergunta: Descreva o conceito fundamental de 2. O Monte (Heap) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-07/#questao-3-3-memory-leaks-vazamentos-de-memoria-intermediario-1","title":"Quest\u00e3o 3 - 3. Memory Leaks (Vazamentos de Mem\u00f3ria) (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Um cl\u00e1ssico e letal bug de engenharia C++. Quando o desenvolvedor executa <code>new</code> ou <code>malloc</code> solicitando mem\u00f3ria do Heap, mas quebra regras do fluxo perdendo o contato formal do ponteiro retornado do hardware sem antes ter reportado o fim via <code>delete</code> ou <code>free</code>.</p> <p>Pergunta: Analisando o funcionamento de 3. Memory Leaks (Vazamentos de Mem\u00f3ria), como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-07/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <ul> <li>Se n\u00e3o sabe onde colocar: Bote no STACK.</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-07/#questao-5-1-a-pilha-stack-desafio","title":"Quest\u00e3o 5 - 1. A Pilha (Stack) (Desafio)","text":"<p>Contexto: </p> <p>A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out).</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. A Pilha (Stack) cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-08/","title":"Exerc\u00edcios: Aula 08 - Mem\u00f3ria Virtual","text":""},{"location":"exercicios/exercicio-08/#exercicios-aula-08-memoria-virtual","title":"Exerc\u00edcios: Aula 08 - Mem\u00f3ria Virtual","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 08.</p>"},{"location":"exercicios/exercicio-08/#questao-1-1-o-abismo-logico-a-memoria-virtual-basico-1","title":"Quest\u00e3o 1 - 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center.</p> <p>Pergunta: Descreva o conceito fundamental de 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-08/#questao-2-2-tlb-mmu-e-a-traducao-da-pagina-basico-2","title":"Quest\u00e3o 2 - 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>Para driblar isso, a arquitetura moderna usa a TLB (Translation Lookaside Buffer). A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso vira bloco 344 do pente de DDR5 real\".</p> <p>Pergunta: Descreva o conceito fundamental de 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-08/#questao-3-3-driblando-a-paginacao-como-programador-intermediario-1","title":"Quest\u00e3o 3 - 3. Driblando a Pagina\u00e7\u00e3o como Programador (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Ao iterarmos matrizes massivas (Matrizes 2D em C++) na ordem invertida ou em l\u00f3gicas dispersas <code>LinkedList-&gt;prox</code>, voc\u00ea n\u00e3o causa apenas Cache Miss da Aula 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes TLB Misses! Voc\u00ea induzir\u00e1 Page Faults insanos que derrubar\u00e3o o throughput (taxa de transfer\u00eancia de dados) em N fatores.</p> <p>Pergunta: Analisando o funcionamento de 3. Driblando a Pagina\u00e7\u00e3o como Programador, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-08/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <ul> <li>O ponteiro que o dev manipula com um <code>int *ptr = &amp;value</code> em qualquer IDE \u00e9 puramente 100% Virtual. \u00c9 o passaporte intermedi\u00e1rio.</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-08/#questao-5-1-o-abismo-logico-a-memoria-virtual-desafio","title":"Quest\u00e3o 5 - 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual (Desafio)","text":"<p>Contexto: </p> <p>Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center.</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-09/","title":"Exerc\u00edcios: Aula 09 - Processos e Threads","text":""},{"location":"exercicios/exercicio-09/#exercicios-aula-09-processos-e-threads","title":"Exerc\u00edcios: Aula 09 - Processos e Threads","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 09.</p>"},{"location":"exercicios/exercicio-09/#questao-1-1-processos-isolamento-forte-basico-1","title":"Quest\u00e3o 1 - 1. Processos (Isolamento Forte) (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>).</p> <p>Pergunta: Descreva o conceito fundamental de 1. Processos (Isolamento Forte) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-09/#questao-2-2-threads-isolamento-fraco-partilha-basico-2","title":"Quest\u00e3o 2 - 2. Threads (Isolamento Fraco / Partilha) (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para Multithreading!</p> <p>Pergunta: Descreva o conceito fundamental de 2. Threads (Isolamento Fraco / Partilha) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-09/#questao-3-3-context-switch-a-faca-de-dois-gumes-intermediario-1","title":"Quest\u00e3o 3 - 3. Context Switch (A Faca de Dois Gumes) (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Quando escrevemos <code>\"Hello World\"</code>, achamos que a CPU roda por horas sem interrup\u00e7\u00f5es. Engano.</p> <p>Pergunta: Analisando o funcionamento de 3. Context Switch (A Faca de Dois Gumes), como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-09/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <ul> <li>Se a tarefa for CPU-Bound (requerer Matem\u00e1tica Bruta Massiva / Machine Learning), voc\u00ea cria Threads numerando-as pr\u00f3ximo n\u00famero oficial de n\u00facleos estritos da CPU, evitando desperd\u00edcio de overhead com Context Switches ilus\u00f3rios.</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-09/#questao-5-1-processos-isolamento-forte-desafio","title":"Quest\u00e3o 5 - 1. Processos (Isolamento Forte) (Desafio)","text":"<p>Contexto: </p> <p>O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>).</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. Processos (Isolamento Forte) cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-10/","title":"Exerc\u00edcios: Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":""},{"location":"exercicios/exercicio-10/#exercicios-aula-10-sincronizacao-e-concorrencia","title":"Exerc\u00edcios: Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 10.</p>"},{"location":"exercicios/exercicio-10/#questao-1-1-o-data-race-uma-colisao-inevitavel-basico-1","title":"Quest\u00e3o 1 - 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\".</p> <p>Pergunta: Descreva o conceito fundamental de 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-10/#questao-2-2-mutex-e-the-critical-section-basico-2","title":"Quest\u00e3o 2 - 2. Mutex e The Critical Section (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As Locks (Travas) como padr\u00e3o Ouro C++: <code>std::mutex</code> (Mutual Exclusion).</p> <p>Pergunta: Descreva o conceito fundamental de 2. Mutex e The Critical Section e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-10/#questao-3-3-o-dilema-deadlock-intermediario-1","title":"Quest\u00e3o 3 - 3. O Dilema: Deadlock (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Mas e se o programador de Backend C/C++ prender (usou lock() ou Mutex) em A esperando que B seja terminado.. mas B s\u00f3 termina porque B precisa pegar lock() em A que t\u00e1 bloqueado?</p> <p>Pergunta: Analisando o funcionamento de 3. O Dilema: Deadlock, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-10/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <ul> <li>Mutex: Usa o sistema do n\u00facleo para trancar \u00e1reas exclusivas do Hardware (RAM).</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-10/#questao-5-1-o-data-race-uma-colisao-inevitavel-desafio","title":"Quest\u00e3o 5 - 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel (Desafio)","text":"<p>Contexto: </p> <p>Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\".</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-11/","title":"Exerc\u00edcios: Aula 11 - Paralelismo no Hardware","text":""},{"location":"exercicios/exercicio-11/#exercicios-aula-11-paralelismo-no-hardware","title":"Exerc\u00edcios: Aula 11 - Paralelismo no Hardware","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 11.</p>"},{"location":"exercicios/exercicio-11/#questao-1-1-multi-core-multiplos-nucleos-basico-1","title":"Quest\u00e3o 1 - 1. Multi-Core (M\u00faltiplos N\u00facleos) (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip).</p> <p>Pergunta: Descreva o conceito fundamental de 1. Multi-Core (M\u00faltiplos N\u00facleos) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-11/#questao-2-2-hyper-threading-smt-symmetrical-multi-threading-basico-2","title":"Quest\u00e3o 2 - 2. Hyper-Threading (SMT - Symmetrical Multi-Threading) (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux?</p> <p>Pergunta: Descreva o conceito fundamental de 2. Hyper-Threading (SMT - Symmetrical Multi-Threading) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-11/#questao-3-3-gpus-o-paralelismo-macico-intermediario-1","title":"Quest\u00e3o 3 - 3. GPUs: O Paralelismo Maci\u00e7o (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>CPUs (Processadores) foram feitos para \"Serem R\u00e1pidos executando sequ\u00eancias l\u00f3gicas e IFs complexos\". Possuem Caches gigantes.</p> <p>Pergunta: Analisando o funcionamento de 3. GPUs: O Paralelismo Maci\u00e7o, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-11/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <ul> <li>Task Paralelism: Se tens l\u00f3gica variada, use a CPU Multi-Core C++ thread pool.</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-11/#questao-5-1-multi-core-multiplos-nucleos-desafio","title":"Quest\u00e3o 5 - 1. Multi-Core (M\u00faltiplos N\u00facleos) (Desafio)","text":"<p>Contexto: </p> <p>Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip).</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. Multi-Core (M\u00faltiplos N\u00facleos) cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-12/","title":"Exerc\u00edcios: Aula 12 - O Modelo de Mem\u00f3ria","text":""},{"location":"exercicios/exercicio-12/#exercicios-aula-12-o-modelo-de-memoria","title":"Exerc\u00edcios: Aula 12 - O Modelo de Mem\u00f3ria","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 12.</p>"},{"location":"exercicios/exercicio-12/#questao-1-1-a-reordenacao-do-compilador-e-cpu-out-of-order-execution-basico-1","title":"Quest\u00e3o 1 - 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>Voc\u00ea codifica:</p> <p>Pergunta: Descreva o conceito fundamental de 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-12/#questao-2-2-o-memory-model-consistencias-e-barreiras-basico-2","title":"Quest\u00e3o 2 - 2. O Memory Model (Consist\u00eancias e Barreiras) (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>O C++11 emitiu formalmente o seu universal Memory Model definindo atrav\u00e9s da biblioteca <code>std::atomic</code> o que o Hardware tem permi\u00e7\u00f5es para Adiantar vs Trancar.</p> <p>Pergunta: Descreva o conceito fundamental de 2. O Memory Model (Consist\u00eancias e Barreiras) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-12/#questao-3-3-memory-barriers-fences-nas-cpus-intermediario-1","title":"Quest\u00e3o 3 - 3. Memory Barriers (Fences) nas CPUs (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Se n\u00e3o tivessemos essa lei <code>std::atomic</code> no standard oficial do GCC, program\u00e1vamos via \"Gambiarra Intrinseca\" de Processador (Ex: Comando Assembler MFENCE ou SFENCE no Intel). Os Fences pro\u00edbem categoricamente a travessia de saltos das sub-opera\u00e7\u00f5es em Assembly, estancando a execu\u00e7\u00e3o como um sinaleiro fechado.</p> <p>Pergunta: Analisando o funcionamento de 3. Memory Barriers (Fences) nas CPUs, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-12/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <ul> <li>Se duas \"Threads\" conversam atrav\u00e9s das mesmas vari\u00e1veis limpas de C e n\u00e3o possuam <code>std::mutex</code> da aula 10 as blindando, USE <code>std::atomic&lt;bool&gt;</code>. Do contr\u00e1rio voc\u00ea \u00e9 uma v\u00edtima da Superscalar Out Of Order Intel Architecture Pipeline (a reordena\u00e7\u00e3o el\u00e9trica).</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-12/#questao-5-1-a-reordenacao-do-compilador-e-cpu-out-of-order-execution-desafio","title":"Quest\u00e3o 5 - 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) (Desafio)","text":"<p>Contexto: </p> <p>Voc\u00ea codifica:</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-13/","title":"Exerc\u00edcios: Aula 13 - Dispositivos de Armazenamento","text":""},{"location":"exercicios/exercicio-13/#exercicios-aula-13-dispositivos-de-armazenamento","title":"Exerc\u00edcios: Aula 13 - Dispositivos de Armazenamento","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 13.</p>"},{"location":"exercicios/exercicio-13/#questao-1-1-hdd-hard-disk-drive-vs-ssd-sata-basico-1","title":"Quest\u00e3o 1 - 1. HDD (Hard Disk Drive) vs SSD (SATA) (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>Pergunta: Descreva o conceito fundamental de 1. HDD (Hard Disk Drive) vs SSD (SATA) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-13/#questao-2-2-nvme-o-limite-pcie-basico-2","title":"Quest\u00e3o 2 - 2. NVMe (O Limite PCIe) (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em que passam Gigabytes por segundo (ex: Gen4 cruza 7.000 MB/s).</p> <p>Pergunta: Descreva o conceito fundamental de 2. NVMe (O Limite PCIe) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-13/#questao-3-3-iops-a-metrica-real-do-servidor-intermediario-1","title":"Quest\u00e3o 3 - 3. IOPS - A M\u00e9trica Real do Servidor (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Se a banda (MB/s) diz o volume da mangueira, os IOPS (Input/Output Operations Per Second) dizem quantos golpes a mangueira d\u00e1 por segundo.</p> <p>Pergunta: Analisando o funcionamento de 3. IOPS - A M\u00e9trica Real do Servidor, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-13/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <p>O desenvolvedor C++ entende isso programando a I/O por grandes lotes (<code>Buffers</code>). N\u00e3o escreva no disco <code>1 byte</code> no la\u00e7o for por <code>1 milh\u00e3o de vezes</code> (Destrui\u00e7\u00e3o de IOPS).</p> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-13/#questao-5-1-hdd-hard-disk-drive-vs-ssd-sata-desafio","title":"Quest\u00e3o 5 - 1. HDD (Hard Disk Drive) vs SSD (SATA) (Desafio)","text":"<p>Contexto: </p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. HDD (Hard Disk Drive) vs SSD (SATA) cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-14/","title":"Exerc\u00edcios: Aula 14 - Sistemas de Arquivos","text":""},{"location":"exercicios/exercicio-14/#exercicios-aula-14-sistemas-de-arquivos","title":"Exerc\u00edcios: Aula 14 - Sistemas de Arquivos","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 14.</p>"},{"location":"exercicios/exercicio-14/#questao-1-1-o-v-node-inode-basico-1","title":"Quest\u00e3o 1 - 1. O V-Node / Inode (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster.</p> <p>Pergunta: Descreva o conceito fundamental de 1. O V-Node / Inode e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-14/#questao-2-2-journaling-a-prova-contra-quedas-basico-2","title":"Quest\u00e3o 2 - 2. Journaling (A Prova contra Quedas) (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode.</p> <p>Pergunta: Descreva o conceito fundamental de 2. Journaling (A Prova contra Quedas) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-14/#questao-3-3-buffers-e-page-cache-por-que-linux-e-rapido-intermediario-1","title":"Quest\u00e3o 3 - 3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido) (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>\"Escrever no disco\" via SysCall C++ <code>write()</code> ou <code>fwrite()</code> raramente vai pro HD!</p> <p>Pergunta: Analisando o funcionamento de 3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido), como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-14/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <ul> <li>Ao usar C/C++, chame o instr\u00ednseco <code>fsync()</code> se seu App for um Banco de Dados ou Software Cr\u00edtico Banc\u00e1rio for\u00e7ando a Cache RAM descarregar a for\u00e7a e salvar permanentemente no sil\u00edcio do disco.</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-14/#questao-5-1-o-v-node-inode-desafio","title":"Quest\u00e3o 5 - 1. O V-Node / Inode (Desafio)","text":"<p>Contexto: </p> <p>Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster.</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. O V-Node / Inode cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-15/","title":"Exerc\u00edcios: Aula 15 - Entrada e Sa\u00edda (I/O)","text":""},{"location":"exercicios/exercicio-15/#exercicios-aula-15-entrada-e-saida-io","title":"Exerc\u00edcios: Aula 15 - Entrada e Sa\u00edda (I/O)","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 15.</p>"},{"location":"exercicios/exercicio-15/#questao-1-1-system-calls-o-pedagio-do-kernel-basico-1","title":"Quest\u00e3o 1 - 1. System Calls (O Ped\u00e1gio do Kernel) (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminante encerramento compuls\u00f3rio pelo Processador atrav\u00e9s do bloqueio de An\u00e9is de Prote\u00e7\u00e3o.</p> <p>Pergunta: Descreva o conceito fundamental de 1. System Calls (O Ped\u00e1gio do Kernel) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-15/#questao-2-2-interrupcoes-vs-polling-basico-2","title":"Quest\u00e3o 2 - 2. Interrup\u00e7\u00f5es vs Polling (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\".</p> <p>Pergunta: Descreva o conceito fundamental de 2. Interrup\u00e7\u00f5es vs Polling e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-15/#questao-3-3-dma-memoria-com-acesso-direto-intermediario-1","title":"Quest\u00e3o 3 - 3. DMA (Mem\u00f3ria com Acesso Direto) (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Mesmo com as Interrup\u00e7\u00f5es ajudando a n\u00e3o ficar paralisado Polling... Fazer a Placa de Rede encher a placa RAM transitando Bit a Bit passando pelo miolo doloroso da CPU era impratic\u00e1vel em Gigabit Ethernets.</p> <p>Pergunta: Analisando o funcionamento de 3. DMA (Mem\u00f3ria com Acesso Direto), como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-15/#questao-4-resumo-pratico-intermediario-2","title":"Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <ul> <li>Se a sua aplica\u00e7\u00e3o Web Framework ass\u00edncrona (como NodeJS ou Nginx C++) trava muito com \"I/O\", isso significa que o Sistema delega opera\u00e7\u00f5es custosas pelo DMA ao Kernel, enquanto orquestra Event-Loops aguardando os famigerados Interrupts de retorno.</li> </ul> <p>Pergunta: Analisando o funcionamento de Resumo Pr\u00e1tico, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-15/#questao-5-1-system-calls-o-pedagio-do-kernel-desafio","title":"Quest\u00e3o 5 - 1. System Calls (O Ped\u00e1gio do Kernel) (Desafio)","text":"<p>Contexto: </p> <p>Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminante encerramento compuls\u00f3rio pelo Processador atrav\u00e9s do bloqueio de An\u00e9is de Prote\u00e7\u00e3o.</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 1. System Calls (O Ped\u00e1gio do Kernel) cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/exercicio-16/","title":"Exerc\u00edcios: Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":""},{"location":"exercicios/exercicio-16/#exercicios-aula-16-projeto-final-otimizacao-baseada-em-hardware","title":"Exerc\u00edcios: Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":"<p>Resolver esses exerc\u00edcios ajudar\u00e1 na fixa\u00e7\u00e3o do conte\u00fado abordado na Aula 16.</p>"},{"location":"exercicios/exercicio-16/#questao-1-1-profiling-classico-a-vida-real-basico-1","title":"Quest\u00e3o 1 - 1. Profiling Cl\u00e1ssico (A Vida Real) (B\u00e1sico 1)","text":"<p>Contexto: </p> <p>Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior.</p> <p>Pergunta: Descreva o conceito fundamental de 1. Profiling Cl\u00e1ssico (A Vida Real) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-16/#questao-2-2-o-grande-desafio-mini-projeto-pratico-basico-2","title":"Quest\u00e3o 2 - 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) (B\u00e1sico 2)","text":"<p>Contexto: </p> <p>O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware:</p> <p>Pergunta: Descreva o conceito fundamental de 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) e liste duas vantagens de seu uso.</p>"},{"location":"exercicios/exercicio-16/#questao-3-3-conclusao-da-trilha-intermediario-1","title":"Quest\u00e3o 3 - 3. Conclus\u00e3o da Trilha (Intermedi\u00e1rio 1)","text":"<p>Contexto: </p> <p>Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada.</p> <p>Pergunta: Analisando o funcionamento de 3. Conclus\u00e3o da Trilha, como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-16/#questao-4-1-profiling-classico-a-vida-real-intermediario-2","title":"Quest\u00e3o 4 - 1. Profiling Cl\u00e1ssico (A Vida Real) (Intermedi\u00e1rio 2)","text":"<p>Contexto: </p> <p>Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior.</p> <p>Pergunta: Analisando o funcionamento de 1. Profiling Cl\u00e1ssico (A Vida Real), como essa m\u00e9trica interage em um ambiente pr\u00e1tico de compila\u00e7\u00e3o ou execu\u00e7\u00e3o de c\u00f3digo C/C++ a n\u00edvel de sistema operacional?</p>"},{"location":"exercicios/exercicio-16/#questao-5-2-o-grande-desafio-mini-projeto-pratico-desafio","title":"Quest\u00e3o 5 - 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) (Desafio)","text":"<p>Contexto: </p> <p>O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware:</p> <p>Pergunta (Desafio): Elabore um cen\u00e1rio de arquitetura onde o uso incorreto ou a falta de entendimento de 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) cause um problema grave de performance ou vazamento de mem\u00f3ria. Como voc\u00ea mitigaria estruturalmente esse gargalo?</p> <p> Ver Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada</p>"},{"location":"exercicios/solucao-01/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 01 - Como o Software Roda no Hardware","text":""},{"location":"exercicios/solucao-01/#solucao-e-explicacao-detalhada-aula-01-como-o-software-roda-no-hardware","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 01 - Como o Software Roda no Hardware","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 01.</p>"},{"location":"exercicios/solucao-01/#solucao-da-questao-1-1-o-abismo-entre-codigo-e-silicio-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. O Abismo entre C\u00f3digo e Sil\u00edcio (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, Bin\u00e1rios (0 e 1).</p> <p>Como a sua frase <code>printf(\"Hello World\");</code> chega aos pinos do processador? Atrav\u00e9s de uma cadeia de ferramentas (Toolchain).</p>"},{"location":"exercicios/solucao-01/#o-processo-de-compilacao-cc","title":"O Processo de Compila\u00e7\u00e3o (C/C++)","text":"<p>Linguagens compiladas de baixo n\u00edvel seguem um caminho determin\u00edstico. Veja o diagrama abaixo de como um arquivo <code>.c</code> \u00e9 fatiado:</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. O Abismo entre C\u00f3digo e Sil\u00edcio determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-01/#solucao-da-questao-2-2-compiladores-vs-interpretadores-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. Compiladores vs Interpretadores (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance:</p> <p>O c\u00f3digo \u00e9 100% transformado em bin\u00e1rio antes de executar (AOT - Ahead of Time).</p> <p>Um programa (Interpretador) l\u00ea o seu c\u00f3digo fonte em tempo de execu\u00e7\u00e3o e executa as a\u00e7\u00f5es simulando o comando subjacente para o S.O.</p> <p>Compilam para um formato intermedi\u00e1rio (Bytecode), e a JVM ou CLR as compila JIT (Just-In-Time) na m\u00e1quina cliente no instante de executar.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Compiladores vs Interpretadores determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-01/#solucao-da-questao-3-3-isa-o-contrato-do-processador-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. ISA: O Contrato do Processador (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Todo c\u00f3digo, por mais sofisticado que seja, precisa ser reduzido a estas poucas opera\u00e7\u00f5es ditadas pela ISA para rodar.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. ISA: O Contrato do Processador determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-01/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li> <p>Ao usar C/C++, voc\u00ea n\u00e3o lida com um motor intermedi\u00e1rio te cobrindo (como a JVM), voc\u00ea escreve algoritmos cuja gest\u00e3o \u00e9 delegada ao S.O. e rodada pura em metal.</p> </li> <li> <p>O programador backend / performance critica deve inspecionar eventuais outputs em Assembly para verificar se a abordagem da linguagem otimiza tempo de registrador.</p> </li> </ul> <p>Pronto para entender profundamente os dados no M\u00f3dulo Bin\u00e1rio?</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-01/#solucao-da-questao-5-1-o-abismo-entre-codigo-e-silicio-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. O Abismo entre C\u00f3digo e Sil\u00edcio (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, Bin\u00e1rios (0 e 1).</p> <p>Como a sua frase <code>printf(\"Hello World\");</code> chega aos pinos do processador? Atrav\u00e9s de uma cadeia de ferramentas (Toolchain).</p>"},{"location":"exercicios/solucao-01/#o-processo-de-compilacao-cc_1","title":"O Processo de Compila\u00e7\u00e3o (C/C++)","text":"<p>Linguagens compiladas de baixo n\u00edvel seguem um caminho determin\u00edstico. Veja o diagrama abaixo de como um arquivo <code>.c</code> \u00e9 fatiado:</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. O Abismo entre C\u00f3digo e Sil\u00edcio determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-02/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 02 - Representa\u00e7\u00e3o de Dados","text":""},{"location":"exercicios/solucao-02/#solucao-e-explicacao-detalhada-aula-02-representacao-de-dados","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 02 - Representa\u00e7\u00e3o de Dados","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 02.</p>"},{"location":"exercicios/solucao-02/#solucao-da-questao-1-1-sistema-binario-e-hexadecimal-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. Sistema Bin\u00e1rio e Hexadecimal (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal).</p> <p>Por que <code>Hexadecimal</code> \u00e9 amado pelos desenvolvedores C/C++? Um Byte (8 bits) pode ser perfeitamente representado por exatos dois caracteres Hexadecimais. <code>FF</code> \u00e9 o mesmo que <code>11111111</code>.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Sistema Bin\u00e1rio e Hexadecimal determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-02/#solucao-da-questao-2-2-inteiros-com-e-sem-sinal-unsigned-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. Inteiros com e sem Sinal (Unsigned) (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware:</p> <p>No hardware, inteiros negativos s\u00e3o representados usando a regra de Complemento de 2. Para obtermos o bin\u00e1rio do <code>-1</code>, invertemos todos os bits de <code>1</code> e somamos <code>1</code>.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Inteiros com e sem Sinal (Unsigned) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-02/#solucao-da-questao-3-3-ponto-flutuante-ieee-754-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. Ponto Flutuante (IEEE 754) (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Os famosos tipos <code>float</code> e <code>double</code>. O processador possui normalmente um setor dedicado de FPU (Floating Point Unit) para eles.</p> <p>A representa\u00e7\u00e3o oficial IEEE 754 os divide em 3 por\u00e7\u00f5es:</p>"},{"location":"exercicios/solucao-02/#o-perigo-da-precisao","title":"O Perigo da Precis\u00e3o!","text":"<p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. Ponto Flutuante (IEEE 754) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-02/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A maneira como voc\u00ea escolhe o tipo primitivo da vari\u00e1vel modela a fisionomia do registrador acionado na m\u00e1quina durante o fetch. Entender o Overflow \u00e9 a prote\u00e7\u00e3o b\u00e1sica contra corrup\u00e7\u00e3o l\u00f3gica do c\u00f3digo.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-02/#solucao-da-questao-5-1-sistema-binario-e-hexadecimal-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. Sistema Bin\u00e1rio e Hexadecimal (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal).</p> <p>Por que <code>Hexadecimal</code> \u00e9 amado pelos desenvolvedores C/C++? Um Byte (8 bits) pode ser perfeitamente representado por exatos dois caracteres Hexadecimais. <code>FF</code> \u00e9 o mesmo que <code>11111111</code>.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Sistema Bin\u00e1rio e Hexadecimal determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-03/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 03 - CPU: Estrutura e Funcionamento","text":""},{"location":"exercicios/solucao-03/#solucao-e-explicacao-detalhada-aula-03-cpu-estrutura-e-funcionamento","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 03 - CPU: Estrutura e Funcionamento","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 03.</p>"},{"location":"exercicios/solucao-03/#solucao-da-questao-1-1-o-triangulo-de-ouro-alu-cu-e-registradores-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais:</p> <ol> <li> <p>ALU (Unidade L\u00f3gica e Aritm\u00e9tica): O m\u00fasculo. Onde as somas, subtra\u00e7\u00f5es e portas l\u00f3gicas (AND/OR/XOR) acontecem fisicamente usando transistores.</p> </li> <li> <p>CU (Unidade de Controle): O supervisor. Ela diz \u00e0 ALU o que fazer lendo os \"Opcodes\" (comandos bin\u00e1rios ISA).</p> </li> <li> <p>Registradores: Pequenos e ultra-r\u00e1pidos blocos de mem\u00f3ria embutidos diretamente no chip. (ex: EAX, EBX, RSP).</p> </li> </ol> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-03/#solucao-da-questao-2-2-o-ciclo-de-instrucao-fetch-decode-execute-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute) (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do Clock pelo ciclo cl\u00e1ssico:</p> <ol> <li> <p>Fetch (Busca): A CU vai na Mem\u00f3ria RAM e busca qual o pr\u00f3ximo byte de comando, guiando-se pelo Program Counter (PC).</p> </li> <li> <p>Decode (Decodifica): A CU traduz o comando para entender o que \u00e9 (\"Ah, \u00e9 para Somar 5!\").</p> </li> <li> <p>Execute: A ALU recebe os par\u00e2metros e faz a conta f\u00edsica el\u00e9tron a el\u00e9tron.</p> </li> <li> <p>Store (Armazena): O resultado volta para um registrador ou para a Mem\u00f3ria RAM.</p> </li> </ol> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-03/#solucao-da-questao-3-3-pipeline-e-previsao-de-desvio-branch-prediction-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction) (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Seu processador n\u00e3o faz essas 4 etapas de forma burra (uma por vez). Ele usa Pipelining: Enquanto a Instru\u00e7\u00e3o A est\u00e1 em Execute, a Instru\u00e7\u00e3o B j\u00e1 est\u00e1 em Decode e a Instru\u00e7\u00e3o C est\u00e1 em Fetch!</p>"},{"location":"exercicios/solucao-03/#o-perigo-do-if","title":"O perigo do \"IF\"","text":"<p>Quando voc\u00ea usa muitos <code>if()</code>, o processador tenta \"Adivinhar\" o lado do if usando heur\u00edsticas para n\u00e3o frear o Pipeline (Isso \u00e9 o Branch Prediction).</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-03/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Registradores s\u00e3o seus maiores amigos de performance. C\u00f3digos C++ que permitem ao compilador prender c\u00e1lculos pesados 100% dentro dos Registradores rodam em Nanossegundos, contra Milissegundos lendo sempre pela RAM.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-03/#solucao-da-questao-5-1-o-triangulo-de-ouro-alu-cu-e-registradores-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais:</p> <ol> <li> <p>ALU (Unidade L\u00f3gica e Aritm\u00e9tica): O m\u00fasculo. Onde as somas, subtra\u00e7\u00f5es e portas l\u00f3gicas (AND/OR/XOR) acontecem fisicamente usando transistores.</p> </li> <li> <p>CU (Unidade de Controle): O supervisor. Ela diz \u00e0 ALU o que fazer lendo os \"Opcodes\" (comandos bin\u00e1rios ISA).</p> </li> <li> <p>Registradores: Pequenos e ultra-r\u00e1pidos blocos de mem\u00f3ria embutidos diretamente no chip. (ex: EAX, EBX, RSP).</p> </li> </ol> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-04/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 04 - Arquiteturas RISC vs CISC","text":""},{"location":"exercicios/solucao-04/#solucao-e-explicacao-detalhada-aula-04-arquiteturas-risc-vs-cisc","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 04 - Arquiteturas RISC vs CISC","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 04.</p>"},{"location":"exercicios/solucao-04/#solucao-da-questao-1-1-entendendo-a-batalha-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. Entendendo a Batalha (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas?</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Entendendo a Batalha determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-04/#solucao-da-questao-2-2-como-isso-afeta-o-compilador-cc-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. Como isso afeta o Compilador C/C++? (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas:</p> <p>O c\u00f3digo C++ original <code>app.c</code> n\u00e3o muda! Quem rala \u00e9 o compilador, que na vers\u00e3o ARM gera dezenas de pequenas instru\u00e7\u00f5es curtas RISC, e na vers\u00e3o local gera um op-code gigante com microc\u00f3digos CISC internos da Intel.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Como isso afeta o Compilador C/C++? determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-04/#solucao-da-questao-3-resumo-pratico-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li> <p>Historicamente, servidores eram puramente CISC (Intel).</p> </li> <li> <p>Hoje, o mercado clama por RISC gra\u00e7as \u00e0 sustentabilidade t\u00e9rmica (menos energia e calor).</p> </li> <li> <p>Um bom engenheiro percebe que a ISA (aula anterior) CISC vai conter milhares de comandos Assembly, requerendo compiladores muito agressivos, enquanto a ISA RISC exigir\u00e1 compiladores muito detalhistas e otimizados linearmente na aloca\u00e7\u00e3o de registradores C/C++.</p> </li> </ul> <p>Caminho livre at\u00e9 aqui? Ent\u00e3o agora vamos adentrar nas dores da \"Mem\u00f3ria\".</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-04/#solucao-da-questao-4-1-entendendo-a-batalha-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - 1. Entendendo a Batalha (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas?</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Entendendo a Batalha determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-04/#solucao-da-questao-5-2-como-isso-afeta-o-compilador-cc-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 2. Como isso afeta o Compilador C/C++? (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas:</p> <p>O c\u00f3digo C++ original <code>app.c</code> n\u00e3o muda! Quem rala \u00e9 o compilador, que na vers\u00e3o ARM gera dezenas de pequenas instru\u00e7\u00f5es curtas RISC, e na vers\u00e3o local gera um op-code gigante com microc\u00f3digos CISC internos da Intel.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Como isso afeta o Compilador C/C++? determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-05/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 05 - Hierarquia de Mem\u00f3ria","text":""},{"location":"exercicios/solucao-05/#solucao-e-explicacao-detalhada-aula-05-hierarquia-de-memoria","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 05 - Hierarquia de Mem\u00f3ria","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 05.</p>"},{"location":"exercicios/solucao-05/#solucao-da-questao-1-1-a-piramide-de-alta-performance-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. A Pir\u00e2mide de Alta Performance (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda:</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. A Pir\u00e2mide de Alta Performance determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-05/#solucao-da-questao-2-2-os-impactos-da-latencia-lado-do-codigo-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo) (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty.</p> <p>A instru\u00e7\u00e3o e os dados descem da L3, saltam para L2, descem para L1 e se acoplam na ALU.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-05/#solucao-da-questao-3-3-optimizando-uso-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. Optimizando Uso (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Por que linguagens como C e C++ dominam infraestrutura de servidores High Frequency Trading?</p> <p>Porque elas permitem <code>Aloca\u00e7\u00e3o Est\u00e1tica e Constante</code> que \u00e9 perfeitamente \"encaixada\" pelo compilador diretamente na mem\u00f3ria Cache.</p> <p>Ao inv\u00e9s de carregar gigabytes de Strings na lenta RAM, as linguagens de baixo n\u00edvel incentivam o uso de matrizes de tamanho delimitado (arrays fixos), cujo agrupamento cont\u00edguo for\u00e7a a arquitetura de Hardware Prefetching a adiantar os bytes do Array para a Cache nativamente, antes mesmo de voc\u00ea rodar a linha do c\u00f3digo!</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. Optimizando Uso determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-05/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li> <p>Se processadores hoje s\u00e3o m\u00edsseis atingindo +4GHz, a RAM parou no tempo (Lat\u00eancia de CAS n\u00e3o baixa proporcionalmente).</p> </li> <li> <p>Tudo recai na t\u00e9cnica humana de amarrar dados juntos (Caches L1 e L2) e escrever data-oriented code se quiser ultra-lat\u00eancia C++.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-05/#solucao-da-questao-5-1-a-piramide-de-alta-performance-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. A Pir\u00e2mide de Alta Performance (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda:</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. A Pir\u00e2mide de Alta Performance determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-06/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 06 - Cache e Localidade","text":""},{"location":"exercicios/solucao-06/#solucao-e-explicacao-detalhada-aula-06-cache-e-localidade","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 06 - Cache e Localidade","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 06.</p>"},{"location":"exercicios/solucao-06/#solucao-da-questao-1-1-cache-hit-e-cache-miss-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. Cache Hit e Cache Miss (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate.</p> <ul> <li> <p>Cache Hit: Acerto! A CPU pediu a posi\u00e7\u00e3o <code>[1]</code>, ela j\u00e1 estava na Cache e a conta foi resolvida quase imediatamente.</p> </li> <li> <p>Cache Miss: Erro! O processador precisou parar o Pipeline, ir at\u00e9 a RAM lenta, injetar o bloco de bytes na lenta escalada D-Cache/L3/L2/L1 e prosseguir.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Cache Hit e Cache Miss determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-06/#solucao-da-questao-2-2-localidade-espacial-vs-temporal-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. Localidade Espacial vs Temporal (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada):</p> <p>Se o programa acessou a vari\u00e1vel na posi\u00e7\u00e3o de mem\u00f3ria <code>X</code>, h\u00e1 extrema probabilidade de que no ciclo de CPU seguinte ele acesse a vari\u00e1vel de mem\u00f3ria <code>X + 1</code>.</p> <p>Se o programa visitou a vari\u00e1vel <code>Y</code> agora, h\u00e1 enorme probabilidade dele visit\u00e1-la nos pr\u00f3ximos ms.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Localidade Espacial vs Temporal determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-06/#solucao-da-questao-3-3-false-sharing-e-logica-invertida-a-morte-do-c-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. False Sharing e L\u00f3gica Invertida (A Morte do C++) (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. False Sharing e L\u00f3gica Invertida (A Morte do C++) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-06/#solucao-da-questao-4-1-cache-hit-e-cache-miss-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - 1. Cache Hit e Cache Miss (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate.</p> <ul> <li> <p>Cache Hit: Acerto! A CPU pediu a posi\u00e7\u00e3o <code>[1]</code>, ela j\u00e1 estava na Cache e a conta foi resolvida quase imediatamente.</p> </li> <li> <p>Cache Miss: Erro! O processador precisou parar o Pipeline, ir at\u00e9 a RAM lenta, injetar o bloco de bytes na lenta escalada D-Cache/L3/L2/L1 e prosseguir.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Cache Hit e Cache Miss determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-06/#solucao-da-questao-5-2-localidade-espacial-vs-temporal-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 2. Localidade Espacial vs Temporal (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada):</p> <p>Se o programa acessou a vari\u00e1vel na posi\u00e7\u00e3o de mem\u00f3ria <code>X</code>, h\u00e1 extrema probabilidade de que no ciclo de CPU seguinte ele acesse a vari\u00e1vel de mem\u00f3ria <code>X + 1</code>.</p> <p>Se o programa visitou a vari\u00e1vel <code>Y</code> agora, h\u00e1 enorme probabilidade dele visit\u00e1-la nos pr\u00f3ximos ms.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Localidade Espacial vs Temporal determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-07/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 07 - Stack vs Heap","text":""},{"location":"exercicios/solucao-07/#solucao-e-explicacao-detalhada-aula-07-stack-vs-heap","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 07 - Stack vs Heap","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 07.</p>"},{"location":"exercicios/solucao-07/#solucao-da-questao-1-1-a-pilha-stack-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. A Pilha (Stack) (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out).</p> <ul> <li> <p>Performance Imediata: N\u00e3o sofre do atraso monumental do Sistema Operacional rodando scripts para achar buracos vazios. A CPU avan\u00e7a 1 pino de hardware no SP (Stack Pointer) e empilha na RAM. Retirou, ele decrementa. Super r\u00e1pido.</p> </li> <li> <p>Anti-Vazamento Autom\u00e1tico: Fun\u00e7\u00f5es extintas s\u00e3o imediatamente retiradas (popped) num clique at\u00f4mico LIFO e as fatias voltam a uso global. Mem\u00f3ria protegida contra vazamentos l\u00f3gicos (memory leaks) por defini\u00e7\u00e3o estrita.</p> </li> <li> <p>Quente da CPU: Frequentemente preza por Cache Hit. A Stack costuma viver majoritariamente no limiar da L1 Data Cache.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. A Pilha (Stack) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-07/#solucao-da-questao-2-2-o-monte-heap-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. O Monte (Heap) (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o Din\u00e2mica).</p> <p>Voc\u00ea \u00e9 o \u00fanico \u00e1rbitro. Diferente de Java, Python ou C# que usam complexos rob\u00f4s vasculhadores ocultos (Garbage Collectors) na sombra consumindo at\u00e9 20% do processador para auditar seu Heap e limpar os lixos. O Rust automatiza e barra aloca\u00e7\u00f5es indevidas usando Ownership sem o robozinho. O C++ fornece ferramentas novas e maduras (<code>std::unique_ptr</code> ou <code>std::shared_ptr</code>) baseadas na contagem de refer\u00eancia.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. O Monte (Heap) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-07/#solucao-da-questao-3-3-memory-leaks-vazamentos-de-memoria-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. Memory Leaks (Vazamentos de Mem\u00f3ria) (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Um cl\u00e1ssico e letal bug de engenharia C++. Quando o desenvolvedor executa <code>new</code> ou <code>malloc</code> solicitando mem\u00f3ria do Heap, mas quebra regras do fluxo perdendo o contato formal do ponteiro retornado do hardware sem antes ter reportado o fim via <code>delete</code> ou <code>free</code>.</p> <p>Resultado?  Aquela fatia na RAM f\u00edsica do servidor Linux ficar\u00e1 congelada, cega, retida unicamente pro seu app at\u00e9 que a nuvem AWS exaure toda a m\u00e1quina do container num erro de Kernel <code>OOM Killer (Out Of Memory)</code>.</p> <p>Em contra-partida: Dangling Pointers. Usar a \u00e1rea que o ponteiro apontava depois da liberta\u00e7\u00e3o formal do free provoca instabilidade instant\u00e2nea e corrup\u00e7\u00e3o silenciosa nos endere\u00e7os da placa-m\u00e3e.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. Memory Leaks (Vazamentos de Mem\u00f3ria) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-07/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li> <p>Se n\u00e3o sabe onde colocar: Bote no STACK.</p> </li> <li> <p>\u00c9 muito grande pra caber (Strings longas ou Arrays): Invoque HEAP com o <code>std::vector</code> (ele gerencia o malloc e free na destrui\u00e7\u00e3o de escopo).</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-07/#solucao-da-questao-5-1-a-pilha-stack-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. A Pilha (Stack) (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out).</p> <ul> <li> <p>Performance Imediata: N\u00e3o sofre do atraso monumental do Sistema Operacional rodando scripts para achar buracos vazios. A CPU avan\u00e7a 1 pino de hardware no SP (Stack Pointer) e empilha na RAM. Retirou, ele decrementa. Super r\u00e1pido.</p> </li> <li> <p>Anti-Vazamento Autom\u00e1tico: Fun\u00e7\u00f5es extintas s\u00e3o imediatamente retiradas (popped) num clique at\u00f4mico LIFO e as fatias voltam a uso global. Mem\u00f3ria protegida contra vazamentos l\u00f3gicos (memory leaks) por defini\u00e7\u00e3o estrita.</p> </li> <li> <p>Quente da CPU: Frequentemente preza por Cache Hit. A Stack costuma viver majoritariamente no limiar da L1 Data Cache.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. A Pilha (Stack) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-08/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 08 - Mem\u00f3ria Virtual","text":""},{"location":"exercicios/solucao-08/#solucao-e-explicacao-detalhada-aula-08-memoria-virtual","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 08 - Mem\u00f3ria Virtual","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 08.</p>"},{"location":"exercicios/solucao-08/#solucao-da-questao-1-1-o-abismo-logico-a-memoria-virtual-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center.</p> <p>Todo processo que o Linux constr\u00f3i roda dentro de uma gigante Ilus\u00e3o. O endere\u00e7o do seu ponteiro <code>0x7ffeeB...</code> em C++ \u00e9 falso (Endere\u00e7o L\u00f3gico).</p> <p>O HW (Hardware MMU no processador) mais as planilhas do Sistema Operacional (Page Tables) formencem a liga\u00e7\u00e3o din\u00e2mica e escondida pra sua aplica\u00e7\u00e3o.</p> <p>A Mem\u00f3ria Virtual (VM) \u00e9 um sandu\u00edche mental e isolador protetor usado pelo S.O.</p> <p>Ela entrega para o ponteiro do processo o pretexto visual de que ele tem toda a mem\u00f3ria que ele quiser num universo cont\u00ednuo livre.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-08/#solucao-da-questao-2-2-tlb-mmu-e-a-traducao-da-pagina-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Para driblar isso, a arquitetura moderna usa a TLB (Translation Lookaside Buffer). A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso vira bloco 344 do pente de DDR5 real\".</p> <ul> <li> <p>Page Hit: A tradu\u00e7\u00e3o ocorreu instat\u00e2neamente pela cache veloz na CPU (a TLB validou o ponteiro do C++ localizando logo onde est\u00e1 no metal a vari\u00e1vel no chip Kingston).</p> </li> <li> <p>Page Fault Limitrofico: A TLB errou e teve que rolar pra Main RAM puxando o endere\u00e7o mapeado localizando num novo cluster na pilha. (100+ ciclos)</p> </li> <li> <p>Page Fault Cr\u00edtico (SWAP): A m\u00e1quina n\u00e3o acha e entra em Swapping com o SSD (SSD Swap). \u00c9 ali que ocorre as quedas colossais para \"Travamento de Janela\", a CPU foi pro SSD buscar um arquivo gigante que o Linux ejetou l\u00e1, pra trazer e rebotar pra cima pra Mem\u00f3ria RAM f\u00edsica real, jogando pro seu c\u00f3digo que achava estar \"na mem\u00f3ria\" e dormiu (Milh\u00f5es de ciclos).</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-08/#solucao-da-questao-3-3-driblando-a-paginacao-como-programador-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. Driblando a Pagina\u00e7\u00e3o como Programador (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Ao iterarmos matrizes massivas (Matrizes 2D em C++) na ordem invertida ou em l\u00f3gicas dispersas <code>LinkedList-&gt;prox</code>, voc\u00ea n\u00e3o causa apenas Cache Miss da Aula 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes TLB Misses! Voc\u00ea induzir\u00e1 Page Faults insanos que derrubar\u00e3o o throughput (taxa de transfer\u00eancia de dados) em N fatores.</p> <p>Portanto: Localidade Espacial \u00e9 sagrada em Dados C/C++.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. Driblando a Pagina\u00e7\u00e3o como Programador determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-08/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li> <p>O ponteiro que o dev manipula com um <code>int *ptr = &amp;value</code> em qualquer IDE \u00e9 puramente 100% Virtual. \u00c9 o passaporte intermedi\u00e1rio.</p> </li> <li> <p>Nunca dependa da pagina\u00e7\u00e3o e arquivo local de Swap do Disco: os mil\u00e9simos de segundo viram minutos na Nuvem se o app \"estourar a cota da cloud\", sofrendo <code>Thrashing</code> com o Disco local para falsificar a RAM que ele acreditou ter num loop mal codificado ou em Leaks do M\u00f3dulo/Aula anterior.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-08/#solucao-da-questao-5-1-o-abismo-logico-a-memoria-virtual-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center.</p> <p>Todo processo que o Linux constr\u00f3i roda dentro de uma gigante Ilus\u00e3o. O endere\u00e7o do seu ponteiro <code>0x7ffeeB...</code> em C++ \u00e9 falso (Endere\u00e7o L\u00f3gico).</p> <p>O HW (Hardware MMU no processador) mais as planilhas do Sistema Operacional (Page Tables) formencem a liga\u00e7\u00e3o din\u00e2mica e escondida pra sua aplica\u00e7\u00e3o.</p> <p>A Mem\u00f3ria Virtual (VM) \u00e9 um sandu\u00edche mental e isolador protetor usado pelo S.O.</p> <p>Ela entrega para o ponteiro do processo o pretexto visual de que ele tem toda a mem\u00f3ria que ele quiser num universo cont\u00ednuo livre.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-09/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 09 - Processos e Threads","text":""},{"location":"exercicios/solucao-09/#solucao-e-explicacao-detalhada-aula-09-processos-e-threads","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 09 - Processos e Threads","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 09.</p>"},{"location":"exercicios/solucao-09/#solucao-da-questao-1-1-processos-isolamento-forte-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. Processos (Isolamento Forte) (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>).</p> <ul> <li> <p>O S.O. d\u00e1 ao Processo sua pr\u00f3pria e exclusiva Mem\u00f3ria Virtual (visto na Aula 8).</p> </li> <li> <p>O Processo tem sua exclusiva Pilha e n\u00e3o se mistura nunca. E isso isola falhas: se um Chrome (processo isolado) trava, n\u00e3o d\u00e1 tela azul na outra aba.</p> </li> <li> <p>A comunica\u00e7\u00e3o entre Processos (IPC - Inter-process Communication) \u00e9 pesada e necessita do S.O. atrav\u00e9s de Pipes ou Redes.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Processos (Isolamento Forte) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-09/#solucao-da-questao-2-2-threads-isolamento-fraco-partilha-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. Threads (Isolamento Fraco / Partilha) (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para Multithreading!</p> <p>Uma Thread \u00e9 simplesmente uma subdivis\u00e3o leve controlada do processo. Elas todas orbitam e vivem na exata MESMA MEM\u00d3RIA VIRTUAL (Heap) DO PROCESSO MESTRE.</p> <p>Duas <code>std::thread</code> manipulando os ponteiros apontam rigorosamente r\u00e1pido ao mesmo endere\u00e7o na RAM sem nenhuma barreira do S.O., o que traz milisegundos imbat\u00edveis versus IPC!</p> <p>Como ambas alteram ativamente a mesm\u00edssima RAM viva desprotegidas, se elas lerem/sobreescreverem juntas o mesmo byte int da Conta Banc\u00e1ria C++, ocorre o let\u00edfero e maldoso Data Race (Condi\u00e7\u00e3o de Corrida de Dados).</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Threads (Isolamento Fraco / Partilha) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-09/#solucao-da-questao-3-3-context-switch-a-faca-de-dois-gumes-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. Context Switch (A Faca de Dois Gumes) (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Quando escrevemos <code>\"Hello World\"</code>, achamos que a CPU roda por horas sem interrup\u00e7\u00f5es. Engano.</p> <p>O S.O. possui um n\u00facleo (Kernel Scheduler) que fatia mil\u00e9simos de mil\u00e9simos de segundos distribuindo uma core <code>i7-P</code> para a aba do Google, logo retira o Google e taca nos frames do VS-Code, em micro-loop alternante de Context Switches.</p> <p>O problema? Puxar e devolver o estado (registradores, program counter) na cache \u00e9 hiper custoso e derruba o Pipeline se abusado (overhead em CPU bound apps).</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. Context Switch (A Faca de Dois Gumes) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-09/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li> <p>Se a tarefa for CPU-Bound (requerer Matem\u00e1tica Bruta Massiva / Machine Learning), voc\u00ea cria Threads numerando-as pr\u00f3ximo n\u00famero oficial de n\u00facleos estritos da CPU, evitando desperd\u00edcio de overhead com Context Switches ilus\u00f3rios.</p> </li> <li> <p>\u00c9 muito f\u00e1cil em C/C++ estragar a vida financeira do cliente numa Race Condition compartilhada pelo Heap se n\u00e3o protegida... mas isso \u00e9 o tema da pr\u00f3xima aula!</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-09/#solucao-da-questao-5-1-processos-isolamento-forte-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. Processos (Isolamento Forte) (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>).</p> <ul> <li> <p>O S.O. d\u00e1 ao Processo sua pr\u00f3pria e exclusiva Mem\u00f3ria Virtual (visto na Aula 8).</p> </li> <li> <p>O Processo tem sua exclusiva Pilha e n\u00e3o se mistura nunca. E isso isola falhas: se um Chrome (processo isolado) trava, n\u00e3o d\u00e1 tela azul na outra aba.</p> </li> <li> <p>A comunica\u00e7\u00e3o entre Processos (IPC - Inter-process Communication) \u00e9 pesada e necessita do S.O. atrav\u00e9s de Pipes ou Redes.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Processos (Isolamento Forte) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-10/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":""},{"location":"exercicios/solucao-10/#solucao-e-explicacao-detalhada-aula-10-sincronizacao-e-concorrencia","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 10.</p>"},{"location":"exercicios/solucao-10/#solucao-da-questao-1-1-o-data-race-uma-colisao-inevitavel-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\".</p> <p>O HW (Processador) traduz internamente num RMW: Read (Puxa os 100 da RAM para o Registrador EAX), Modify (Adiciona +10 e vira 110 na ALU), e Write (Substitui na RAM os antigos 100 por 110).</p> <p>Se na fresta entre a Thread 1 preencher o EAX e depois descer ao RAM o valor 110... a Thread 2 rodar e \"puxar os mesm\u00edssimos originais 100\" para outro registrador (Context Switch), quando abas enviarem pra RAM final as sobreposi\u00e7\u00f5es as contas, um dos <code>10</code> desvanecer\u00e1, o banco perde e a vari\u00e1vel fica logicamente corrompida.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-10/#solucao-da-questao-2-2-mutex-e-the-critical-section-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. Mutex e The Critical Section (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As Locks (Travas) como padr\u00e3o Ouro C++: <code>std::mutex</code> (Mutual Exclusion).</p> <p>A \u00e1rea demarcada pelo lock a unlock \u00e9 intitulada Se\u00e7\u00e3o Cr\u00edtica. O poder e o problema do design residem a\u00ed: Se voc\u00ea for pregui\u00e7oso e prender 10.000 linhas da sua transa\u00e7\u00e3o atr\u00e1s da Se\u00e7\u00e3o Cr\u00edtica Mestre, o teu glorioso Processador Multicore Ultra de 32 cores se comportar\u00e1 como um rid\u00edculo e solit\u00e1rio Processador Antigo Pentium de 1 core single Threaded, derrubando teu design ao zero! Tudo vai rodar Enfileirado (Serializado). O bom C++ trava com extrema granuladidade e rapid\u00edssimo na vari\u00e1vel.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Mutex e The Critical Section determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-10/#solucao-da-questao-3-3-o-dilema-deadlock-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. O Dilema: Deadlock (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Mas e se o programador de Backend C/C++ prender (usou lock() ou Mutex) em A esperando que B seja terminado.. mas B s\u00f3 termina porque B precisa pegar lock() em A que t\u00e1 bloqueado?</p> <p>Ambos processos morrem na tela, dormindo inertes (Blocked State), enquanto a barra de % CPU despenca lentamente para ZERO! Seu Sistema Paralelo entrou em Deadlock. (O Abra\u00e7o Mortal Padr\u00e3o The Dining Philosophers). Um design multi-thread exige uma heuristica sagrada de adquirir as trancas Lock C++ em id\u00eantica e constante ordem arquitetural atrav\u00e9s dos sistemas, ou apelar a mec\u00e2nicas <code>std::lock()</code> que aplicam garantias subjacentes do Kernel.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. O Dilema: Deadlock determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-10/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li> <p>Mutex: Usa o sistema do n\u00facleo para trancar \u00e1reas exclusivas do Hardware (RAM).</p> </li> <li> <p>Se a concorr\u00eancia n\u00e3o tiver \"Se\u00e7\u00e3o Cr\u00edtica\" que lida com Grava\u00e7\u00e3o e tiver \"S\u00f3 Read-only\", n\u00e3o aplique trancas (Mutex) para n\u00e3o serializar as Threads da m\u00e1quina.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-10/#solucao-da-questao-5-1-o-data-race-uma-colisao-inevitavel-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\".</p> <p>O HW (Processador) traduz internamente num RMW: Read (Puxa os 100 da RAM para o Registrador EAX), Modify (Adiciona +10 e vira 110 na ALU), e Write (Substitui na RAM os antigos 100 por 110).</p> <p>Se na fresta entre a Thread 1 preencher o EAX e depois descer ao RAM o valor 110... a Thread 2 rodar e \"puxar os mesm\u00edssimos originais 100\" para outro registrador (Context Switch), quando abas enviarem pra RAM final as sobreposi\u00e7\u00f5es as contas, um dos <code>10</code> desvanecer\u00e1, o banco perde e a vari\u00e1vel fica logicamente corrompida.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-11/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 11 - Paralelismo no Hardware","text":""},{"location":"exercicios/solucao-11/#solucao-e-explicacao-detalhada-aula-11-paralelismo-no-hardware","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 11 - Paralelismo no Hardware","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 11.</p>"},{"location":"exercicios/solucao-11/#solucao-da-questao-1-1-multi-core-multiplos-nucleos-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. Multi-Core (M\u00faltiplos N\u00facleos) (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip).</p> <ul> <li> <p>Core F\u00edsico: \u00c9 uma CPU completa e independente, com sua pr\u00f3pria ALU, Unidade de Controle e Caches L1/L2 particulares.</p> </li> <li> <p>Cache L3 Compartilhado: Na maioria dos designs AMD e Intel reais, os M\u00faltiplos Cores (Ex: 8 Cores) conversam e trocam estados atrav\u00e9s de uma suntuosa e lenta \u00e1rea comum L3 que circunda todos os processadores ali impressos no wafer.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Multi-Core (M\u00faltiplos N\u00facleos) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-11/#solucao-da-questao-2-2-hyper-threading-smt-symmetrical-multi-threading-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. Hyper-Threading (SMT - Symmetrical Multi-Threading) (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux?</p> <p>Na aula 03, vimos que a execu\u00e7\u00e3o cruza pelo Pipeline ou pode esbarrar em ciclos ociosos na CU aguardando a Mem\u00f3ria Principal. O Hyper-Threading espeta um Segundo conjunto de Registradores e Hardware de Estado no mesmo Core. Enquanto o c\u00f3digo da Thread \"A\" est\u00e1 0.5 nanosegundo travada esperando chegar o dado lento da L3, o Core troca instantaneamente para o contexto da Thread \"B\", executando-o usando as mesmas Unidades L\u00f3gicas (ALU) num aproveitamento fabril monstruoso de 100%.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Hyper-Threading (SMT - Symmetrical Multi-Threading) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-11/#solucao-da-questao-3-3-gpus-o-paralelismo-macico-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. GPUs: O Paralelismo Maci\u00e7o (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>CPUs (Processadores) foram feitos para \"Serem R\u00e1pidos executando sequ\u00eancias l\u00f3gicas e IFs complexos\". Possuem Caches gigantes.</p> <p>GPUs (Placas de V\u00eddeo) foram feitas para \"Executar a MESM\u00cdSSIMA MIN\u00daSCULA matem\u00e1tica simultaneamente em milhares de pixels fracos\". Sem grandes condicionais, focando no Throughput.</p> <p>NVIDIA e CUDA (plataforma de C++) reinam supremas em Deep Learning e Criptografia exatamente porque pegam Loops For gigantescos de \u00c1lgebra Linear, e fracionam em 8.000 mini-n\u00facleos (CUDA cores) esmagando qualquer Intel Core i9 na lat\u00eancia matem\u00e1tica cont\u00ednua pura.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. GPUs: O Paralelismo Maci\u00e7o determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-11/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li> <p>Task Paralelism: Se tens l\u00f3gica variada, use a CPU Multi-Core C++ thread pool.</p> </li> <li> <p>Data Paralelism: Se a conta for a repeti\u00e7\u00e3o retumbante de um algoritmo id\u00eantico sobre 2 milh\u00f5es de dados sem depend\u00eancia de saltos complexos, mova-a da RAM \u00e0 VRAM da GPU via CUDA/OpenCL. A m\u00e9trica vai das horas paras os d\u00e9cimos de segundo.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-11/#solucao-da-questao-5-1-multi-core-multiplos-nucleos-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. Multi-Core (M\u00faltiplos N\u00facleos) (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip).</p> <ul> <li> <p>Core F\u00edsico: \u00c9 uma CPU completa e independente, com sua pr\u00f3pria ALU, Unidade de Controle e Caches L1/L2 particulares.</p> </li> <li> <p>Cache L3 Compartilhado: Na maioria dos designs AMD e Intel reais, os M\u00faltiplos Cores (Ex: 8 Cores) conversam e trocam estados atrav\u00e9s de uma suntuosa e lenta \u00e1rea comum L3 que circunda todos os processadores ali impressos no wafer.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Multi-Core (M\u00faltiplos N\u00facleos) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-12/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 12 - O Modelo de Mem\u00f3ria","text":""},{"location":"exercicios/solucao-12/#solucao-e-explicacao-detalhada-aula-12-o-modelo-de-memoria","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 12 - O Modelo de Mem\u00f3ria","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 12.</p>"},{"location":"exercicios/solucao-12/#solucao-da-questao-1-1-a-reordenacao-do-compilador-e-cpu-out-of-order-execution-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Voc\u00ea codifica:</p> <p>Um programador esperan\u00e7oso diz: \"Vou ler a v\u00e1riavel na Thread Oposta (Main)... e quando <code>FLAG</code> for true, sei que <code>X</code> \u00e9 impreterivelmente 42 pois executei a linha acima primeiro na tela!\"</p> <ol> <li> <p>O Compilador C++ (GCC -O3) pode achar que o PASSO B \u00e9 irrelevante para o PASSO A (n\u00e3o usam das mesmas m\u00e9tricas) e reordenar por conta pr\u00f3pria o seu execut\u00e1vel para gravar a FLAG e depois o 42 nas linhas do assembly.</p> </li> <li> <p>O CISC (Intel x86) Processador Superscalar Out-Of-Order percebe que a posi\u00e7\u00e3o de <code>x</code> estava fria na Cache L3, mas a vari\u00e1vel <code>FLAG</code> estava quente presa na L1D. Ele salva na FLAG imediatamente (Store Buffers), adiantando a etapa 2, antes da 1, para n\u00e3o morrer de \u00f3cio no Pipeline. E seu c\u00f3digo multi-thread infarta com B chegando a ser lido remotamente como TRUE com A ainda em <code>0</code> (zero)!!</p> </li> </ol> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-12/#solucao-da-questao-2-2-o-memory-model-consistencias-e-barreiras-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. O Memory Model (Consist\u00eancias e Barreiras) (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O C++11 emitiu formalmente o seu universal Memory Model definindo atrav\u00e9s da biblioteca <code>std::atomic</code> o que o Hardware tem permi\u00e7\u00f5es para Adiantar vs Trancar.</p> <ol> <li> <p>Relaxed Consistensy (<code>std::memory_order_relaxed</code>): A CPU \u00e9 dona, reordene como quiser em torno da sua vizinhan\u00e7a na RAM, apenas aplique na thread isolada em seguran\u00e7a. Performance brutal.</p> </li> <li> <p>Release / Acquire (<code>std::memory_order_acquire / release</code>): O padr\u00e3o para transferir fardos (como ler a Fila sem locks e sem medo da Out-Of-Order embaralhar flags finalizadoras de Loop C++ no hardware alheio do *Core 2).</p> </li> <li> <p>Sequential Consistency (<code>std::memory_order_seq_cst</code>): O C++ por default invoca barreiras completas absolutas el\u00e9tricas. For\u00e7a todas as cores (L1/L2) da CPU e do compilador a n\u00e3o alterarem NADA a ordem que seu texto determinou. Seguro, mas castrador de velocidade em processadores ARM.</p> </li> </ol> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. O Memory Model (Consist\u00eancias e Barreiras) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-12/#solucao-da-questao-3-3-memory-barriers-fences-nas-cpus-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. Memory Barriers (Fences) nas CPUs (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Se n\u00e3o tivessemos essa lei <code>std::atomic</code> no standard oficial do GCC, program\u00e1vamos via \"Gambiarra Intrinseca\" de Processador (Ex: Comando Assembler MFENCE ou SFENCE no Intel). Os Fences pro\u00edbem categoricamente a travessia de saltos das sub-opera\u00e7\u00f5es em Assembly, estancando a execu\u00e7\u00e3o como um sinaleiro fechado.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. Memory Barriers (Fences) nas CPUs determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-12/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li>Se duas \"Threads\" conversam atrav\u00e9s das mesmas vari\u00e1veis limpas de C e n\u00e3o possuam <code>std::mutex</code> da aula 10 as blindando, USE <code>std::atomic&lt;bool&gt;</code>. Do contr\u00e1rio voc\u00ea \u00e9 uma v\u00edtima da Superscalar Out Of Order Intel Architecture Pipeline (a reordena\u00e7\u00e3o el\u00e9trica).</li> </ul> <p>Isso enterra as nuances sombrias das mem\u00f3rias RAM + Cache. Agora mergulhemos no escuro do \"Lento Discovoador\": Os Armazenamentos (Avan\u00e7ar).</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-12/#solucao-da-questao-5-1-a-reordenacao-do-compilador-e-cpu-out-of-order-execution-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Voc\u00ea codifica:</p> <p>Um programador esperan\u00e7oso diz: \"Vou ler a v\u00e1riavel na Thread Oposta (Main)... e quando <code>FLAG</code> for true, sei que <code>X</code> \u00e9 impreterivelmente 42 pois executei a linha acima primeiro na tela!\"</p> <ol> <li> <p>O Compilador C++ (GCC -O3) pode achar que o PASSO B \u00e9 irrelevante para o PASSO A (n\u00e3o usam das mesmas m\u00e9tricas) e reordenar por conta pr\u00f3pria o seu execut\u00e1vel para gravar a FLAG e depois o 42 nas linhas do assembly.</p> </li> <li> <p>O CISC (Intel x86) Processador Superscalar Out-Of-Order percebe que a posi\u00e7\u00e3o de <code>x</code> estava fria na Cache L3, mas a vari\u00e1vel <code>FLAG</code> estava quente presa na L1D. Ele salva na FLAG imediatamente (Store Buffers), adiantando a etapa 2, antes da 1, para n\u00e3o morrer de \u00f3cio no Pipeline. E seu c\u00f3digo multi-thread infarta com B chegando a ser lido remotamente como TRUE com A ainda em <code>0</code> (zero)!!</p> </li> </ol> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-13/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 13 - Dispositivos de Armazenamento","text":""},{"location":"exercicios/solucao-13/#solucao-e-explicacao-detalhada-aula-13-dispositivos-de-armazenamento","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 13 - Dispositivos de Armazenamento","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 13.</p>"},{"location":"exercicios/solucao-13/#solucao-da-questao-1-1-hdd-hard-disk-drive-vs-ssd-sata-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. HDD (Hard Disk Drive) vs SSD (SATA) (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O disco de pratos girat\u00f3rios com uma agulha f\u00edsica.</p> <p>Armazenamento em chips de mem\u00f3ria Flash (NAND). Zero partes m\u00f3veis.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. HDD (Hard Disk Drive) vs SSD (SATA) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-13/#solucao-da-questao-2-2-nvme-o-limite-pcie-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. NVMe (O Limite PCIe) (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em que passam Gigabytes por segundo (ex: Gen4 cruza 7.000 MB/s).</p> <p>Isto alterou para sempre o Backend moderno: Os Softwares de Mem\u00f3ria In-Memory (Redis) est\u00e3o repensando paradigmas pois o Disco NVMe moderno \u00e0s vezes responde com velocidade que ro\u00e7a a velha mem\u00f3ria RAM DDR3!</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. NVMe (O Limite PCIe) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-13/#solucao-da-questao-3-3-iops-a-metrica-real-do-servidor-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. IOPS - A M\u00e9trica Real do Servidor (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Se a banda (MB/s) diz o volume da mangueira, os IOPS (Input/Output Operations Per Second) dizem quantos golpes a mangueira d\u00e1 por segundo.</p> <ul> <li>Quando voc\u00ea hospeda um App Node/Python que grava 1 milh\u00e3o de pequenos logs <code>.txt</code> de 1KB, n\u00e3o importa se voc\u00ea tem 7000 MB/s. Voc\u00ea precisa de IOPS Alt\u00edssimos, para que a fila matem\u00e1tica de Write Requests n\u00e3o trave seu servidor (<code>I/O Wait / Blocked</code>).</li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. IOPS - A M\u00e9trica Real do Servidor determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-13/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O desenvolvedor C++ entende isso programando a I/O por grandes lotes (<code>Buffers</code>). N\u00e3o escreva no disco <code>1 byte</code> no la\u00e7o for por <code>1 milh\u00e3o de vezes</code> (Destrui\u00e7\u00e3o de IOPS).</p> <p>Acumule os dados num Buffer gig\u00e2ntico de <code>1 MB</code> na RAM, e comande gravar os dados no SSD em \u00fanico e massivo Request! (Otimiza\u00e7\u00e3o m\u00e1xima de Throughput).</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-13/#solucao-da-questao-5-1-hdd-hard-disk-drive-vs-ssd-sata-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. HDD (Hard Disk Drive) vs SSD (SATA) (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O disco de pratos girat\u00f3rios com uma agulha f\u00edsica.</p> <p>Armazenamento em chips de mem\u00f3ria Flash (NAND). Zero partes m\u00f3veis.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. HDD (Hard Disk Drive) vs SSD (SATA) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-14/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 14 - Sistemas de Arquivos","text":""},{"location":"exercicios/solucao-14/#solucao-e-explicacao-detalhada-aula-14-sistemas-de-arquivos","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 14 - Sistemas de Arquivos","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 14.</p>"},{"location":"exercicios/solucao-14/#solucao-da-questao-1-1-o-v-node-inode-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. O V-Node / Inode (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster.</p> <p>O FS usa de \u00edndices num\u00e9ricos ultra-r\u00e1pidos: os Inodes.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. O V-Node / Inode determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-14/#solucao-da-questao-2-2-journaling-a-prova-contra-quedas-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. Journaling (A Prova contra Quedas) (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode.</p> <p>E se faltar luz na etapa 2? A parti\u00e7\u00e3o corromperia inteiramente para sempre (Problema antigo do FAT32).</p> <p>FSs modernos (NTFS, EXT4) usam Journaling. Antes de aplicar qualquer mudan\u00e7a no Inode oficial, eles \"anotam a inten\u00e7\u00e3o do que v\u00e3o fazer\" num Di\u00e1rio Oculto (Journal). Se a luz cai, ao ligar o PC, ele l\u00ea o di\u00e1rio oculto incompleto, reverte o estrago e devolve sua m\u00e1quina salva! \u00c9 a ess\u00eancia do conceito Atomicidade.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Journaling (A Prova contra Quedas) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-14/#solucao-da-questao-3-3-buffers-e-page-cache-por-que-linux-e-rapido-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido) (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>\"Escrever no disco\" via SysCall C++ <code>write()</code> ou <code>fwrite()</code> raramente vai pro HD!</p> <p>O Linux usa de forma abusiva toda a RAM ociosa do seu computador como um gigantesco Cache File. Ele capta suas writes e diz \"Gravei amig\u00e3o!\" mas jogou na RAM (Page Cache). Posteriormente ele realiza os envios reais para o Hardware agrupados (Flush / Sync).</p> <p>Essa m\u00e1gica salva a Morte do seu SSD (menos grava\u00e7\u00f5es simult\u00e2neas em desgaste das celulas NAND) e simula uma ilus\u00e3o de lentid\u00e3o zero ao usu\u00e1rio.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-14/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li> <p>Ao usar C/C++, chame o instr\u00ednseco <code>fsync()</code> se seu App for um Banco de Dados ou Software Cr\u00edtico Banc\u00e1rio for\u00e7ando a Cache RAM descarregar a for\u00e7a e salvar permanentemente no sil\u00edcio do disco.</p> </li> <li> <p>Nunca dependa da nomenclatura C: <code>/usr/foto.jpg</code>. Leia descritores de arquivo, file-pointers e fluxos bin\u00e1rios se for transitar redes em baixo n\u00edvel.</p> </li> </ul> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-14/#solucao-da-questao-5-1-o-v-node-inode-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. O V-Node / Inode (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster.</p> <p>O FS usa de \u00edndices num\u00e9ricos ultra-r\u00e1pidos: os Inodes.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. O V-Node / Inode determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-15/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 15 - Entrada e Sa\u00edda (I/O)","text":""},{"location":"exercicios/solucao-15/#solucao-e-explicacao-detalhada-aula-15-entrada-e-saida-io","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 15 - Entrada e Sa\u00edda (I/O)","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 15.</p>"},{"location":"exercicios/solucao-15/#solucao-da-questao-1-1-system-calls-o-pedagio-do-kernel-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. System Calls (O Ped\u00e1gio do Kernel) (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminante encerramento compuls\u00f3rio pelo Processador atrav\u00e9s do bloqueio de An\u00e9is de Prote\u00e7\u00e3o.</p> <p>Para acionar a Rede, o C++ precisa paralisar, invocar a sagrada System Call (Syscall, ex: write, sendto, read) que abre o portal para o S.O (Kernel Space). \u00c9 o Kernel Linux quem vai orquestrar a placa C de Ethernet.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. System Calls (O Ped\u00e1gio do Kernel) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-15/#solucao-da-questao-2-2-interrupcoes-vs-polling-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. Interrup\u00e7\u00f5es vs Polling (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\".</p> <ol> <li> <p>Polling (Desastroso): A CPU fica travada rodando <code>while(mouse_is_empty) {}</code> perguntando de nano em nanosegundo \"Chegou? E agora? E Agora?\". (Suga 100% da CPU por um mouse inerte).</p> </li> <li> <p>Interrupts (Moderno): A CPU delega para o controlador USB rodar a escuta passiva, e a CPU volta a fechar os frames de Game. Quando o usu\u00e1rio clica com o dedo, o Controlador injeta um choque el\u00e9trico no pino do Processador. Interrupt request (IRQ)! A CPU congela subitamente o Game, salva o contexto, trata o clique do Mouse rapidamente, e exuma a cena do Game novamente do congelamento.</p> </li> </ol> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. Interrup\u00e7\u00f5es vs Polling determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-15/#solucao-da-questao-3-3-dma-memoria-com-acesso-direto-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. DMA (Mem\u00f3ria com Acesso Direto) (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Mesmo com as Interrup\u00e7\u00f5es ajudando a n\u00e3o ficar paralisado Polling... Fazer a Placa de Rede encher a placa RAM transitando Bit a Bit passando pelo miolo doloroso da CPU era impratic\u00e1vel em Gigabit Ethernets.</p> <p>A revolu\u00e7\u00e3o moderna chama-se Direct Memory Access (DMA). Placas de Captura, NVMe e Placas de Rede conversam Diretamente com a Mem\u00f3ria RAM por vias de bypass.</p> <p>A CPU diz: \"Placa, baixe o NetFlix do Ponto P pro Q na RAM\". A Placa faz todo os trabalho violento por tr\u00e1s. A CPU usa seu pipeline pra c\u00e1lculos e matem\u00e1tica puros, enquanto sua mem\u00f3ria vai sendo injetada pela placa de v\u00eddeo via t\u00faneis secretos pelas pontes.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. DMA (Mem\u00f3ria com Acesso Direto) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-15/#solucao-da-questao-4-resumo-pratico-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - Resumo Pr\u00e1tico (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <ul> <li>Se a sua aplica\u00e7\u00e3o Web Framework ass\u00edncrona (como NodeJS ou Nginx C++) trava muito com \"I/O\", isso significa que o Sistema delega opera\u00e7\u00f5es custosas pelo DMA ao Kernel, enquanto orquestra Event-Loops aguardando os famigerados Interrupts de retorno.</li> </ul> <p>Fim do estudo base te\u00f3rico, chegamos ao final. \u00c9 hora de compilar conhecimento na Otimiza\u00e7\u00e3o Pura (Aula Final).</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de Resumo Pr\u00e1tico determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-15/#solucao-da-questao-5-1-system-calls-o-pedagio-do-kernel-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 1. System Calls (O Ped\u00e1gio do Kernel) (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminante encerramento compuls\u00f3rio pelo Processador atrav\u00e9s do bloqueio de An\u00e9is de Prote\u00e7\u00e3o.</p> <p>Para acionar a Rede, o C++ precisa paralisar, invocar a sagrada System Call (Syscall, ex: write, sendto, read) que abre o portal para o S.O (Kernel Space). \u00c9 o Kernel Linux quem vai orquestrar a placa C de Ethernet.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. System Calls (O Ped\u00e1gio do Kernel) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"exercicios/solucao-16/","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":""},{"location":"exercicios/solucao-16/#solucao-e-explicacao-detalhada-aula-16-projeto-final-otimizacao-baseada-em-hardware","title":"Solu\u00e7\u00e3o e Explica\u00e7\u00e3o Detalhada: Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":"<p>Abaixo est\u00e3o as respostas esperadas e o embasamento te\u00f3rico para os exerc\u00edcios propostos na Aula 16.</p>"},{"location":"exercicios/solucao-16/#solucao-da-questao-1-1-profiling-classico-a-vida-real-basico-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 1 - 1. Profiling Cl\u00e1ssico (A Vida Real) (B\u00e1sico 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior.</p> <p>Usamos ferramentas robustas para que a Arquitetura Linux diga-nos onde os gargalos fervem a CPU.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Profiling Cl\u00e1ssico (A Vida Real) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-16/#solucao-da-questao-2-2-o-grande-desafio-mini-projeto-pratico-basico-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 2 - 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) (B\u00e1sico 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware:</p> <ol> <li> <p>Alocar um Array gigantesco Massivo no Heap Din\u00e2mico via <code>malloc()</code> C (N\u00e3o use vectors prontos para sentir a dor no bra\u00e7o).</p> </li> <li> <p>Criar duas l\u00f3gicas for().</p> </li> <li> <p>A primeira varre a matriz na exata sequencia alg\u00e9brica Row-Major. Explorando a TLB/Localidade da Aula 08 e 06.</p> </li> <li> <p>O segundo For varre as colunas saltando a intervalos gigantescos. Omiss\u00f5es grotescas de Cache Miss.</p> </li> <li> <p>Invoquem o <code>std::chrono</code> em volta das fun\u00e7\u00f5es, me\u00e7am os Mils e relatem num documento Markdown o porqu\u00ea de um Software ser 10 vezes mais r\u00e1pido que o outro mesmo usando \"a c\u00f3pia mental perfeitamente id\u00eantica das mesm\u00edssimas opera\u00e7\u00f5es de if e soma na ALU\".</p> </li> </ol> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-16/#solucao-da-questao-3-3-conclusao-da-trilha-intermediario-1","title":"Solu\u00e7\u00e3o da Quest\u00e3o 3 - 3. Conclus\u00e3o da Trilha (Intermedi\u00e1rio 1)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada.</p> <p>Um engenheiro de Backend jamais olhar\u00e1 para <code>int x;</code> ou <code>for()</code> sem recordar os impactos t\u00e9rmicos, cache hits mortais de linha, L1 local, reordena\u00e7\u00f5es do std::atomic Memory Model ou Page Faults nos clusters de Sistema e Processos em Swap.</p> <p>Parab\u00e9ns pela resili\u00eancia no vale do Sil\u00edcio e da Matem\u00e1tica discreta profunda.</p> <p>Nunca pare de medir e Otimizar. O Hardware dita as leis; o Software obedece.</p> <p> Finalizar e Visitar Projetos</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 3. Conclus\u00e3o da Trilha determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-16/#solucao-da-questao-4-1-profiling-classico-a-vida-real-intermediario-2","title":"Solu\u00e7\u00e3o da Quest\u00e3o 4 - 1. Profiling Cl\u00e1ssico (A Vida Real) (Intermedi\u00e1rio 2)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior.</p> <p>Usamos ferramentas robustas para que a Arquitetura Linux diga-nos onde os gargalos fervem a CPU.</p> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 1. Profiling Cl\u00e1ssico (A Vida Real) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p>"},{"location":"exercicios/solucao-16/#solucao-da-questao-5-2-o-grande-desafio-mini-projeto-pratico-desafio","title":"Solu\u00e7\u00e3o da Quest\u00e3o 5 - 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) (Desafio)","text":"<p>Explica\u00e7\u00e3o Detalhada do Assunto:</p> <p>O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware:</p> <ol> <li> <p>Alocar um Array gigantesco Massivo no Heap Din\u00e2mico via <code>malloc()</code> C (N\u00e3o use vectors prontos para sentir a dor no bra\u00e7o).</p> </li> <li> <p>Criar duas l\u00f3gicas for().</p> </li> <li> <p>A primeira varre a matriz na exata sequencia alg\u00e9brica Row-Major. Explorando a TLB/Localidade da Aula 08 e 06.</p> </li> <li> <p>O segundo For varre as colunas saltando a intervalos gigantescos. Omiss\u00f5es grotescas de Cache Miss.</p> </li> <li> <p>Invoquem o <code>std::chrono</code> em volta das fun\u00e7\u00f5es, me\u00e7am os Mils e relatem num documento Markdown o porqu\u00ea de um Software ser 10 vezes mais r\u00e1pido que o outro mesmo usando \"a c\u00f3pia mental perfeitamente id\u00eantica das mesm\u00edssimas opera\u00e7\u00f5es de if e soma na ALU\".</p> </li> </ol> <p>Expectativa de Resposta</p> <p>O aluno deve inferir com clareza que o conceito de 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) determina o desempenho global e n\u00e3o pode ser ignorado nas linguagens compiladas. Para n\u00edveis intermedi\u00e1rios e desafio, exige-se consci\u00eancia das integra\u00e7\u00f5es entre RAM, CPU e Kernel.</p> <p> Voltar para Exerc\u00edcio</p>"},{"location":"projetos/","title":"Laborat\u00f3rios de Projetos","text":""},{"location":"projetos/#laboratorios-de-projetos","title":"Laborat\u00f3rios de Projetos","text":"<p>Coloque em pr\u00e1tica seu aprendizado de Hardware implementando ferramentas reais com C/C++.</p>"},{"location":"projetos/#modulo-1-fundamentos-de-arquitetura-de-computadores","title":"M\u00f3dulo 1 \u2013 Fundamentos de Arquitetura de Computadores","text":"<ul> <li> Lab 01 - Como o Software Roda no Hardware</li> <li> Lab 02 - Representa\u00e7\u00e3o de Dados</li> <li> Lab 03 - CPU: Estrutura e Funcionamento</li> <li> Lab 04 - Arquiteturas RISC vs CISC</li> </ul>"},{"location":"projetos/#modulo-2-memoria-e-performance","title":"M\u00f3dulo 2 \u2013 Mem\u00f3ria e Performance","text":"<ul> <li> Lab 05 - Hierarquia de Mem\u00f3ria</li> <li> Lab 06 - Cache e Localidade</li> <li> Lab 07 - Stack vs Heap</li> <li> Lab 08 - Mem\u00f3ria Virtual</li> </ul>"},{"location":"projetos/#modulo-3-concorrencia-e-paralelismo","title":"M\u00f3dulo 3 \u2013 Concorr\u00eancia e Paralelismo","text":"<ul> <li> Lab 09 - Processos e Threads</li> <li> Lab 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia</li> <li> Lab 11 - Paralelismo no Hardware</li> <li> Lab 12 - O Modelo de Mem\u00f3ria</li> </ul>"},{"location":"projetos/#modulo-4-armazenamento-io-e-pratica","title":"M\u00f3dulo 4 \u2013 Armazenamento, I/O e Pr\u00e1tica","text":"<ul> <li> Lab 13 - Dispositivos de Armazenamento</li> <li> Lab 14 - Sistemas de Arquivos</li> <li> Lab 15 - Entrada e Sa\u00edda (I/O)</li> <li> Lab 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware</li> </ul>"},{"location":"projetos/projeto-01/","title":"Projeto 01: Aula 01 - Como o Software Roda no Hardware","text":""},{"location":"projetos/projeto-01/#projeto-01-aula-01-como-o-software-roda-no-hardware","title":"Projeto 01: Aula 01 - Como o Software Roda no Hardware","text":""},{"location":"projetos/projeto-01/#laboratorio-pratico-aula-01-como-o-software-roda-no-hardware","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 01 - Como o Software Roda no Hardware","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, **Bin\u00e1rios...</p> <p>A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance:...</p> <p>Todo c\u00f3digo, por mais sofisticado que seja, precisa ser reduzido a estas poucas opera\u00e7\u00f5es ditadas pela ISA para rodar....</p>"},{"location":"projetos/projeto-01/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. O Abismo entre C\u00f3digo e Sil\u00edcio no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. Compiladores vs Interpretadores no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. ISA: O Contrato do Processador no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-01/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-02/","title":"Projeto 02: Aula 02 - Representa\u00e7\u00e3o de Dados","text":""},{"location":"projetos/projeto-02/#projeto-02-aula-02-representacao-de-dados","title":"Projeto 02: Aula 02 - Representa\u00e7\u00e3o de Dados","text":""},{"location":"projetos/projeto-02/#laboratorio-pratico-aula-02-representacao-de-dados","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 02 - Representa\u00e7\u00e3o de Dados","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal)....</p> <p>Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware:...</p> <p>Os famosos tipos <code>float</code> e <code>double</code>. O processador possui normalmente um setor dedicado de FPU (Floating Point Unit) para eles....</p>"},{"location":"projetos/projeto-02/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. Sistema Bin\u00e1rio e Hexadecimal no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. Inteiros com e sem Sinal (Unsigned) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. Ponto Flutuante (IEEE 754) no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-02/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-03/","title":"Projeto 03: Aula 03 - CPU: Estrutura e Funcionamento","text":""},{"location":"projetos/projeto-03/#projeto-03-aula-03-cpu-estrutura-e-funcionamento","title":"Projeto 03: Aula 03 - CPU: Estrutura e Funcionamento","text":""},{"location":"projetos/projeto-03/#laboratorio-pratico-aula-03-cpu-estrutura-e-funcionamento","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 03 - CPU: Estrutura e Funcionamento","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais:...</p> <p>Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do Clock pelo ciclo cl\u00e1ssico:...</p> <p>Seu processador n\u00e3o faz essas 4 etapas de forma burra (uma por vez). Ele usa Pipelining: Enquanto a Instru\u00e7\u00e3o A est\u00e1 em Execute, a Instru\u00e7\u00e3o B j\u00e1 est\u00e1 em Decode e a Instru\u00e7\u00e3o C est\u00e1 em Fetch!...</p>"},{"location":"projetos/projeto-03/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction) no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-03/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-04/","title":"Projeto 04: Aula 04 - Arquiteturas RISC vs CISC","text":""},{"location":"projetos/projeto-04/#projeto-04-aula-04-arquiteturas-risc-vs-cisc","title":"Projeto 04: Aula 04 - Arquiteturas RISC vs CISC","text":""},{"location":"projetos/projeto-04/#laboratorio-pratico-aula-04-arquiteturas-risc-vs-cisc","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 04 - Arquiteturas RISC vs CISC","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais barat...</p> <p>Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas:...</p> <ul> <li>Historicamente, servidores eram puramente CISC (Intel)....</li> </ul>"},{"location":"projetos/projeto-04/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. Entendendo a Batalha no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. Como isso afeta o Compilador C/C++? no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente Resumo Pr\u00e1tico no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-04/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-05/","title":"Projeto 05: Aula 05 - Hierarquia de Mem\u00f3ria","text":""},{"location":"projetos/projeto-05/#projeto-05-aula-05-hierarquia-de-memoria","title":"Projeto 05: Aula 05 - Hierarquia de Mem\u00f3ria","text":""},{"location":"projetos/projeto-05/#laboratorio-pratico-aula-05-hierarquia-de-memoria","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 05 - Hierarquia de Mem\u00f3ria","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda:...</p> <p>Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty....</p> <p>Por que linguagens como C e C++ dominam infraestrutura de servidores High Frequency Trading?...</p>"},{"location":"projetos/projeto-05/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. A Pir\u00e2mide de Alta Performance no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. Optimizando Uso no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-05/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-06/","title":"Projeto 06: Aula 06 - Cache e Localidade","text":""},{"location":"projetos/projeto-06/#projeto-06-aula-06-cache-e-localidade","title":"Projeto 06: Aula 06 - Cache e Localidade","text":""},{"location":"projetos/projeto-06/#laboratorio-pratico-aula-06-cache-e-localidade","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 06 - Cache e Localidade","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate....</p> <p>As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada):...</p> <p>A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo....</p>"},{"location":"projetos/projeto-06/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. Cache Hit e Cache Miss no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. Localidade Espacial vs Temporal no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. False Sharing e L\u00f3gica Invertida (A Morte do C++) no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-06/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-07/","title":"Projeto 07: Aula 07 - Stack vs Heap","text":""},{"location":"projetos/projeto-07/#projeto-07-aula-07-stack-vs-heap","title":"Projeto 07: Aula 07 - Stack vs Heap","text":""},{"location":"projetos/projeto-07/#laboratorio-pratico-aula-07-stack-vs-heap","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 07 - Stack vs Heap","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, Fir...</p> <p>Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob ...</p> <p>Um cl\u00e1ssico e letal bug de engenharia C++. Quando o desenvolvedor executa <code>new</code> ou <code>malloc</code> solicitando mem\u00f3ria do Heap, mas quebra regras do fluxo perdendo o contato formal do ponteiro retorn...</p>"},{"location":"projetos/projeto-07/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. A Pilha (Stack) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. O Monte (Heap) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. Memory Leaks (Vazamentos de Mem\u00f3ria) no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-07/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-08/","title":"Projeto 08: Aula 08 - Mem\u00f3ria Virtual","text":""},{"location":"projetos/projeto-08/#projeto-08-aula-08-memoria-virtual","title":"Projeto 08: Aula 08 - Mem\u00f3ria Virtual","text":""},{"location":"projetos/projeto-08/#laboratorio-pratico-aula-08-memoria-virtual","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 08 - Mem\u00f3ria Virtual","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center....</p> <p>Para driblar isso, a arquitetura moderna usa a TLB (Translation Lookaside Buffer). A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem ...</p> <p>Ao iterarmos matrizes massivas (Matrizes 2D em C++) na ordem invertida ou em l\u00f3gicas dispersas <code>LinkedList-&gt;prox</code>, voc\u00ea n\u00e3o causa apenas Cache Miss da Aula 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de po...</p>"},{"location":"projetos/projeto-08/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. Driblando a Pagina\u00e7\u00e3o como Programador no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-08/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-09/","title":"Projeto 09: Aula 09 - Processos e Threads","text":""},{"location":"projetos/projeto-09/#projeto-09-aula-09-processos-e-threads","title":"Projeto 09: Aula 09 - Processos e Threads","text":""},{"location":"projetos/projeto-09/#laboratorio-pratico-aula-09-processos-e-threads","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 09 - Processos e Threads","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>)....</p> <p>Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para Multithreading!...</p> <p>Quando escrevemos <code>\"Hello World\"</code>, achamos que a CPU roda por horas sem interrup\u00e7\u00f5es. Engano....</p>"},{"location":"projetos/projeto-09/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. Processos (Isolamento Forte) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. Threads (Isolamento Fraco / Partilha) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. Context Switch (A Faca de Dois Gumes) no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-09/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-10/","title":"Projeto 10: Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":""},{"location":"projetos/projeto-10/#projeto-10-aula-10-sincronizacao-e-concorrencia","title":"Projeto 10: Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":""},{"location":"projetos/projeto-10/#laboratorio-pratico-aula-10-sincronizacao-e-concorrencia","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\"....</p> <p>A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As Locks (Travas) como padr\u00e3o Ouro C++: <code>std::mutex</code> (Mutual Exclus...</p> <p>Mas e se o programador de Backend C/C++ prender (usou lock() ou Mutex) em A esperando que B seja terminado.. mas B s\u00f3 termina porque B precisa pegar lock() em A que t\u00e1 bloqueado?...</p>"},{"location":"projetos/projeto-10/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. Mutex e The Critical Section no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. O Dilema: Deadlock no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-10/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-11/","title":"Projeto 11: Aula 11 - Paralelismo no Hardware","text":""},{"location":"projetos/projeto-11/#projeto-11-aula-11-paralelismo-no-hardware","title":"Projeto 11: Aula 11 - Paralelismo no Hardware","text":""},{"location":"projetos/projeto-11/#laboratorio-pratico-aula-11-paralelismo-no-hardware","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 11 - Paralelismo no Hardware","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip)....</p> <p>A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux?...</p> <p>CPUs (Processadores) foram feitos para \"Serem R\u00e1pidos executando sequ\u00eancias l\u00f3gicas e IFs complexos\". Possuem Caches gigantes....</p>"},{"location":"projetos/projeto-11/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. Multi-Core (M\u00faltiplos N\u00facleos) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. Hyper-Threading (SMT - Symmetrical Multi-Threading) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. GPUs: O Paralelismo Maci\u00e7o no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-11/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-12/","title":"Projeto 12: Aula 12 - O Modelo de Mem\u00f3ria","text":""},{"location":"projetos/projeto-12/#projeto-12-aula-12-o-modelo-de-memoria","title":"Projeto 12: Aula 12 - O Modelo de Mem\u00f3ria","text":""},{"location":"projetos/projeto-12/#laboratorio-pratico-aula-12-o-modelo-de-memoria","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 12 - O Modelo de Mem\u00f3ria","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>Voc\u00ea codifica:...</p> <p>O C++11 emitiu formalmente o seu universal Memory Model definindo atrav\u00e9s da biblioteca <code>std::atomic</code> o que o Hardware tem permi\u00e7\u00f5es para Adiantar vs Trancar....</p> <p>Se n\u00e3o tivessemos essa lei <code>std::atomic</code> no standard oficial do GCC, program\u00e1vamos via \"Gambiarra Intrinseca\" de Processador (Ex: Comando Assembler MFENCE ou SFENCE no Intel). Os Fences pro\u00edbe...</p>"},{"location":"projetos/projeto-12/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. O Memory Model (Consist\u00eancias e Barreiras) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. Memory Barriers (Fences) nas CPUs no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-12/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-13/","title":"Projeto 13: Aula 13 - Dispositivos de Armazenamento","text":""},{"location":"projetos/projeto-13/#projeto-13-aula-13-dispositivos-de-armazenamento","title":"Projeto 13: Aula 13 - Dispositivos de Armazenamento","text":""},{"location":"projetos/projeto-13/#laboratorio-pratico-aula-13-dispositivos-de-armazenamento","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 13 - Dispositivos de Armazenamento","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>...</p> <p>Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisica...</p> <p>Se a banda (MB/s) diz o volume da mangueira, os IOPS (Input/Output Operations Per Second) dizem quantos golpes a mangueira d\u00e1 por segundo....</p>"},{"location":"projetos/projeto-13/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. HDD (Hard Disk Drive) vs SSD (SATA) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. NVMe (O Limite PCIe) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. IOPS - A M\u00e9trica Real do Servidor no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-13/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-14/","title":"Projeto 14: Aula 14 - Sistemas de Arquivos","text":""},{"location":"projetos/projeto-14/#projeto-14-aula-14-sistemas-de-arquivos","title":"Projeto 14: Aula 14 - Sistemas de Arquivos","text":""},{"location":"projetos/projeto-14/#laboratorio-pratico-aula-14-sistemas-de-arquivos","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 14 - Sistemas de Arquivos","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster....</p> <p>Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode....</p> <p>\"Escrever no disco\" via SysCall C++ <code>write()</code> ou <code>fwrite()</code> raramente vai pro HD!...</p>"},{"location":"projetos/projeto-14/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. O V-Node / Inode no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. Journaling (A Prova contra Quedas) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido) no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-14/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-15/","title":"Projeto 15: Aula 15 - Entrada e Sa\u00edda (I/O)","text":""},{"location":"projetos/projeto-15/#projeto-15-aula-15-entrada-e-saida-io","title":"Projeto 15: Aula 15 - Entrada e Sa\u00edda (I/O)","text":""},{"location":"projetos/projeto-15/#laboratorio-pratico-aula-15-entrada-e-saida-io","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 15 - Entrada e Sa\u00edda (I/O)","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera u...</p> <p>Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\"....</p> <p>Mesmo com as Interrup\u00e7\u00f5es ajudando a n\u00e3o ficar paralisado Polling... Fazer a Placa de Rede encher a placa RAM transitando Bit a Bit passando pelo miolo doloroso da CPU era impratic\u00e1vel em Gigabit Et...</p>"},{"location":"projetos/projeto-15/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. System Calls (O Ped\u00e1gio do Kernel) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. Interrup\u00e7\u00f5es vs Polling no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. DMA (Mem\u00f3ria com Acesso Direto) no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-15/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"projetos/projeto-16/","title":"Projeto 16: Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":""},{"location":"projetos/projeto-16/#projeto-16-aula-16-projeto-final-otimizacao-baseada-em-hardware","title":"Projeto 16: Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":""},{"location":"projetos/projeto-16/#laboratorio-pratico-aula-16-projeto-final-otimizacao-baseada-em-hardware","title":"\ud83d\ude80 Laborat\u00f3rio Pr\u00e1tico: Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":"<p>Construa uma simula\u00e7\u00e3o l\u00f3gica ou um roteiro anal\u00edtico em linguagem C/C++ focado no fen\u00f4meno real ocorrido no Hardware baseando-se em:</p> <p>Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior....</p> <p>O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware:...</p> <p>Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada....</p>"},{"location":"projetos/projeto-16/#tarefas-do-projeto","title":"Tarefas do Projeto","text":"<ul> <li>[ ] Setup Inicial: Alocar perfeitamente os arquivos como <code>main.cpp</code> em sua IDE configurando compilador GCC/Clang.</li> <li>[ ] M\u00f3dulo 1: Implementar, prototipar ou demonstrar funcionalmente 1. Profiling Cl\u00e1ssico (A Vida Real) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 2: Implementar, prototipar ou demonstrar funcionalmente 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) no c\u00f3digo.</li> <li>[ ] M\u00f3dulo 3: Implementar, prototipar ou demonstrar funcionalmente 3. Conclus\u00e3o da Trilha no c\u00f3digo.</li> <li>[ ] Valida\u00e7\u00e3o E Benchmark: Fazer o build via terminal e testar limites de velocidade analiticamente comparando o log de transi\u00e7\u00e3o.</li> </ul>"},{"location":"projetos/projeto-16/#criterios-de-qualidade-review","title":"\ud83c\udfc6 Crit\u00e9rios de Qualidade (Review)","text":"<ol> <li>Compila estritamente sem nenhum warning de memory loss ou fallback.</li> <li>Adere e representa fielmente 100% \u00e0 teoria aprendida do Markdown da Aula correspondente.</li> <li>Estrutura\u00e7\u00e3o modular limpa para f\u00e1cil manuten\u00e7\u00e3o.</li> </ol>"},{"location":"quizzes/","title":"Quizzes Interativos","text":""},{"location":"quizzes/#quizzes-interativos","title":"Quizzes Interativos","text":"<p>Teste os seus conhecimentos adquiridos durantes as explora\u00e7\u00f5es te\u00f3ricas.</p>"},{"location":"quizzes/#modulo-1-fundamentos-de-arquitetura-de-computadores","title":"M\u00f3dulo 1 \u2013 Fundamentos de Arquitetura de Computadores","text":"<ul> <li> Quiz 01 - Como o Software Roda no Hardware</li> <li> Quiz 02 - Representa\u00e7\u00e3o de Dados</li> <li> Quiz 03 - CPU: Estrutura e Funcionamento</li> <li> Quiz 04 - Arquiteturas RISC vs CISC</li> </ul>"},{"location":"quizzes/#modulo-2-memoria-e-performance","title":"M\u00f3dulo 2 \u2013 Mem\u00f3ria e Performance","text":"<ul> <li> Quiz 05 - Hierarquia de Mem\u00f3ria</li> <li> Quiz 06 - Cache e Localidade</li> <li> Quiz 07 - Stack vs Heap</li> <li> Quiz 08 - Mem\u00f3ria Virtual</li> </ul>"},{"location":"quizzes/#modulo-3-concorrencia-e-paralelismo","title":"M\u00f3dulo 3 \u2013 Concorr\u00eancia e Paralelismo","text":"<ul> <li> Quiz 09 - Processos e Threads</li> <li> Quiz 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia</li> <li> Quiz 11 - Paralelismo no Hardware</li> <li> Quiz 12 - O Modelo de Mem\u00f3ria</li> </ul>"},{"location":"quizzes/#modulo-4-armazenamento-io-e-pratica","title":"M\u00f3dulo 4 \u2013 Armazenamento, I/O e Pr\u00e1tica","text":"<ul> <li> Quiz 13 - Dispositivos de Armazenamento</li> <li> Quiz 14 - Sistemas de Arquivos</li> <li> Quiz 15 - Entrada e Sa\u00edda (I/O)</li> <li> Quiz 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware</li> </ul>"},{"location":"quizzes/quiz-01/","title":"Quiz 01 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-01/#quiz-01-introducao","title":"Quiz 01 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. O Abismo entre C\u00f3digo e Sil\u00edcio** explicado em sala, indique a afirmativa verdadeira: Escrevemos *software* (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas **Sinais El\u00e9tricos** ou, abstraindo para o dom\u00ednio digital, **Bin\u00e1rios (0 e 1)**. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. Compiladores vs Interpretadores** explicado em sala, indique a afirmativa verdadeira: A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. ISA: O Contrato do Processador** explicado em sala, indique a afirmativa verdadeira: Todo c\u00f3digo, por mais sofisticado que seja, precisa ser reduzido a estas poucas opera\u00e7\u00f5es ditadas pela ISA para rodar. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Ao usar C/C++, voc\u00ea n\u00e3o lida com um motor intermedi\u00e1rio te cobrindo (como a JVM), voc\u00ea escreve algoritmos cuja gest\u00e3o \u00e9 delegada ao S.O. e rodada pura em metal. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. O Abismo entre C\u00f3digo e Sil\u00edcio** explicado em sala, indique a afirmativa verdadeira: Escrevemos *software* (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas **Sinais El\u00e9tricos** ou, abstraindo para o dom\u00ednio digital, **Bin\u00e1rios (0 e 1)**. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. Compiladores vs Interpretadores** explicado em sala, indique a afirmativa verdadeira: A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. ISA: O Contrato do Processador** explicado em sala, indique a afirmativa verdadeira: Todo c\u00f3digo, por mais sofisticado que seja, precisa ser reduzido a estas poucas opera\u00e7\u00f5es ditadas pela ISA para rodar. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Ao usar C/C++, voc\u00ea n\u00e3o lida com um motor intermedi\u00e1rio te cobrindo (como a JVM), voc\u00ea escreve algoritmos cuja gest\u00e3o \u00e9 delegada ao S.O. e rodada pura em metal. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. O Abismo entre C\u00f3digo e Sil\u00edcio** explicado em sala, indique a afirmativa verdadeira: Escrevemos *software* (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas **Sinais El\u00e9tricos** ou, abstraindo para o dom\u00ednio digital, **Bin\u00e1rios (0 e 1)**. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. Compiladores vs Interpretadores** explicado em sala, indique a afirmativa verdadeira: A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-02/","title":"Quiz 02 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-02/#quiz-02-introducao","title":"Quiz 02 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. Sistema Bin\u00e1rio e Hexadecimal** explicado em sala, indique a afirmativa verdadeira: O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. Inteiros com e sem Sinal (Unsigned)** explicado em sala, indique a afirmativa verdadeira: Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. Ponto Flutuante (IEEE 754)** explicado em sala, indique a afirmativa verdadeira: Os famosos tipos `float` e `double`. O processador possui normalmente um setor dedicado de FPU (Floating Point Unit) para eles. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: A maneira como voc\u00ea escolhe o tipo primitivo da vari\u00e1vel modela a fisionomia do registrador acionado na m\u00e1quina durante o *fetch*. Entender o *Overflow* \u00e9 a prote\u00e7\u00e3o b\u00e1sica contra corrup\u00e7\u00e3o l\u00f3gica do c\u00f3digo. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. Sistema Bin\u00e1rio e Hexadecimal** explicado em sala, indique a afirmativa verdadeira: O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. Inteiros com e sem Sinal (Unsigned)** explicado em sala, indique a afirmativa verdadeira: Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. Ponto Flutuante (IEEE 754)** explicado em sala, indique a afirmativa verdadeira: Os famosos tipos `float` e `double`. O processador possui normalmente um setor dedicado de FPU (Floating Point Unit) para eles. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: A maneira como voc\u00ea escolhe o tipo primitivo da vari\u00e1vel modela a fisionomia do registrador acionado na m\u00e1quina durante o *fetch*. Entender o *Overflow* \u00e9 a prote\u00e7\u00e3o b\u00e1sica contra corrup\u00e7\u00e3o l\u00f3gica do c\u00f3digo. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. Sistema Bin\u00e1rio e Hexadecimal** explicado em sala, indique a afirmativa verdadeira: O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. Inteiros com e sem Sinal (Unsigned)** explicado em sala, indique a afirmativa verdadeira: Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-03/","title":"Quiz 03 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-03/#quiz-03-introducao","title":"Quiz 03 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores** explicado em sala, indique a afirmativa verdadeira: A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute)** explicado em sala, indique a afirmativa verdadeira: Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do *Clock* pelo ciclo cl\u00e1ssico: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction)** explicado em sala, indique a afirmativa verdadeira: Seu processador n\u00e3o faz essas 4 etapas de forma burra (uma por vez). Ele usa **Pipelining**: Enquanto a Instru\u00e7\u00e3o A est\u00e1 em Execute, a Instru\u00e7\u00e3o B j\u00e1 est\u00e1 em Decode e a Instru\u00e7\u00e3o C est\u00e1 em Fetch! \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: Registradores s\u00e3o seus maiores amigos de performance. C\u00f3digos C++ que permitem ao compilador prender c\u00e1lculos pesados 100% dentro dos Registradores rodam em Nanossegundos, contra Milissegundos lendo sempre pela RAM. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores** explicado em sala, indique a afirmativa verdadeira: A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute)** explicado em sala, indique a afirmativa verdadeira: Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do *Clock* pelo ciclo cl\u00e1ssico: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction)** explicado em sala, indique a afirmativa verdadeira: Seu processador n\u00e3o faz essas 4 etapas de forma burra (uma por vez). Ele usa **Pipelining**: Enquanto a Instru\u00e7\u00e3o A est\u00e1 em Execute, a Instru\u00e7\u00e3o B j\u00e1 est\u00e1 em Decode e a Instru\u00e7\u00e3o C est\u00e1 em Fetch! \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: Registradores s\u00e3o seus maiores amigos de performance. C\u00f3digos C++ que permitem ao compilador prender c\u00e1lculos pesados 100% dentro dos Registradores rodam em Nanossegundos, contra Milissegundos lendo sempre pela RAM. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores** explicado em sala, indique a afirmativa verdadeira: A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute)** explicado em sala, indique a afirmativa verdadeira: Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do *Clock* pelo ciclo cl\u00e1ssico: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-04/","title":"Quiz 04 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-04/#quiz-04-introducao","title":"Quiz 04 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. Entendendo a Batalha** explicado em sala, indique a afirmativa verdadeira: A grande revolu\u00e7\u00e3o do backend \u00e9: Seu *deploy* de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. Como isso afeta o Compilador C/C++?** explicado em sala, indique a afirmativa verdadeira: Como programador, ao compilar nosso software, a *Target Architecture* \u00e9 o divisor de \u00e1guas: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Historicamente, servidores eram puramente CISC (Intel). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **1. Entendendo a Batalha** explicado em sala, indique a afirmativa verdadeira: A grande revolu\u00e7\u00e3o do backend \u00e9: Seu *deploy* de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **2. Como isso afeta o Compilador C/C++?** explicado em sala, indique a afirmativa verdadeira: Como programador, ao compilar nosso software, a *Target Architecture* \u00e9 o divisor de \u00e1guas: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Historicamente, servidores eram puramente CISC (Intel). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **1. Entendendo a Batalha** explicado em sala, indique a afirmativa verdadeira: A grande revolu\u00e7\u00e3o do backend \u00e9: Seu *deploy* de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **2. Como isso afeta o Compilador C/C++?** explicado em sala, indique a afirmativa verdadeira: Como programador, ao compilar nosso software, a *Target Architecture* \u00e9 o divisor de \u00e1guas: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Historicamente, servidores eram puramente CISC (Intel). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **1. Entendendo a Batalha** explicado em sala, indique a afirmativa verdadeira: A grande revolu\u00e7\u00e3o do backend \u00e9: Seu *deploy* de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-05/","title":"Quiz 05 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-05/#quiz-05-introducao","title":"Quiz 05 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. A Pir\u00e2mide de Alta Performance** explicado em sala, indique a afirmativa verdadeira: Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe *em qual camada* a vari\u00e1vel se hospeda: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo)** explicado em sala, indique a afirmativa verdadeira: Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. Optimizando Uso** explicado em sala, indique a afirmativa verdadeira: Por que linguagens como C e C++ dominam infraestrutura de servidores High Frequency Trading? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Se processadores hoje s\u00e3o m\u00edsseis atingindo +4GHz, a RAM parou no tempo (Lat\u00eancia de CAS n\u00e3o baixa proporcionalmente). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. A Pir\u00e2mide de Alta Performance** explicado em sala, indique a afirmativa verdadeira: Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe *em qual camada* a vari\u00e1vel se hospeda: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo)** explicado em sala, indique a afirmativa verdadeira: Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. Optimizando Uso** explicado em sala, indique a afirmativa verdadeira: Por que linguagens como C e C++ dominam infraestrutura de servidores High Frequency Trading? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Se processadores hoje s\u00e3o m\u00edsseis atingindo +4GHz, a RAM parou no tempo (Lat\u00eancia de CAS n\u00e3o baixa proporcionalmente). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. A Pir\u00e2mide de Alta Performance** explicado em sala, indique a afirmativa verdadeira: Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe *em qual camada* a vari\u00e1vel se hospeda: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo)** explicado em sala, indique a afirmativa verdadeira: Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-06/","title":"Quiz 06 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-06/#quiz-06-introducao","title":"Quiz 06 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. Cache Hit e Cache Miss** explicado em sala, indique a afirmativa verdadeira: O desempenho do seu loop `for()` depende maci\u00e7amente da *Cache Hit Rate*. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. Localidade Espacial vs Temporal** explicado em sala, indique a afirmativa verdadeira: As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada): \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. False Sharing e L\u00f3gica Invertida (A Morte do C++)** explicado em sala, indique a afirmativa verdadeira: A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **1. Cache Hit e Cache Miss** explicado em sala, indique a afirmativa verdadeira: O desempenho do seu loop `for()` depende maci\u00e7amente da *Cache Hit Rate*. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **2. Localidade Espacial vs Temporal** explicado em sala, indique a afirmativa verdadeira: As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada): \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **3. False Sharing e L\u00f3gica Invertida (A Morte do C++)** explicado em sala, indique a afirmativa verdadeira: A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **1. Cache Hit e Cache Miss** explicado em sala, indique a afirmativa verdadeira: O desempenho do seu loop `for()` depende maci\u00e7amente da *Cache Hit Rate*. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **2. Localidade Espacial vs Temporal** explicado em sala, indique a afirmativa verdadeira: As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada): \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **3. False Sharing e L\u00f3gica Invertida (A Morte do C++)** explicado em sala, indique a afirmativa verdadeira: A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **1. Cache Hit e Cache Miss** explicado em sala, indique a afirmativa verdadeira: O desempenho do seu loop `for()` depende maci\u00e7amente da *Cache Hit Rate*. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-07/","title":"Quiz 07 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-07/#quiz-07-introducao","title":"Quiz 07 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. A Pilha (Stack)** explicado em sala, indique a afirmativa verdadeira: A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (`int x`, `float y`). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. O Monte (Heap)** explicado em sala, indique a afirmativa verdadeira: Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o D... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. Memory Leaks (Vazamentos de Mem\u00f3ria)** explicado em sala, indique a afirmativa verdadeira: Um cl\u00e1ssico e letal bug de engenharia C++. Quando o desenvolvedor executa `new` ou `malloc` solicitando mem\u00f3ria do **Heap**, mas quebra regras do fluxo perdendo o contato formal do **ponteiro** retornado do hardware sem ... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Se n\u00e3o sabe onde colocar: Bote no STACK. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. A Pilha (Stack)** explicado em sala, indique a afirmativa verdadeira: A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (`int x`, `float y`). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. O Monte (Heap)** explicado em sala, indique a afirmativa verdadeira: Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o D... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. Memory Leaks (Vazamentos de Mem\u00f3ria)** explicado em sala, indique a afirmativa verdadeira: Um cl\u00e1ssico e letal bug de engenharia C++. Quando o desenvolvedor executa `new` ou `malloc` solicitando mem\u00f3ria do **Heap**, mas quebra regras do fluxo perdendo o contato formal do **ponteiro** retornado do hardware sem ... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Se n\u00e3o sabe onde colocar: Bote no STACK. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. A Pilha (Stack)** explicado em sala, indique a afirmativa verdadeira: A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (`int x`, `float y`). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. O Monte (Heap)** explicado em sala, indique a afirmativa verdadeira: Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o D... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-08/","title":"Quiz 08 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-08/#quiz-08-introducao","title":"Quiz 08 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual** explicado em sala, indique a afirmativa verdadeira: Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina** explicado em sala, indique a afirmativa verdadeira: Para driblar isso, a arquitetura moderna usa a **TLB (Translation Lookaside Buffer)**. A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso v... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. Driblando a Pagina\u00e7\u00e3o como Programador** explicado em sala, indique a afirmativa verdadeira: Ao iterarmos matrizes massivas (Matrizes 2D em C++) na ordem invertida ou em l\u00f3gicas dispersas `LinkedList-&gt;prox`, voc\u00ea n\u00e3o causa apenas *Cache Miss* da Aula 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes *TLB Misses*! V... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes *TLB Misses*! V... *feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.* \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - O ponteiro que o dev manipula com um `int *ptr = &amp;value` em qualquer IDE \u00e9 puramente 100% Virtual. \u00c9 o passaporte intermedi\u00e1rio. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual** explicado em sala, indique a afirmativa verdadeira: Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina** explicado em sala, indique a afirmativa verdadeira: Para driblar isso, a arquitetura moderna usa a **TLB (Translation Lookaside Buffer)**. A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso v... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. Driblando a Pagina\u00e7\u00e3o como Programador** explicado em sala, indique a afirmativa verdadeira: Ao iterarmos matrizes massivas (Matrizes 2D em C++) na ordem invertida ou em l\u00f3gicas dispersas `LinkedList-&gt;prox`, voc\u00ea n\u00e3o causa apenas *Cache Miss* da Aula 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes *TLB Misses*! V... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes *TLB Misses*! V... *feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.* \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - O ponteiro que o dev manipula com um `int *ptr = &amp;value` em qualquer IDE \u00e9 puramente 100% Virtual. \u00c9 o passaporte intermedi\u00e1rio. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual** explicado em sala, indique a afirmativa verdadeira: Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina** explicado em sala, indique a afirmativa verdadeira: Para driblar isso, a arquitetura moderna usa a **TLB (Translation Lookaside Buffer)**. A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso v... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-09/","title":"Quiz 09 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-09/#quiz-09-introducao","title":"Quiz 09 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. Processos (Isolamento Forte)** explicado em sala, indique a afirmativa verdadeira: O Processo \u00e9 o cont\u00eainer mestre do *Sistema Operacional*. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (`PID 2900`). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. Threads (Isolamento Fraco / Partilha)** explicado em sala, indique a afirmativa verdadeira: Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para **Multithreading**! \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. Context Switch (A Faca de Dois Gumes)** explicado em sala, indique a afirmativa verdadeira: Quando escrevemos `\"Hello World\"`, achamos que a CPU roda por horas sem interrup\u00e7\u00f5es. Engano. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Se a tarefa for CPU-Bound (requerer Matem\u00e1tica Bruta Massiva / Machine Learning), voc\u00ea cria Threads numerando-as pr\u00f3ximo n\u00famero oficial de n\u00facleos estritos da CPU, evitando desperd\u00edcio de overhead com *Context Switches... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. Processos (Isolamento Forte)** explicado em sala, indique a afirmativa verdadeira: O Processo \u00e9 o cont\u00eainer mestre do *Sistema Operacional*. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (`PID 2900`). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. Threads (Isolamento Fraco / Partilha)** explicado em sala, indique a afirmativa verdadeira: Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para **Multithreading**! \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. Context Switch (A Faca de Dois Gumes)** explicado em sala, indique a afirmativa verdadeira: Quando escrevemos `\"Hello World\"`, achamos que a CPU roda por horas sem interrup\u00e7\u00f5es. Engano. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Se a tarefa for CPU-Bound (requerer Matem\u00e1tica Bruta Massiva / Machine Learning), voc\u00ea cria Threads numerando-as pr\u00f3ximo n\u00famero oficial de n\u00facleos estritos da CPU, evitando desperd\u00edcio de overhead com *Context Switches... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. Processos (Isolamento Forte)** explicado em sala, indique a afirmativa verdadeira: O Processo \u00e9 o cont\u00eainer mestre do *Sistema Operacional*. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (`PID 2900`). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. Threads (Isolamento Fraco / Partilha)** explicado em sala, indique a afirmativa verdadeira: Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para **Multithreading**! \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-10/","title":"Quiz 10 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-10/#quiz-10-introducao","title":"Quiz 10 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel** explicado em sala, indique a afirmativa verdadeira: Imaginemos uma vari\u00e1vel primitiva `int balance = 100;`. Em Assembly C/C++, aumentar uma quantia em `balance += 10;` n\u00e3o \u00e9 \"Um \u00danico Movimento\". \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. Mutex e The Critical Section** explicado em sala, indique a afirmativa verdadeira: A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As **Locks (Travas)** como padr\u00e3o Ouro C++: `std::mutex` (Mutual Exclusion). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. O Dilema: Deadlock** explicado em sala, indique a afirmativa verdadeira: Mas e se o programador de *Backend C/C++* prender (usou lock() ou Mutex) em A esperando que B seja terminado.. mas B s\u00f3 termina porque B precisa pegar lock() em A que t\u00e1 bloqueado? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - **Mutex**: Usa o sistema do n\u00facleo para trancar \u00e1reas exclusivas do Hardware (RAM). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel** explicado em sala, indique a afirmativa verdadeira: Imaginemos uma vari\u00e1vel primitiva `int balance = 100;`. Em Assembly C/C++, aumentar uma quantia em `balance += 10;` n\u00e3o \u00e9 \"Um \u00danico Movimento\". \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. Mutex e The Critical Section** explicado em sala, indique a afirmativa verdadeira: A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As **Locks (Travas)** como padr\u00e3o Ouro C++: `std::mutex` (Mutual Exclusion). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. O Dilema: Deadlock** explicado em sala, indique a afirmativa verdadeira: Mas e se o programador de *Backend C/C++* prender (usou lock() ou Mutex) em A esperando que B seja terminado.. mas B s\u00f3 termina porque B precisa pegar lock() em A que t\u00e1 bloqueado? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - **Mutex**: Usa o sistema do n\u00facleo para trancar \u00e1reas exclusivas do Hardware (RAM). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel** explicado em sala, indique a afirmativa verdadeira: Imaginemos uma vari\u00e1vel primitiva `int balance = 100;`. Em Assembly C/C++, aumentar uma quantia em `balance += 10;` n\u00e3o \u00e9 \"Um \u00danico Movimento\". \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. Mutex e The Critical Section** explicado em sala, indique a afirmativa verdadeira: A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As **Locks (Travas)** como padr\u00e3o Ouro C++: `std::mutex` (Mutual Exclusion). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-11/","title":"Quiz 11 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-11/#quiz-11-introducao","title":"Quiz 11 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. Multi-Core (M\u00faltiplos N\u00facleos)** explicado em sala, indique a afirmativa verdadeira: Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. Hyper-Threading (SMT - Symmetrical Multi-Threading)** explicado em sala, indique a afirmativa verdadeira: A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux? *feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.* \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. GPUs: O Paralelismo Maci\u00e7o** explicado em sala, indique a afirmativa verdadeira: CPUs (Processadores) foram feitos para \"Serem R\u00e1pidos executando sequ\u00eancias l\u00f3gicas e IFs complexos\". Possuem Caches gigantes. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - **Task Paralelism**: Se tens l\u00f3gica variada, use a *CPU Multi-Core C++ thread pool*. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. Multi-Core (M\u00faltiplos N\u00facleos)** explicado em sala, indique a afirmativa verdadeira: Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. Hyper-Threading (SMT - Symmetrical Multi-Threading)** explicado em sala, indique a afirmativa verdadeira: A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux? *feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.* \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. GPUs: O Paralelismo Maci\u00e7o** explicado em sala, indique a afirmativa verdadeira: CPUs (Processadores) foram feitos para \"Serem R\u00e1pidos executando sequ\u00eancias l\u00f3gicas e IFs complexos\". Possuem Caches gigantes. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - **Task Paralelism**: Se tens l\u00f3gica variada, use a *CPU Multi-Core C++ thread pool*. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. Multi-Core (M\u00faltiplos N\u00facleos)** explicado em sala, indique a afirmativa verdadeira: Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. Hyper-Threading (SMT - Symmetrical Multi-Threading)** explicado em sala, indique a afirmativa verdadeira: A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux? \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux? *feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.* \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-12/","title":"Quiz 12 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-12/#quiz-12-introducao","title":"Quiz 12 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution)** explicado em sala, indique a afirmativa verdadeira: Voc\u00ea codifica: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. O Memory Model (Consist\u00eancias e Barreiras)** explicado em sala, indique a afirmativa verdadeira: O C++11 emitiu formalmente o seu universal **Memory Model** definindo atrav\u00e9s da biblioteca `std::atomic` o que o Hardware tem permi\u00e7\u00f5es para *Adiantar* vs *Trancar*. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. Memory Barriers (Fences) nas CPUs** explicado em sala, indique a afirmativa verdadeira: Se n\u00e3o tivessemos essa lei `std::atomic` no standard oficial do GCC, program\u00e1vamos via \"Gambiarra Intrinseca\" de Processador (Ex: Comando Assembler **MFENCE** ou **SFENCE** no Intel). Os Fences pro\u00edbem categoricamente a ... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Se duas \"Threads\" conversam atrav\u00e9s das mesmas vari\u00e1veis limpas de C e n\u00e3o possuam `std::mutex` da aula 10 as blindando, USE **`std::atomic`**. Do contr\u00e1rio voc\u00ea \u00e9 uma v\u00edtima da *Superscalar Out Of Order Intel Ar... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution)** explicado em sala, indique a afirmativa verdadeira: Voc\u00ea codifica: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. O Memory Model (Consist\u00eancias e Barreiras)** explicado em sala, indique a afirmativa verdadeira: O C++11 emitiu formalmente o seu universal **Memory Model** definindo atrav\u00e9s da biblioteca `std::atomic` o que o Hardware tem permi\u00e7\u00f5es para *Adiantar* vs *Trancar*. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. Memory Barriers (Fences) nas CPUs** explicado em sala, indique a afirmativa verdadeira: Se n\u00e3o tivessemos essa lei `std::atomic` no standard oficial do GCC, program\u00e1vamos via \"Gambiarra Intrinseca\" de Processador (Ex: Comando Assembler **MFENCE** ou **SFENCE** no Intel). Os Fences pro\u00edbem categoricamente a ... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Se duas \"Threads\" conversam atrav\u00e9s das mesmas vari\u00e1veis limpas de C e n\u00e3o possuam `std::mutex` da aula 10 as blindando, USE **`std::atomic`**. Do contr\u00e1rio voc\u00ea \u00e9 uma v\u00edtima da *Superscalar Out Of Order Intel Ar... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution)** explicado em sala, indique a afirmativa verdadeira: Voc\u00ea codifica: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. O Memory Model (Consist\u00eancias e Barreiras)** explicado em sala, indique a afirmativa verdadeira: O C++11 emitiu formalmente o seu universal **Memory Model** definindo atrav\u00e9s da biblioteca `std::atomic` o que o Hardware tem permi\u00e7\u00f5es para *Adiantar* vs *Trancar*. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-13/","title":"Quiz 13 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-13/#quiz-13-introducao","title":"Quiz 13 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. HDD (Hard Disk Drive) vs SSD (SATA)** explicado em sala, indique a afirmativa verdadeira: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. NVMe (O Limite PCIe)** explicado em sala, indique a afirmativa verdadeira: Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em ... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. IOPS - A M\u00e9trica Real do Servidor** explicado em sala, indique a afirmativa verdadeira: Se a banda (MB/s) diz o volume da mangueira, os **IOPS (Input/Output Operations Per Second)** dizem quantos golpes a mangueira d\u00e1 por segundo. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: O desenvolvedor C++ entende isso programando a I/O por grandes lotes (`Buffers`). N\u00e3o escreva no disco `1 byte` no la\u00e7o for por `1 milh\u00e3o de vezes` (Destrui\u00e7\u00e3o de IOPS). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. HDD (Hard Disk Drive) vs SSD (SATA)** explicado em sala, indique a afirmativa verdadeira: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. NVMe (O Limite PCIe)** explicado em sala, indique a afirmativa verdadeira: Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em ... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. IOPS - A M\u00e9trica Real do Servidor** explicado em sala, indique a afirmativa verdadeira: Se a banda (MB/s) diz o volume da mangueira, os **IOPS (Input/Output Operations Per Second)** dizem quantos golpes a mangueira d\u00e1 por segundo. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: O desenvolvedor C++ entende isso programando a I/O por grandes lotes (`Buffers`). N\u00e3o escreva no disco `1 byte` no la\u00e7o for por `1 milh\u00e3o de vezes` (Destrui\u00e7\u00e3o de IOPS). \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. HDD (Hard Disk Drive) vs SSD (SATA)** explicado em sala, indique a afirmativa verdadeira: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. NVMe (O Limite PCIe)** explicado em sala, indique a afirmativa verdadeira: Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em ... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-14/","title":"Quiz 14 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-14/#quiz-14-introducao","title":"Quiz 14 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. O V-Node / Inode** explicado em sala, indique a afirmativa verdadeira: Se no seu PC existe a pasta `Docs/foto.jpg`, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. Journaling (A Prova contra Quedas)** explicado em sala, indique a afirmativa verdadeira: Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido)** explicado em sala, indique a afirmativa verdadeira: \"Escrever no disco\" via SysCall C++ `write()` ou `fwrite()` raramente vai pro HD! \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Ao usar C/C++, chame o instr\u00ednseco `fsync()` se seu App for um Banco de Dados ou Software Cr\u00edtico Banc\u00e1rio for\u00e7ando a Cache RAM descarregar a for\u00e7a e salvar permanentemente no sil\u00edcio do disco. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. O V-Node / Inode** explicado em sala, indique a afirmativa verdadeira: Se no seu PC existe a pasta `Docs/foto.jpg`, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. Journaling (A Prova contra Quedas)** explicado em sala, indique a afirmativa verdadeira: Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido)** explicado em sala, indique a afirmativa verdadeira: \"Escrever no disco\" via SysCall C++ `write()` ou `fwrite()` raramente vai pro HD! \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Ao usar C/C++, chame o instr\u00ednseco `fsync()` se seu App for um Banco de Dados ou Software Cr\u00edtico Banc\u00e1rio for\u00e7ando a Cache RAM descarregar a for\u00e7a e salvar permanentemente no sil\u00edcio do disco. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. O V-Node / Inode** explicado em sala, indique a afirmativa verdadeira: Se no seu PC existe a pasta `Docs/foto.jpg`, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. Journaling (A Prova contra Quedas)** explicado em sala, indique a afirmativa verdadeira: Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-15/","title":"Quiz 15 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-15/#quiz-15-introducao","title":"Quiz 15 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. System Calls (O Ped\u00e1gio do Kernel)** explicado em sala, indique a afirmativa verdadeira: Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminan... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. Interrup\u00e7\u00f5es vs Polling** explicado em sala, indique a afirmativa verdadeira: Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\". \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. DMA (Mem\u00f3ria com Acesso Direto)** explicado em sala, indique a afirmativa verdadeira: Mesmo com as Interrup\u00e7\u00f5es ajudando a n\u00e3o ficar paralisado *Polling*... Fazer a Placa de Rede encher a placa RAM transitando Bit a Bit passando pelo miolo doloroso da CPU era impratic\u00e1vel em Gigabit Ethernets. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Se a sua aplica\u00e7\u00e3o Web Framework ass\u00edncrona (como NodeJS ou Nginx C++) trava muito com \"I/O\", isso significa que o Sistema delega opera\u00e7\u00f5es custosas pelo DMA ao Kernel, enquanto orquestra Event-Loops aguardando os fami... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **1. System Calls (O Ped\u00e1gio do Kernel)** explicado em sala, indique a afirmativa verdadeira: Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminan... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **2. Interrup\u00e7\u00f5es vs Polling** explicado em sala, indique a afirmativa verdadeira: Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\". \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **3. DMA (Mem\u00f3ria com Acesso Direto)** explicado em sala, indique a afirmativa verdadeira: Mesmo com as Interrup\u00e7\u00f5es ajudando a n\u00e3o ficar paralisado *Polling*... Fazer a Placa de Rede encher a placa RAM transitando Bit a Bit passando pelo miolo doloroso da CPU era impratic\u00e1vel em Gigabit Ethernets. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **Resumo Pr\u00e1tico** explicado em sala, indique a afirmativa verdadeira: - Se a sua aplica\u00e7\u00e3o Web Framework ass\u00edncrona (como NodeJS ou Nginx C++) trava muito com \"I/O\", isso significa que o Sistema delega opera\u00e7\u00f5es custosas pelo DMA ao Kernel, enquanto orquestra Event-Loops aguardando os fami... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **1. System Calls (O Ped\u00e1gio do Kernel)** explicado em sala, indique a afirmativa verdadeira: Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminan... \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **2. Interrup\u00e7\u00f5es vs Polling** explicado em sala, indique a afirmativa verdadeira: Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\". \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/quiz-16/","title":"Quiz 16 - Introdu\u00e7\u00e3o","text":""},{"location":"quizzes/quiz-16/#quiz-16-introducao","title":"Quiz 16 - Introdu\u00e7\u00e3o","text":"1. Sobre o funcionamento pr\u00e1tico de **1. Profiling Cl\u00e1ssico (A Vida Real)** explicado em sala, indique a afirmativa verdadeira: Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 2. No contexto anal\u00edtico de **2. O Grande Desafio (Mini-Projeto Pr\u00e1tico)** explicado em sala, indique a afirmativa verdadeira: O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 3. Ao avaliar a caracter\u00edstica inerente a **3. Conclus\u00e3o da Trilha** explicado em sala, indique a afirmativa verdadeira: Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 4. A respeito da arquitetura sist\u00eamica conectada a **1. Profiling Cl\u00e1ssico (A Vida Real)** explicado em sala, indique a afirmativa verdadeira: Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 5. No que tange diretamente a l\u00f3gica de **2. O Grande Desafio (Mini-Projeto Pr\u00e1tico)** explicado em sala, indique a afirmativa verdadeira: O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 6. Sobre o funcionamento pr\u00e1tico de **3. Conclus\u00e3o da Trilha** explicado em sala, indique a afirmativa verdadeira: Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 7. No contexto anal\u00edtico de **1. Profiling Cl\u00e1ssico (A Vida Real)** explicado em sala, indique a afirmativa verdadeira: Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 8. Ao avaliar a caracter\u00edstica inerente a **2. O Grande Desafio (Mini-Projeto Pr\u00e1tico)** explicado em sala, indique a afirmativa verdadeira: O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware: \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 9. A respeito da arquitetura sist\u00eamica conectada a **3. Conclus\u00e3o da Trilha** explicado em sala, indique a afirmativa verdadeira: Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o. 10. No que tange diretamente a l\u00f3gica de **1. Profiling Cl\u00e1ssico (A Vida Real)** explicado em sala, indique a afirmativa verdadeira: Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais. Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos. A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o."},{"location":"quizzes/src/quiz-01/","title":"Quiz 01 - Aula 01 - Como o Software Roda no Hardware","text":""},{"location":"quizzes/src/quiz-01/#quiz-01-aula-01-como-o-software-roda-no-hardware","title":"Quiz 01 - Aula 01 - Como o Software Roda no Hardware","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. O Abismo entre C\u00f3digo e Sil\u00edcio explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, Bin\u00e1rios (0 e 1). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. Compiladores vs Interpretadores explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. ISA: O Contrato do Processador explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Todo c\u00f3digo, por mais sofisticado que seja, precisa ser reduzido a estas poucas opera\u00e7\u00f5es ditadas pela ISA para rodar. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Ao usar C/C++, voc\u00ea n\u00e3o lida com um motor intermedi\u00e1rio te cobrindo (como a JVM), voc\u00ea escreve algoritmos cuja gest\u00e3o \u00e9 delegada ao S.O. e rodada pura em metal. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. O Abismo entre C\u00f3digo e Sil\u00edcio explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, Bin\u00e1rios (0 e 1). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. Compiladores vs Interpretadores explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. ISA: O Contrato do Processador explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Todo c\u00f3digo, por mais sofisticado que seja, precisa ser reduzido a estas poucas opera\u00e7\u00f5es ditadas pela ISA para rodar. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Ao usar C/C++, voc\u00ea n\u00e3o lida com um motor intermedi\u00e1rio te cobrindo (como a JVM), voc\u00ea escreve algoritmos cuja gest\u00e3o \u00e9 delegada ao S.O. e rodada pura em metal. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. O Abismo entre C\u00f3digo e Sil\u00edcio explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, Bin\u00e1rios (0 e 1). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. Compiladores vs Interpretadores explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-02/","title":"Quiz 02 - Aula 02 - Representa\u00e7\u00e3o de Dados","text":""},{"location":"quizzes/src/quiz-02/#quiz-02-aula-02-representacao-de-dados","title":"Quiz 02 - Aula 02 - Representa\u00e7\u00e3o de Dados","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. Sistema Bin\u00e1rio e Hexadecimal explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. Inteiros com e sem Sinal (Unsigned) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. Ponto Flutuante (IEEE 754) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Os famosos tipos <code>float</code> e <code>double</code>. O processador possui normalmente um setor dedicado de FPU (Floating Point Unit) para eles. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A maneira como voc\u00ea escolhe o tipo primitivo da vari\u00e1vel modela a fisionomia do registrador acionado na m\u00e1quina durante o fetch. Entender o Overflow \u00e9 a prote\u00e7\u00e3o b\u00e1sica contra corrup\u00e7\u00e3o l\u00f3gica do c\u00f3digo. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. Sistema Bin\u00e1rio e Hexadecimal explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. Inteiros com e sem Sinal (Unsigned) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. Ponto Flutuante (IEEE 754) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Os famosos tipos <code>float</code> e <code>double</code>. O processador possui normalmente um setor dedicado de FPU (Floating Point Unit) para eles. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A maneira como voc\u00ea escolhe o tipo primitivo da vari\u00e1vel modela a fisionomia do registrador acionado na m\u00e1quina durante o fetch. Entender o Overflow \u00e9 a prote\u00e7\u00e3o b\u00e1sica contra corrup\u00e7\u00e3o l\u00f3gica do c\u00f3digo. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. Sistema Bin\u00e1rio e Hexadecimal explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. Inteiros com e sem Sinal (Unsigned) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-03/","title":"Quiz 03 - Aula 03 - CPU: Estrutura e Funcionamento","text":""},{"location":"quizzes/src/quiz-03/#quiz-03-aula-03-cpu-estrutura-e-funcionamento","title":"Quiz 03 - Aula 03 - CPU: Estrutura e Funcionamento","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do Clock pelo ciclo cl\u00e1ssico: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Seu processador n\u00e3o faz essas 4 etapas de forma burra (uma por vez). Ele usa Pipelining: Enquanto a Instru\u00e7\u00e3o A est\u00e1 em Execute, a Instru\u00e7\u00e3o B j\u00e1 est\u00e1 em Decode e a Instru\u00e7\u00e3o C est\u00e1 em Fetch! feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Registradores s\u00e3o seus maiores amigos de performance. C\u00f3digos C++ que permitem ao compilador prender c\u00e1lculos pesados 100% dentro dos Registradores rodam em Nanossegundos, contra Milissegundos lendo sempre pela RAM. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do Clock pelo ciclo cl\u00e1ssico: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Seu processador n\u00e3o faz essas 4 etapas de forma burra (uma por vez). Ele usa Pipelining: Enquanto a Instru\u00e7\u00e3o A est\u00e1 em Execute, a Instru\u00e7\u00e3o B j\u00e1 est\u00e1 em Decode e a Instru\u00e7\u00e3o C est\u00e1 em Fetch! feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Registradores s\u00e3o seus maiores amigos de performance. C\u00f3digos C++ que permitem ao compilador prender c\u00e1lculos pesados 100% dentro dos Registradores rodam em Nanossegundos, contra Milissegundos lendo sempre pela RAM. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do Clock pelo ciclo cl\u00e1ssico: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-04/","title":"Quiz 04 - Aula 04 - Arquiteturas RISC vs CISC","text":""},{"location":"quizzes/src/quiz-04/#quiz-04-aula-04-arquiteturas-risc-vs-cisc","title":"Quiz 04 - Aula 04 - Arquiteturas RISC vs CISC","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. Entendendo a Batalha explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. Como isso afeta o Compilador C/C++? explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Historicamente, servidores eram puramente CISC (Intel). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. Entendendo a Batalha explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. Como isso afeta o Compilador C/C++? explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Historicamente, servidores eram puramente CISC (Intel). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 1. Entendendo a Batalha explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 2. Como isso afeta o Compilador C/C++? explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Historicamente, servidores eram puramente CISC (Intel). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. Entendendo a Batalha explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-05/","title":"Quiz 05 - Aula 05 - Hierarquia de Mem\u00f3ria","text":""},{"location":"quizzes/src/quiz-05/#quiz-05-aula-05-hierarquia-de-memoria","title":"Quiz 05 - Aula 05 - Hierarquia de Mem\u00f3ria","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. A Pir\u00e2mide de Alta Performance explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. Optimizando Uso explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Por que linguagens como C e C++ dominam infraestrutura de servidores High Frequency Trading? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Se processadores hoje s\u00e3o m\u00edsseis atingindo +4GHz, a RAM parou no tempo (Lat\u00eancia de CAS n\u00e3o baixa proporcionalmente). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. A Pir\u00e2mide de Alta Performance explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. Optimizando Uso explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Por que linguagens como C e C++ dominam infraestrutura de servidores High Frequency Trading? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Se processadores hoje s\u00e3o m\u00edsseis atingindo +4GHz, a RAM parou no tempo (Lat\u00eancia de CAS n\u00e3o baixa proporcionalmente). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. A Pir\u00e2mide de Alta Performance explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-06/","title":"Quiz 06 - Aula 06 - Cache e Localidade","text":""},{"location":"quizzes/src/quiz-06/#quiz-06-aula-06-cache-e-localidade","title":"Quiz 06 - Aula 06 - Cache e Localidade","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. Cache Hit e Cache Miss explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. Localidade Espacial vs Temporal explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada): feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. False Sharing e L\u00f3gica Invertida (A Morte do C++) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. Cache Hit e Cache Miss explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. Localidade Espacial vs Temporal explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada): feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 3. False Sharing e L\u00f3gica Invertida (A Morte do C++) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 1. Cache Hit e Cache Miss explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 2. Localidade Espacial vs Temporal explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada): feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 3. False Sharing e L\u00f3gica Invertida (A Morte do C++) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. Cache Hit e Cache Miss explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-07/","title":"Quiz 07 - Aula 07 - Stack vs Heap","text":""},{"location":"quizzes/src/quiz-07/#quiz-07-aula-07-stack-vs-heap","title":"Quiz 07 - Aula 07 - Stack vs Heap","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. A Pilha (Stack) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. O Monte (Heap) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o D... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. Memory Leaks (Vazamentos de Mem\u00f3ria) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Um cl\u00e1ssico e letal bug de engenharia C++. Quando o desenvolvedor executa <code>new</code> ou <code>malloc</code> solicitando mem\u00f3ria do Heap, mas quebra regras do fluxo perdendo o contato formal do ponteiro retornado do hardware sem ... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Se n\u00e3o sabe onde colocar: Bote no STACK. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. A Pilha (Stack) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. O Monte (Heap) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o D... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. Memory Leaks (Vazamentos de Mem\u00f3ria) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Um cl\u00e1ssico e letal bug de engenharia C++. Quando o desenvolvedor executa <code>new</code> ou <code>malloc</code> solicitando mem\u00f3ria do Heap, mas quebra regras do fluxo perdendo o contato formal do ponteiro retornado do hardware sem ... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Se n\u00e3o sabe onde colocar: Bote no STACK. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. A Pilha (Stack) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. O Monte (Heap) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o D... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-08/","title":"Quiz 08 - Aula 08 - Mem\u00f3ria Virtual","text":""},{"location":"quizzes/src/quiz-08/#quiz-08-aula-08-memoria-virtual","title":"Quiz 08 - Aula 08 - Mem\u00f3ria Virtual","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Para driblar isso, a arquitetura moderna usa a TLB (Translation Lookaside Buffer). A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso v... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. Driblando a Pagina\u00e7\u00e3o como Programador explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Ao iterarmos matrizes massivas (Matrizes 2D em C++) na ordem invertida ou em l\u00f3gicas dispersas <code>LinkedList-&gt;prox</code>, voc\u00ea n\u00e3o causa apenas Cache Miss da Aula 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes TLB Misses! V... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - O ponteiro que o dev manipula com um <code>int *ptr = &amp;value</code> em qualquer IDE \u00e9 puramente 100% Virtual. \u00c9 o passaporte intermedi\u00e1rio. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Para driblar isso, a arquitetura moderna usa a TLB (Translation Lookaside Buffer). A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso v... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. Driblando a Pagina\u00e7\u00e3o como Programador explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Ao iterarmos matrizes massivas (Matrizes 2D em C++) na ordem invertida ou em l\u00f3gicas dispersas <code>LinkedList-&gt;prox</code>, voc\u00ea n\u00e3o causa apenas Cache Miss da Aula 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes TLB Misses! V... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - O ponteiro que o dev manipula com um <code>int *ptr = &amp;value</code> em qualquer IDE \u00e9 puramente 100% Virtual. \u00c9 o passaporte intermedi\u00e1rio. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Para driblar isso, a arquitetura moderna usa a TLB (Translation Lookaside Buffer). A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso v... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-09/","title":"Quiz 09 - Aula 09 - Processos e Threads","text":""},{"location":"quizzes/src/quiz-09/#quiz-09-aula-09-processos-e-threads","title":"Quiz 09 - Aula 09 - Processos e Threads","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. Processos (Isolamento Forte) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. Threads (Isolamento Fraco / Partilha) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para Multithreading! feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. Context Switch (A Faca de Dois Gumes) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Quando escrevemos <code>\"Hello World\"</code>, achamos que a CPU roda por horas sem interrup\u00e7\u00f5es. Engano. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Se a tarefa for CPU-Bound (requerer Matem\u00e1tica Bruta Massiva / Machine Learning), voc\u00ea cria Threads numerando-as pr\u00f3ximo n\u00famero oficial de n\u00facleos estritos da CPU, evitando desperd\u00edcio de overhead com Context Switches... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.*</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. Processos (Isolamento Forte) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. Threads (Isolamento Fraco / Partilha) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para Multithreading! feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. Context Switch (A Faca de Dois Gumes) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Quando escrevemos <code>\"Hello World\"</code>, achamos que a CPU roda por horas sem interrup\u00e7\u00f5es. Engano. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Se a tarefa for CPU-Bound (requerer Matem\u00e1tica Bruta Massiva / Machine Learning), voc\u00ea cria Threads numerando-as pr\u00f3ximo n\u00famero oficial de n\u00facleos estritos da CPU, evitando desperd\u00edcio de overhead com Context Switches... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.*</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. Processos (Isolamento Forte) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. Threads (Isolamento Fraco / Partilha) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para Multithreading! feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-10/","title":"Quiz 10 - Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":""},{"location":"quizzes/src/quiz-10/#quiz-10-aula-10-sincronizacao-e-concorrencia","title":"Quiz 10 - Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\". feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. Mutex e The Critical Section explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As Locks (Travas) como padr\u00e3o Ouro C++: <code>std::mutex</code> (Mutual Exclusion). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. O Dilema: Deadlock explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Mas e se o programador de Backend C/C++ prender (usou lock() ou Mutex) em A esperando que B seja terminado.. mas B s\u00f3 termina porque B precisa pegar lock() em A que t\u00e1 bloqueado? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Mutex: Usa o sistema do n\u00facleo para trancar \u00e1reas exclusivas do Hardware (RAM). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\". feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. Mutex e The Critical Section explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As Locks (Travas) como padr\u00e3o Ouro C++: <code>std::mutex</code> (Mutual Exclusion). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. O Dilema: Deadlock explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Mas e se o programador de Backend C/C++ prender (usou lock() ou Mutex) em A esperando que B seja terminado.. mas B s\u00f3 termina porque B precisa pegar lock() em A que t\u00e1 bloqueado? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Mutex: Usa o sistema do n\u00facleo para trancar \u00e1reas exclusivas do Hardware (RAM). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\". feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. Mutex e The Critical Section explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As Locks (Travas) como padr\u00e3o Ouro C++: <code>std::mutex</code> (Mutual Exclusion). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-11/","title":"Quiz 11 - Aula 11 - Paralelismo no Hardware","text":""},{"location":"quizzes/src/quiz-11/#quiz-11-aula-11-paralelismo-no-hardware","title":"Quiz 11 - Aula 11 - Paralelismo no Hardware","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. Multi-Core (M\u00faltiplos N\u00facleos) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. Hyper-Threading (SMT - Symmetrical Multi-Threading) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. GPUs: O Paralelismo Maci\u00e7o explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] CPUs (Processadores) foram feitos para \"Serem R\u00e1pidos executando sequ\u00eancias l\u00f3gicas e IFs complexos\". Possuem Caches gigantes. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Task Paralelism: Se tens l\u00f3gica variada, use a CPU Multi-Core C++ thread pool. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. Multi-Core (M\u00faltiplos N\u00facleos) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. Hyper-Threading (SMT - Symmetrical Multi-Threading) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. GPUs: O Paralelismo Maci\u00e7o explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] CPUs (Processadores) foram feitos para \"Serem R\u00e1pidos executando sequ\u00eancias l\u00f3gicas e IFs complexos\". Possuem Caches gigantes. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Task Paralelism: Se tens l\u00f3gica variada, use a CPU Multi-Core C++ thread pool. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. Multi-Core (M\u00faltiplos N\u00facleos) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. Hyper-Threading (SMT - Symmetrical Multi-Threading) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux? feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-12/","title":"Quiz 12 - Aula 12 - O Modelo de Mem\u00f3ria","text":""},{"location":"quizzes/src/quiz-12/#quiz-12-aula-12-o-modelo-de-memoria","title":"Quiz 12 - Aula 12 - O Modelo de Mem\u00f3ria","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Voc\u00ea codifica: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. O Memory Model (Consist\u00eancias e Barreiras) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O C++11 emitiu formalmente o seu universal Memory Model definindo atrav\u00e9s da biblioteca <code>std::atomic</code> o que o Hardware tem permi\u00e7\u00f5es para Adiantar vs Trancar. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. Memory Barriers (Fences) nas CPUs explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Se n\u00e3o tivessemos essa lei <code>std::atomic</code> no standard oficial do GCC, program\u00e1vamos via \"Gambiarra Intrinseca\" de Processador (Ex: Comando Assembler MFENCE ou SFENCE no Intel). Os Fences pro\u00edbem categoricamente a ... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Se duas \"Threads\" conversam atrav\u00e9s das mesmas vari\u00e1veis limpas de C e n\u00e3o possuam <code>std::mutex</code> da aula 10 as blindando, USE <code>std::atomic&lt;bool&gt;</code>. Do contr\u00e1rio voc\u00ea \u00e9 uma v\u00edtima da Superscalar Out Of Order Intel Ar... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.*</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Voc\u00ea codifica: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. O Memory Model (Consist\u00eancias e Barreiras) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O C++11 emitiu formalmente o seu universal Memory Model definindo atrav\u00e9s da biblioteca <code>std::atomic</code> o que o Hardware tem permi\u00e7\u00f5es para Adiantar vs Trancar. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. Memory Barriers (Fences) nas CPUs explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Se n\u00e3o tivessemos essa lei <code>std::atomic</code> no standard oficial do GCC, program\u00e1vamos via \"Gambiarra Intrinseca\" de Processador (Ex: Comando Assembler MFENCE ou SFENCE no Intel). Os Fences pro\u00edbem categoricamente a ... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Se duas \"Threads\" conversam atrav\u00e9s das mesmas vari\u00e1veis limpas de C e n\u00e3o possuam <code>std::mutex</code> da aula 10 as blindando, USE <code>std::atomic&lt;bool&gt;</code>. Do contr\u00e1rio voc\u00ea \u00e9 uma v\u00edtima da Superscalar Out Of Order Intel Ar... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.*</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Voc\u00ea codifica: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. O Memory Model (Consist\u00eancias e Barreiras) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O C++11 emitiu formalmente o seu universal Memory Model definindo atrav\u00e9s da biblioteca <code>std::atomic</code> o que o Hardware tem permi\u00e7\u00f5es para Adiantar vs Trancar. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-13/","title":"Quiz 13 - Aula 13 - Dispositivos de Armazenamento","text":""},{"location":"quizzes/src/quiz-13/#quiz-13-aula-13-dispositivos-de-armazenamento","title":"Quiz 13 - Aula 13 - Dispositivos de Armazenamento","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. HDD (Hard Disk Drive) vs SSD (SATA) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x]  feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. NVMe (O Limite PCIe) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em ... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. IOPS - A M\u00e9trica Real do Servidor explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Se a banda (MB/s) diz o volume da mangueira, os IOPS (Input/Output Operations Per Second) dizem quantos golpes a mangueira d\u00e1 por segundo. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O desenvolvedor C++ entende isso programando a I/O por grandes lotes (<code>Buffers</code>). N\u00e3o escreva no disco <code>1 byte</code> no la\u00e7o for por <code>1 milh\u00e3o de vezes</code> (Destrui\u00e7\u00e3o de IOPS). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. HDD (Hard Disk Drive) vs SSD (SATA) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x]  feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. NVMe (O Limite PCIe) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em ... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. IOPS - A M\u00e9trica Real do Servidor explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Se a banda (MB/s) diz o volume da mangueira, os IOPS (Input/Output Operations Per Second) dizem quantos golpes a mangueira d\u00e1 por segundo. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O desenvolvedor C++ entende isso programando a I/O por grandes lotes (<code>Buffers</code>). N\u00e3o escreva no disco <code>1 byte</code> no la\u00e7o for por <code>1 milh\u00e3o de vezes</code> (Destrui\u00e7\u00e3o de IOPS). feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. HDD (Hard Disk Drive) vs SSD (SATA) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x]  feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. NVMe (O Limite PCIe) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em ... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-14/","title":"Quiz 14 - Aula 14 - Sistemas de Arquivos","text":""},{"location":"quizzes/src/quiz-14/#quiz-14-aula-14-sistemas-de-arquivos","title":"Quiz 14 - Aula 14 - Sistemas de Arquivos","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. O V-Node / Inode explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. Journaling (A Prova contra Quedas) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] \"Escrever no disco\" via SysCall C++ <code>write()</code> ou <code>fwrite()</code> raramente vai pro HD! feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Ao usar C/C++, chame o instr\u00ednseco <code>fsync()</code> se seu App for um Banco de Dados ou Software Cr\u00edtico Banc\u00e1rio for\u00e7ando a Cache RAM descarregar a for\u00e7a e salvar permanentemente no sil\u00edcio do disco. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. O V-Node / Inode explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. Journaling (A Prova contra Quedas) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] \"Escrever no disco\" via SysCall C++ <code>write()</code> ou <code>fwrite()</code> raramente vai pro HD! feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Ao usar C/C++, chame o instr\u00ednseco <code>fsync()</code> se seu App for um Banco de Dados ou Software Cr\u00edtico Banc\u00e1rio for\u00e7ando a Cache RAM descarregar a for\u00e7a e salvar permanentemente no sil\u00edcio do disco. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. O V-Node / Inode explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. Journaling (A Prova contra Quedas) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-15/","title":"Quiz 15 - Aula 15 - Entrada e Sa\u00edda (I/O)","text":""},{"location":"quizzes/src/quiz-15/#quiz-15-aula-15-entrada-e-saida-io","title":"Quiz 15 - Aula 15 - Entrada e Sa\u00edda (I/O)","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. System Calls (O Ped\u00e1gio do Kernel) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminan... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. Interrup\u00e7\u00f5es vs Polling explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\". feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. DMA (Mem\u00f3ria com Acesso Direto) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Mesmo com as Interrup\u00e7\u00f5es ajudando a n\u00e3o ficar paralisado Polling... Fazer a Placa de Rede encher a placa RAM transitando Bit a Bit passando pelo miolo doloroso da CPU era impratic\u00e1vel em Gigabit Ethernets. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Se a sua aplica\u00e7\u00e3o Web Framework ass\u00edncrona (como NodeJS ou Nginx C++) trava muito com \"I/O\", isso significa que o Sistema delega opera\u00e7\u00f5es custosas pelo DMA ao Kernel, enquanto orquestra Event-Loops aguardando os fami... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. System Calls (O Ped\u00e1gio do Kernel) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminan... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 2. Interrup\u00e7\u00f5es vs Polling explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\". feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 3. DMA (Mem\u00f3ria com Acesso Direto) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Mesmo com as Interrup\u00e7\u00f5es ajudando a n\u00e3o ficar paralisado Polling... Fazer a Placa de Rede encher a placa RAM transitando Bit a Bit passando pelo miolo doloroso da CPU era impratic\u00e1vel em Gigabit Ethernets. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a Resumo Pr\u00e1tico explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] - Se a sua aplica\u00e7\u00e3o Web Framework ass\u00edncrona (como NodeJS ou Nginx C++) trava muito com \"I/O\", isso significa que o Sistema delega opera\u00e7\u00f5es custosas pelo DMA ao Kernel, enquanto orquestra Event-Loops aguardando os fami... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. System Calls (O Ped\u00e1gio do Kernel) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminan... feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. Interrup\u00e7\u00f5es vs Polling explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\". feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"quizzes/src/quiz-16/","title":"Quiz 16 - Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":""},{"location":"quizzes/src/quiz-16/#quiz-16-aula-16-projeto-final-otimizacao-baseada-em-hardware","title":"Quiz 16 - Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":"<p>Bateria Sistem\u00e1tica (10 Quest\u00f5es)</p> <ol> <li> <p>Sobre o funcionamento pr\u00e1tico de 1. Profiling Cl\u00e1ssico (A Vida Real) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 3. Conclus\u00e3o da Trilha explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 1. Profiling Cl\u00e1ssico (A Vida Real) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Sobre o funcionamento pr\u00e1tico de 3. Conclus\u00e3o da Trilha explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No contexto anal\u00edtico de 1. Profiling Cl\u00e1ssico (A Vida Real) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>Ao avaliar a caracter\u00edstica inerente a 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware: feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>A respeito da arquitetura sist\u00eamica conectada a 3. Conclus\u00e3o da Trilha explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> <li> <p>No que tange diretamente a l\u00f3gica de 1. Profiling Cl\u00e1ssico (A Vida Real) explicado em sala, indique a afirmativa verdadeira:</p> <ul> <li>[x] Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. feedback: Afirmativo e Exato. Esta \u00e9 rigorosamente a premissa central abordada no conte\u00fado de sala.</li> <li>[ ] \u00c9 uma limita\u00e7\u00e3o exclusiva de linguagens interpretadas muito antigas, sem nenhuma rela\u00e7\u00e3o ao universo avan\u00e7ado do C/C++ moderno e CPUs atuais.</li> <li>[ ] Este paradigma foi totalmente descontinuado das arquiteturas vigentes porque o processador atua hoje com barramentos perfeitamente abstratos.</li> <li>[ ] A execu\u00e7\u00e3o desse sub-processo opera de maneira paralela puramente abstrata, eximindo o Kernel do SO de gerenciar filas de execu\u00e7\u00e3o.</li> </ul> </li> </ol>"},{"location":"setups/","title":"Configura\u00e7\u00e3o do Ambiente","text":""},{"location":"setups/#configuracao-do-ambiente","title":"Configura\u00e7\u00e3o do Ambiente","text":"<p>Bem-vindo \u00e0 se\u00e7\u00e3o de configura\u00e7\u00e3o! Prepare seu ambiente para acompanhar as aulas de Hardware para Programadores focando na linguagem C e C++.</p> <ul> <li> <p> Configura\u00e7\u00e3o no Windows</p> <ul> <li>Setup C/C++ (MSYS2)</li> <li>Download dos Compiladores GCC/G++ em ambiente MSYS2</li> <li>Instala\u00e7\u00e3o e Extens\u00f5es no Visual Studio Code (C/C++ e Code Runner)</li> </ul> </li> <li> <p> Configura\u00e7\u00e3o no Linux</p> <ul> <li>Setup C/C++ (build-essential)</li> <li>Configura\u00e7\u00f5es com Aptitude usando pacotes base <code>build-essential</code> e <code>gdb</code></li> <li>Adicionando de forma nativa no VS Code</li> </ul> </li> </ul>"},{"location":"setups/#proximos-passos","title":"\ud83d\udccb Pr\u00f3ximos Passos","text":"<p>Ap\u00f3s configurar seu ambiente:</p> <ol> <li>\u2705 Comprove o Compilador: Teste a sa\u00edda de comando do <code>g++ --version</code> ou <code>gcc --version</code>.</li> <li>\ud83d\udcda Instale as extens\u00f5es obrigat\u00f3rias: Adicione as bibliotecas do C/C++ da Microsoft em sua IDE conforme listado nos setups.</li> <li>\ud83d\ude80 Comece a aventura: Mergulhe na Aula 01</li> </ol>"},{"location":"setups/setup-01/","title":"Configura\u00e7\u00e3o do Ambiente (Windows)","text":""},{"location":"setups/setup-01/#configuracao-do-ambiente-windows","title":"Configura\u00e7\u00e3o do Ambiente (Windows)","text":"<p>Para desenvolver as aplica\u00e7\u00f5es de arquitetura de software e baixo n\u00edvel requeridas neste curso, precisaremos instalar ferramentas que convertam o c\u00f3digo <code>C/C++</code> que digitaremos em bin\u00e1rios que o hardware possa executar nativamente.</p>"},{"location":"setups/setup-01/#1-o-compilador-msys2-mingw-w64","title":"1. O Compilador (MSYS2 / MinGW-w64)","text":"<p>No Windows, a maneira mais segura, moderna e madura de instalar o compilador <code>GCC/G++</code> nativo (utilizado historicamente em sistemas Unix) \u00e9 baixar o ambiente do MSYS2.</p>"},{"location":"setups/setup-01/#passo-a-passo-de-instalacao","title":"Passo a Passo de Instala\u00e7\u00e3o:","text":"<ol> <li>Acesse msys2.org.</li> <li>Baixe o instalador mais recente (<code>msys2-x86_64-xxxxxxxx.exe</code>).</li> <li>Instale no caminho padr\u00e3o (<code>C:\\msys64</code>).</li> <li>Ao final da instala\u00e7\u00e3o, deixe a caixa \"Run MSYS2 now\" marcada e clique em Finish. O console do terminal do MSYS2 ir\u00e1 abrir.</li> </ol>"},{"location":"setups/setup-01/#baixando-os-pacotes-de-compilacao","title":"Baixando os Pacotes de Compila\u00e7\u00e3o","text":"<p>Dentro do terminal preto do MSYS2 que abriu, digite o seguinte comando e aperte <code>ENTER</code>:</p> <pre><code>pacman -S mingw-w64-ucrt-x86_64-gcc\n</code></pre> <p>O sistema perguntar\u00e1 se voc\u00ea quer baixar (<code>Proceed with installation? [Y/n]</code>). Digite <code>Y</code> e aperte <code>ENTER</code>. O pacote GCC e G++ (C e C++) da biblioteca UCRT (Universal C Runtime) come\u00e7ar\u00e1 a ser baixado no seu computador.</p> <p>Quando finalizar, instale tamb\u00e9m o GDB (Depurador nativo) com o comando:</p> <pre><code>pacman -S mingw-w64-ucrt-x86_64-gdb\n</code></pre>"},{"location":"setups/setup-01/#configurando-o-path-do-windows","title":"Configurando o PATH do Windows","text":"<p>Para que o seu Windows e o VS Code consigam achar os compiladores (<code>gcc</code>, <code>g++</code>, <code>gdb</code>), voc\u00ea precisa colocar o diret\u00f3rio de instala\u00e7\u00e3o deles na vari\u00e1vel <code>PATH</code>.</p> <ol> <li>No menu iniciar do Windows, procure por Editar vari\u00e1veis de ambiente do sistema.</li> <li>Na janela que abrir (\"Propriedades do Sistema\"), clique no bot\u00e3o Vari\u00e1veis de Ambiente....</li> <li>Na se\u00e7\u00e3o \"Vari\u00e1veis do sistema\" (a de baixo), procure a vari\u00e1vel Path, selecione-a e clique em Editar....</li> <li>Clique em Novo e cole o seguinte caminho:    <code>C:\\msys64\\ucrt64\\bin</code></li> <li>Pressione OK em todas as janelas para salvar e sair.</li> </ol> <p>Teste R\u00e1pido: Abra o Prompt de Comando do Windows (cmd) e digite <code>g++ --version</code>. Se aparecer um texto da Free Software Foundation, parab\u00e9ns! Seu compilador est\u00e1 vivo.</p>"},{"location":"setups/setup-01/#2-o-editor-de-codigo-visual-studio-code","title":"2. O Editor de C\u00f3digo (Visual Studio Code)","text":"<p>O Visual Studio Code \u00e9 um super \"bloco de notas\" voltado a desenvolvedores. Vai ser a nossa ferramenta oficial.</p>"},{"location":"setups/setup-01/#instalacao","title":"Instala\u00e7\u00e3o","text":"<ol> <li>Acesse code.visualstudio.com.</li> <li>Baixe a vers\u00e3o para Windows.</li> <li>Execute o instalador (sugerimos marcar as caixas de adicionar a\u00e7\u00f5es de contexto ao mouse \"Abrir com o VS Code\" caso n\u00e3o estejam marcadas).</li> </ol>"},{"location":"setups/setup-01/#extensoes-recomendadas-obrigatorias","title":"Extens\u00f5es Recomendadas (Obrigat\u00f3rias)","text":"<p>Abra o VS Code, clique no \u00edcone de \"Extensions\" (quatro quadradinhos, sendo um solto) na barra lateral esquerda e procure os seguintes nomes:</p> <ol> <li>C/C++ (fabricante oficial: Microsoft): Traz sintaxe, autocompletar do c\u00f3digo base e o depurador IntelliSense.</li> <li>Code Runner (fabricante oficial: Jun Han): Essa extens\u00e3o mostrar\u00e1 um bot\u00e3o de \"Play\" (\u25b6\ufe0f) no canto direito de cima no seu VS Code, permitindo voc\u00ea clicar nele e automaticamente compilar/rodar seus c\u00f3digos em C/C++ sem precisar escrever comandos gigantescos via terminal de comando.</li> </ol> <p>\ud83c\udf89 Pronto! O seu Windows agora tem a alma de um ecossistema Unix nativo e est\u00e1 pronto para criar execut\u00e1veis velozes!</p>"},{"location":"setups/setup-02/","title":"Configura\u00e7\u00e3o do Ambiente (Linux)","text":""},{"location":"setups/setup-02/#configuracao-do-ambiente-linux","title":"Configura\u00e7\u00e3o do Ambiente (Linux)","text":"<p>Desenvolver em sistemas Linux \u00e9 incrivelmente favor\u00e1vel se tratando de C/C++, visto que muito de sua arquitetura nativa \u00e9 criada fundamentalmente em cima das mesmas bibliotecas padr\u00e3o de C que usaremos no curso.</p>"},{"location":"setups/setup-02/#1-instalando-compiladores-globais","title":"1. Instalando Compiladores Globais","text":"<p>Enquanto no Windows precisamos de runners emulando diret\u00f3rios Unix, no Linux tudo geralmente \u00e9 simples usando o utilit\u00e1rio nativo de instala\u00e7\u00e3o.</p> <p>Abra o seu terminal (no Ubuntu, pop_OS!, Linux Mint ou outros baseados no sistema Debian) e atualize as fontes do seu sistema:</p> <pre><code>sudo apt update\n</code></pre> <p>Logo ap\u00f3s, fa\u00e7a a requisi\u00e7\u00e3o dos pacotes-marco de desenvolvimento nativo do sistema e comissione-os para o disco global da m\u00e1quina:</p> <pre><code>sudo apt install build-essential gdb\n</code></pre> <p>\u2139\ufe0f  O pacote meta chamado <code>build-essential</code> j\u00e1 cont\u00eam o <code>gcc</code> (para compilarmos a linguagem C), o <code>g++</code> (para compilar a linguagem C++ orientada a objetos) e o <code>make</code>. O <code>gdb</code> anexado acima \u00e9 a ferramenta respons\u00e1vel pelo debbuging (an\u00e1lise linha a linha de falhas de mem\u00f3ria) destas linguagens.</p> <p>Teste R\u00e1pido: No pr\u00f3prio terminal digite <code>g++ --version</code>. Se aparecer um texto da Free Software Foundation, sucesso!</p>"},{"location":"setups/setup-02/#2-o-editor-de-codigo-visual-studio-code","title":"2. O Editor de C\u00f3digo (Visual Studio Code)","text":"<p>O uso de IDEs gigantescas como Clion s\u00e3o \u00f3timas, mas o VS Code permanece sendo leve e excelente para as simula\u00e7\u00f5es pragm\u00e1ticas da cadeira.</p> <ol> <li>Baixe o pacote correspondente \u00e0 sua arquitetura: <code>.deb</code> (Debian/Ubuntu) ou <code>.rpm</code> (Fedora) no site oficial code.visualstudio.com.</li> <li>Instale usando o empacotador local. Exemplo via diret\u00f3rio de Downloads: <code>sudo dpkg -i ~/Downloads/code_*.deb</code>.</li> </ol> <p>Ou de forma veloz caso possua o ecossistema Snap embutido com permiss\u00e3o cl\u00e1ssica ativa: </p><pre><code>sudo snap install code --classic\n</code></pre><p></p>"},{"location":"setups/setup-02/#extensoes-recomendadas-obrigatorias","title":"Extens\u00f5es Recomendadas (Obrigat\u00f3rias)","text":"<p>Abra o seu VS Code rec\u00e9m instalado, procure pelo \u00edcone de Extensions e pesquise:</p> <ol> <li>C/C++ (fabricante oficial: Microsoft): Traz sintaxe, autocompletar do c\u00f3digo base (<code>IntelliSense</code>).</li> <li>Code Runner (fabricante oficial: Jun Han): Instala um \u00edcone de \"Play\" (\u25b6\ufe0f) no seu VS Code, permitindo voc\u00ea simplesmente apertar \"Compilar e Rodar\" sobre seu arquivo atual (<code>.cpp</code> ou <code>.c</code>), eliminando a necessidade de escrever <code>$ gcc app.c -o app</code> frequentemente nas implementa\u00e7\u00f5es cotidianas deste curso.</li> </ol> <p>\ud83c\udf89 Pronto! O seu sistema Unix agora \u00e9 oficialmente imbat\u00edvel como emulador nativo para esta disciplina.</p>"},{"location":"slides/","title":"Slides Interativos","text":""},{"location":"slides/#slides-interativos","title":"Slides Interativos","text":"<p>Nesta se\u00e7\u00e3o voc\u00ea acessa os slides completos de cada uma das 16 aulas do Curso. As apresenta\u00e7\u00f5es foram desenhadas com visual otimizado Reveal.js.</p> <p>Para utilizar as transi\u00e7\u00f5es (como as setas do teclado) em tela-cheia, pressione a tecla <code>F</code>.</p>"},{"location":"slides/#modulo-1-fundamentos-de-arquitetura-de-computadores","title":"M\u00f3dulo 1 \u2013 Fundamentos de Arquitetura de Computadores","text":"<ul> <li> Aula 01 - Como o Software Roda no Hardware</li> <li> Aula 02 - Representa\u00e7\u00e3o de Dados</li> <li> Aula 03 - CPU: Estrutura e Funcionamento</li> <li> Aula 04 - Arquiteturas RISC vs CISC</li> </ul>"},{"location":"slides/#modulo-2-memoria-e-performance","title":"M\u00f3dulo 2 \u2013 Mem\u00f3ria e Performance","text":"<ul> <li> Aula 05 - Hierarquia de Mem\u00f3ria</li> <li> Aula 06 - Cache e Localidade</li> <li> Aula 07 - Stack vs Heap</li> <li> Aula 08 - Mem\u00f3ria Virtual</li> </ul>"},{"location":"slides/#modulo-3-concorrencia-e-paralelismo","title":"M\u00f3dulo 3 \u2013 Concorr\u00eancia e Paralelismo","text":"<ul> <li> Aula 09 - Processos e Threads</li> <li> Aula 10 - Sincroniza\u00e7\u00e3o e Concorr\u00eancia</li> <li> Aula 11 - Paralelismo no Hardware</li> <li> Aula 12 - O Modelo de Mem\u00f3ria</li> </ul>"},{"location":"slides/#modulo-4-armazenamento-io-e-pratica","title":"M\u00f3dulo 4 \u2013 Armazenamento, I/O e Pr\u00e1tica","text":"<ul> <li> Aula 13 - Dispositivos de Armazenamento</li> <li> Aula 14 - Sistemas de Arquivos</li> <li> Aula 15 - Entrada e Sa\u00edda (I/O)</li> <li> Aula 16 - Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware</li> </ul>"},{"location":"slides/slide-01/","title":"Slide 01","text":""},{"location":"slides/slide-01/#como-o-software-roda-no-hardware","title":"Como o Software Roda no Hardware","text":""},{"location":"slides/slide-01/#aula-01","title":"Aula 01","text":""},{"location":"slides/slide-01/#1-o-abismo-entre-codigo-e-silicio","title":"\ud83c\udfd7\ufe0f 1. O Abismo entre C\u00f3digo e Sil\u00edcio","text":"<p>Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, Bin\u00e1rios (0 e 1).</p> <p>Como a sua frase <code>printf(\"Hello World\");</code> chega aos pinos do processador? Atrav\u00e9s de uma cadeia de ferramentas (Toolchain).</p>"},{"location":"slides/slide-01/#o-processo-de-compilacao-cc","title":"O Processo de Compila\u00e7\u00e3o (C/C++)","text":"<p>Linguagens compiladas de baixo n\u00edvel seguem um caminho determin\u00edstico. Veja o diagrama abaixo de como um arquivo <code>.c</code> \u00e9 fatiado:</p>"},{"location":"slides/slide-01/#2-compiladores-vs-interpretadores","title":"\ud83d\udee0\ufe0f 2. Compiladores vs Interpretadores","text":"<p>A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance:</p> <pre><code>O c\u00f3digo \u00e9 100% transformado em bin\u00e1rio *antes* de executar (AOT - Ahead of Time).\n**Pr\u00f3**: Alta velocidade de execu\u00e7\u00e3o. Hardware direto.\n**Contra**: O execut\u00e1vel constru\u00eddo em Linux-x86 n\u00e3o roda nativamente em Windows-ARM sem ser recompilado.\n\n\nUm programa (Interpretador) l\u00ea o seu c\u00f3digo fonte em tempo de execu\u00e7\u00e3o e executa as a\u00e7\u00f5es simulando o comando subjacente para o S.O.\n**Pr\u00f3**: Roda em qualquer SO que tiver o interpretador.\n**Contra**: Muito mais lento, por sofrer *overhead* da interpreta\u00e7\u00e3o.\n\n\nCompilam para um formato intermedi\u00e1rio (*Bytecode*), e a JVM ou CLR as compila JIT (Just-In-Time) na m\u00e1quina cliente no instante de executar.\n</code></pre>"},{"location":"slides/slide-01/#3-isa-o-contrato-do-processador","title":"\ud83d\udcd0 3. ISA: O Contrato do Processador","text":"<p>ISA (Instruction Set Architecture) \u00e9 o dicion\u00e1rio de um processador. \u00c9 o conjunto de comandos num\u00e9ricos que o CPU sabe, fisicamente, executar:</p> <ul> <li>Puxar da Mem\u00f3ria (LOAD)</li> <li>Somar (ADD)</li> <li>Gravar na Mem\u00f3ria (STORE)</li> </ul> <p>Todo c\u00f3digo, por mais sofisticado que seja, precisa ser reduzido a estas poucas opera\u00e7\u00f5es ditadas pela ISA para rodar.</p>"},{"location":"slides/slide-01/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Ao usar C/C++, voc\u00ea n\u00e3o lida com um motor intermedi\u00e1rio te cobrindo (como a JVM), voc\u00ea escreve algoritmos cuja gest\u00e3o \u00e9 delegada ao S.O. e rodada pura em metal.</li> <li>O programador backend / performance critica deve inspecionar eventuais outputs em Assembly para verificar se a abordagem da linguagem otimiza tempo de registrador.</li> </ul> <p>Pronto para entender profundamente os dados no M\u00f3dulo Bin\u00e1rio?</p>"},{"location":"slides/slide-02/","title":"Slide 02","text":""},{"location":"slides/slide-02/#representacao-de-dados","title":"Representa\u00e7\u00e3o de Dados","text":""},{"location":"slides/slide-02/#aula-02","title":"Aula 02","text":""},{"location":"slides/slide-02/#1-sistema-binario-e-hexadecimal","title":"\ud83d\udd22 1. Sistema Bin\u00e1rio e Hexadecimal","text":"<p>O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal).</p> <ul> <li>Bit:   0 ou 1</li> <li>Byte:   8 bits (<code>00000000</code> a <code>11111111</code>, indo de 0 a 255 no decimal)</li> </ul> <p>Por que <code>Hexadecimal</code> \u00e9 amado pelos desenvolvedores C/C++? Um Byte (8 bits) pode ser perfeitamente representado por exatos dois caracteres Hexadecimais. <code>FF</code> \u00e9 o mesmo que <code>11111111</code>.</p>"},{"location":"slides/slide-02/#2-inteiros-com-e-sem-sinal-unsigned","title":"\ud83d\udd0b 2. Inteiros com e sem Sinal (Unsigned)","text":"<p>Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware:</p> <pre><code>int x = 255;           // Geralmente um int \u00e9 32 bits, comportando valores grandes, podendo ser negativo (signed).\nunsigned char y = 255; // 8 bits sem sinal (0 a 255)\nsigned char z = -1;    // 8 bits com sinal (-128 a 127)\n</code></pre> <p>No hardware, inteiros negativos s\u00e3o representados usando a regra de Complemento de 2. Para obtermos o bin\u00e1rio do <code>-1</code>, invertemos todos os bits de <code>1</code> e somamos <code>1</code>.</p> <p>[!WARNING] Sempre avalie Overshoot. Um loop usando <code>unsigned int i = 10; while(i &gt;= 0)</code> ser\u00e1 um loop infinito, porque quando <code>i</code> atingir 0 e for subtra\u00eddo, ele NUNCA ficar\u00e1 negativo; ele executar\u00e1 o \"Wrap-around\" arquitetural, voltando ao valor limite de (<code>4.294.967.295</code>).</p>"},{"location":"slides/slide-02/#3-ponto-flutuante-ieee-754","title":"\ud83e\uddee 3. Ponto Flutuante (IEEE 754)","text":"<p>Os famosos tipos <code>float</code> e <code>double</code>. O processador possui normalmente um setor dedicado de FPU (Floating Point Unit) para eles.</p> <p>A representa\u00e7\u00e3o oficial IEEE 754 os divide em 3 por\u00e7\u00f5es:</p> <pre><code>flowchart LR\n    A[Sinal (1 bit)] --- B[Expoente (8 bits)] --- C[Fra\u00e7\u00e3o/Mantissa (23 bits)]\n    style A fill:#ff9999\n    style B fill:#99ccff\n    style C fill:#ccffcc</code></pre>"},{"location":"slides/slide-02/#o-perigo-da-precisao","title":"O Perigo da Precis\u00e3o!","text":""},{"location":"slides/slide-02/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<p>A maneira como voc\u00ea escolhe o tipo primitivo da vari\u00e1vel modela a fisionomia do registrador acionado na m\u00e1quina durante o fetch. Entender o Overflow \u00e9 a prote\u00e7\u00e3o b\u00e1sica contra corrup\u00e7\u00e3o l\u00f3gica do c\u00f3digo.</p>"},{"location":"slides/slide-03/","title":"Slide 03","text":""},{"location":"slides/slide-03/#cpu-estrutura-e-funcionamento","title":"CPU: Estrutura e Funcionamento","text":""},{"location":"slides/slide-03/#aula-03","title":"Aula 03","text":""},{"location":"slides/slide-03/#1-o-triangulo-de-ouro-alu-cu-e-registradores","title":"\ud83c\udfd7\ufe0f 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores","text":"<p>A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais:</p> <ol> <li>ALU (Unidade L\u00f3gica e Aritm\u00e9tica): O m\u00fasculo. Onde as somas, subtra\u00e7\u00f5es e portas l\u00f3gicas (AND/OR/XOR) acontecem fisicamente usando transistores.</li> <li>CU (Unidade de Controle): O supervisor. Ela diz \u00e0 ALU o que fazer lendo os \"Opcodes\" (comandos bin\u00e1rios ISA).</li> <li>Registradores: Pequenos e ultra-r\u00e1pidos blocos de mem\u00f3ria embutidos diretamente no chip. (ex: EAX, EBX, RSP).</li> </ol> <pre><code>$ # Como voc\u00ea l\u00ea valores do processador direto em C?\n$ cat register.c\nint main() {\n    register int i = 10; // \"Dica\" para o compilador usar um registrador direto!\n    return i;\n}\n</code></pre>"},{"location":"slides/slide-03/#2-o-ciclo-de-instrucao-fetch-decode-execute","title":"\ud83d\udd04 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute)","text":"<p>Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do Clock pelo ciclo cl\u00e1ssico:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Fetch\n    Fetch --&gt; Decode\n    Decode --&gt; Execute\n    Execute --&gt; Store\n    Store --&gt; Fetch</code></pre> <ol> <li>Fetch (Busca): A CU vai na Mem\u00f3ria RAM e busca qual o pr\u00f3ximo byte de comando, guiando-se pelo Program Counter (PC).</li> <li>Decode (Decodifica): A CU traduz o comando para entender o que \u00e9 (\"Ah, \u00e9 para Somar 5!\").</li> <li>Execute: A ALU recebe os par\u00e2metros e faz a conta f\u00edsica el\u00e9tron a el\u00e9tron.</li> <li>Store (Armazena): O resultado volta para um registrador ou para a Mem\u00f3ria RAM.</li> </ol>"},{"location":"slides/slide-03/#3-pipeline-e-previsao-de-desvio-branch-prediction","title":"\u26a1 3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction)","text":"<p>Seu processador n\u00e3o faz essas 4 etapas de forma burra (uma por vez). Ele usa Pipelining: Enquanto a Instru\u00e7\u00e3o A est\u00e1 em Execute, a Instru\u00e7\u00e3o B j\u00e1 est\u00e1 em Decode e a Instru\u00e7\u00e3o C est\u00e1 em Fetch!</p>"},{"location":"slides/slide-03/#o-perigo-do-if","title":"O perigo do \"IF\"","text":"<p>Quando voc\u00ea usa muitos <code>if()</code>, o processador tenta \"Adivinhar\" o lado do if usando heur\u00edsticas para n\u00e3o frear o Pipeline (Isso \u00e9 o Branch Prediction).</p> <p>[!WARNING] Errar a adivinha\u00e7\u00e3o do <code>if</code> corrompe todo o Pipeline que foi pr\u00e9-carregado. Em c\u00f3digo de alta performance C++, tentamos escrever loops minimizando saltos condicionais imprevistos.</p>"},{"location":"slides/slide-03/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<p>Registradores s\u00e3o seus maiores amigos de performance. C\u00f3digos C++ que permitem ao compilador prender c\u00e1lculos pesados 100% dentro dos Registradores rodam em Nanossegundos, contra Milissegundos lendo sempre pela RAM.</p>"},{"location":"slides/slide-04/","title":"Slide 04","text":""},{"location":"slides/slide-04/#arquiteturas-risc-vs-cisc","title":"Arquiteturas RISC vs CISC","text":""},{"location":"slides/slide-04/#aula-04","title":"Aula 04","text":""},{"location":"slides/slide-04/#1-entendendo-a-batalha","title":"\ud83e\udd4a 1. Entendendo a Batalha","text":"<p>A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas?</p> <pre><code>**Fios de Cabelo**: Possui instru\u00e7\u00f5es complexas que podem realizar tarefas gigantescas de uma vez (ex: \"Leia da mem\u00f3ria X, mude o bit Y, grave em Z\" em apenas UMA instru\u00e7\u00e3o assembly).\n**Reis do peda\u00e7o**: Processadores Intel e AMD (x86_64).\n**Caracter\u00edsticas**: Hardware muito complexo, consome mais energia para decodificar instru\u00e7\u00f5es multiformes.\n\n\n**L\u00e2mina Fina**: Possui pouqu\u00edssimas instru\u00e7\u00f5es, todas r\u00e1pidas, simples e uniformes. Fazer \"Leia da mem\u00f3ria X, mude o bit Y, grave em Z\" leva 3 a 4 comandos curtos no assembly.\n**Reis do peda\u00e7o**: Arquitetura ARM (Snapdragon, Apple Silicon M1-M3, AWS Graviton).\n**Caracter\u00edsticas**: Consome pouca bateria e se destaca muito em *Pipelines* agressivos.\n</code></pre>"},{"location":"slides/slide-04/#2-como-isso-afeta-o-compilador-cc","title":"\ud83d\udda8\ufe0f 2. Como isso afeta o Compilador C/C++?","text":"<p>Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas:</p> <pre><code>$ # Compilando para a m\u00e1quina local (digamos, x86_64 CISC)\n$ gcc app.c -o app\n$ # Compilando Cruzado (Cross-Compiling) de um PC x86 para rodar num Raspberry Pi (ARMv8):\n$ aarch64-linux-gnu-gcc app.c -o app_arm\n</code></pre>"},{"location":"slides/slide-04/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Historicamente, servidores eram puramente CISC (Intel).</li> <li>Hoje, o mercado clama por RISC gra\u00e7as \u00e0 sustentabilidade t\u00e9rmica (menos energia e calor).</li> <li>Um bom engenheiro percebe que a ISA (aula anterior) CISC vai conter milhares de comandos Assembly, requerendo compiladores muito agressivos, enquanto a ISA RISC exigir\u00e1 compiladores muito detalhistas e otimizados linearmente na aloca\u00e7\u00e3o de registradores C/C++.</li> </ul> <p>Caminho livre at\u00e9 aqui? Ent\u00e3o agora vamos adentrar nas dores da \"Mem\u00f3ria\".</p>"},{"location":"slides/slide-05/","title":"Slide 05","text":""},{"location":"slides/slide-05/#hierarquia-de-memoria","title":"Hierarquia de Mem\u00f3ria","text":""},{"location":"slides/slide-05/#aula-05","title":"Aula 05","text":""},{"location":"slides/slide-05/#1-a-piramide-de-alta-performance","title":"\ud83c\udfdb\ufe0f 1. A Pir\u00e2mide de Alta Performance","text":"<p>Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda:</p> <pre><code>graph TD\n    A(\"Registradores&lt;br/&gt;(1 Ciclo - Alguns Bytes)\") --&gt; B[Cache L1&lt;br/&gt;(~4 Ciclos - ~64KB a 128KB)]\n    B --&gt; C[Cache L2 e L3&lt;br/&gt;(~12 a ~40 Ciclos - Megabytes)]\n    C --&gt; D[[RAM (Mem\u00f3ria Principal)&lt;br/&gt;(~200 a ~300 Ciclos - Gigabytes)]]\n    D --&gt; E[(\"Armazenamento (SSD / HDD)&lt;br/&gt;(Milh\u00f5es de Ciclos - Terabytes)\")]\n\n    style A fill:#ff9999\n    style B fill:#ffcc99\n    style C fill:#ffff99\n    style D fill:#ccffcc\n    style E fill:#99ccff</code></pre> <p>[!IMPORTANT] A lat\u00eancia \u00e9 o tempo que demora da CPU pedir um dado at\u00e9 ele chegar. Buscar um byte da RAM demora ~200 ciclos. Buscar do SSD demora centenas de milhares. Essa diferen\u00e7a grotesca \u00e9 mitigada pelo uso de Caches.</p>"},{"location":"slides/slide-05/#2-os-impactos-da-latencia-lado-do-codigo","title":"\u23f3 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo)","text":"<p>Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty.</p> <pre><code>$ # Como consultar as camadas do processador Linux\n$ lscpu | grep Cache\nL1d cache:                       64 KiB\nL1i cache:                       64 KiB\nL2 cache:                        1 MiB\nL3 cache:                        12 MiB\n</code></pre>"},{"location":"slides/slide-05/#3-optimizando-uso","title":"\ud83c\udfaf 3. Optimizando Uso","text":"<p>Por que linguagens como C e C++ dominam infraestrutura de servidores High Frequency Trading? Porque elas permitem <code>Aloca\u00e7\u00e3o Est\u00e1tica e Constante</code> que \u00e9 perfeitamente \"encaixada\" pelo compilador diretamente na mem\u00f3ria Cache.</p> <p>Ao inv\u00e9s de carregar gigabytes de Strings na lenta RAM, as linguagens de baixo n\u00edvel incentivam o uso de matrizes de tamanho delimitado (arrays fixos), cujo agrupamento cont\u00edguo for\u00e7a a arquitetura de Hardware Prefetching a adiantar os bytes do Array para a Cache nativamente, antes mesmo de voc\u00ea rodar a linha do c\u00f3digo!</p>"},{"location":"slides/slide-05/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se processadores hoje s\u00e3o m\u00edsseis atingindo +4GHz, a RAM parou no tempo (Lat\u00eancia de CAS n\u00e3o baixa proporcionalmente).</li> <li>Tudo recai na t\u00e9cnica humana de amarrar dados juntos (Caches L1 e L2) e escrever data-oriented code se quiser ultra-lat\u00eancia C++.</li> </ul>"},{"location":"slides/slide-06/","title":"Slide 06","text":""},{"location":"slides/slide-06/#cache-e-localidade","title":"Cache e Localidade","text":""},{"location":"slides/slide-06/#aula-06","title":"Aula 06","text":""},{"location":"slides/slide-06/#1-cache-hit-e-cache-miss","title":"\u2705 1. Cache Hit e Cache Miss","text":"<p>O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate.</p> <ul> <li>Cache Hit: Acerto! A CPU pediu a posi\u00e7\u00e3o <code>[1]</code>, ela j\u00e1 estava na Cache e a conta foi resolvida quase imediatamente.</li> <li>Cache Miss: Erro! O processador precisou parar o Pipeline, ir at\u00e9 a RAM lenta, injetar o bloco de bytes na lenta escalada D-Cache/L3/L2/L1 e prosseguir.</li> </ul> <pre><code>sequenceDiagram\n    participant P as Programador\n    participant C as Cache L1\n    participant R as RAM\n\n    P-&gt;&gt;C: Quero array[0]!\n    Note right of C: \"Cache Hit\" (Sucesso imediato)\n\n    P-&gt;&gt;C: Quero NodeLink-&gt;prox!\n    Note right of C: N\u00e3o est\u00e1 aqui...\n    C-&gt;&gt;R: Buscar Posi\u00e7\u00e3o Lenta na RAM...\n    R--&gt;&gt;C: Traz o bloco de 64bytes inteiro\n    Note right of C: \"Cache Miss\" (Atraso)</code></pre>"},{"location":"slides/slide-06/#2-localidade-espacial-vs-temporal","title":"\ud83d\uddfa\ufe0f 2. Localidade Espacial vs Temporal","text":"<p>As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada):</p> <pre><code>Se o programa acessou a vari\u00e1vel na posi\u00e7\u00e3o de mem\u00f3ria `X`, h\u00e1 extrema probabilidade de que no ciclo de CPU seguinte ele acesse a vari\u00e1vel de mem\u00f3ria `X + 1`.\n*O cl\u00e1ssico caso dos **Arrays Continuos (std::vector)**, garantindo varredura limpa em Hit sequencial absoluto de 64 em 64 bytes.*\n\n\nSe o programa visitou a vari\u00e1vel `Y` agora, h\u00e1 enorme probabilidade dele visit\u00e1-la nos pr\u00f3ximos ms.\n*O cl\u00e1ssico caso das **Vari\u00e1veis Locais e Contadores Padr\u00f5es (`int i = 0`)** retidos brutalmente no Registrador ou na L1.*\n</code></pre>"},{"location":"slides/slide-06/#3-false-sharing-e-logica-invertida-a-morte-do-c","title":"\ud83e\udde8 3. False Sharing e L\u00f3gica Invertida (A Morte do C++)","text":"<p>[!WARNING] O vil\u00e3o m\u00e1ximo da performance: Iterar sobre matrizes pela Coluna ao inv\u00e9s da Linha. A imagem matriz na RAM C/C++ (Row-major order) exige saltos. E False Sharing ocorre quando threads isoladas atualizam vari\u00e1veis cont\u00edguas da mesma linha de Cache de 64 bytes, for\u00e7ando o Hardware (Cache Coherence Protocol) a invalidar repetitivas vezes L1/L2, triturando toda m\u00e9trica.</p> <p>A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo.</p>"},{"location":"slides/slide-07/","title":"Slide 07","text":""},{"location":"slides/slide-07/#stack-vs-heap","title":"Stack vs Heap","text":""},{"location":"slides/slide-07/#aula-07","title":"Aula 07","text":""},{"location":"slides/slide-07/#1-a-pilha-stack","title":"\ud83e\uddf1 1. A Pilha (Stack)","text":"<p>A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out). </p> <ul> <li>Performance Imediata:   N\u00e3o sofre do atraso monumental do Sistema Operacional rodando scripts para achar buracos vazios. A CPU avan\u00e7a 1 pino de hardware no SP (Stack Pointer) e empilha na RAM. Retirou, ele decrementa. Super r\u00e1pido.</li> <li>Anti-Vazamento Autom\u00e1tico:   Fun\u00e7\u00f5es extintas s\u00e3o imediatamente retiradas (popped) num clique at\u00f4mico LIFO e as fatias voltam a uso global. Mem\u00f3ria protegida contra vazamentos l\u00f3gicos (memory leaks) por defini\u00e7\u00e3o estrita.</li> <li>Quente da CPU:   Frequentemente preza por Cache Hit. A Stack costuma viver majoritariamente no limiar da L1 Data Cache.</li> </ul> <p>[!CAUTION] Stack Overflow! A Pilha nunca \u00e9 infinita, sendo tipicamente restrita pelo S.O. Windows/Linux (geralmente entre 1MB a 8MB max num Kernel Padr\u00e3o X86). Tentar criar um <code>int array[9999999]</code> puro no escopo sem aloca\u00e7\u00e3o din\u00e2mica explodir\u00e1 a Pilha e esmagar\u00e1 cruelmente (o temido <code>Segmentation Fault (core dumped)</code>).</p>"},{"location":"slides/slide-07/#2-o-monte-heap","title":"\ud83d\udce6 2. O Monte (Heap)","text":"<p>Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o Din\u00e2mica).</p> <pre><code>$ # Como voc\u00ea interage em baixo n\u00edvel (C/C++)\n$ cat code.c\n#include &lt;stdlib.h&gt;\n\nint main() {\n    // malloc vai no Sistema Operacional e chora pedindo: \"Me d\u00ea 10 inteiros!\"\n    int* array_gigante_dinamico = (int*)malloc(10 * sizeof(int));\n\n    // Se voc\u00ea n\u00e3o limpar usando free(), a RAM apodrecer\u00e1 lentamente (LEAK)\n    free(array_gigante_dinamico);\n}\n</code></pre>"},{"location":"slides/slide-07/#3-memory-leaks-vazamentos-de-memoria","title":"\ud83d\udc80 3. Memory Leaks (Vazamentos de Mem\u00f3ria)","text":"<p>Um cl\u00e1ssico e letal bug de engenharia C++. Quando o desenvolvedor executa <code>new</code> ou <code>malloc</code> solicitando mem\u00f3ria do Heap, mas quebra regras do fluxo perdendo o contato formal do ponteiro retornado do hardware sem antes ter reportado o fim via <code>delete</code> ou <code>free</code>. Resultado?  Aquela fatia na RAM f\u00edsica do servidor Linux ficar\u00e1 congelada, cega, retida unicamente pro seu app at\u00e9 que a nuvem AWS exaure toda a m\u00e1quina do container num erro de Kernel <code>OOM Killer (Out Of Memory)</code>.</p> <p>Em contra-partida: Dangling Pointers. Usar a \u00e1rea que o ponteiro apontava depois da liberta\u00e7\u00e3o formal do free provoca instabilidade instant\u00e2nea e corrup\u00e7\u00e3o silenciosa nos endere\u00e7os da placa-m\u00e3e.</p>"},{"location":"slides/slide-07/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se n\u00e3o sabe onde colocar: Bote no STACK.</li> <li>\u00c9 muito grande pra caber (Strings longas ou Arrays): Invoque HEAP com o <code>std::vector</code> (ele gerencia o malloc e free na destrui\u00e7\u00e3o de escopo).</li> </ul>"},{"location":"slides/slide-08/","title":"Slide 08","text":""},{"location":"slides/slide-08/#memoria-virtual","title":"Mem\u00f3ria Virtual","text":""},{"location":"slides/slide-08/#aula-08","title":"Aula 08","text":""},{"location":"slides/slide-08/#1-o-abismo-logico-a-memoria-virtual","title":"\ud83d\udd73\ufe0f 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual","text":"<p>Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center.</p> <p>Todo processo que o Linux constr\u00f3i roda dentro de uma gigante Ilus\u00e3o. O endere\u00e7o do seu ponteiro <code>0x7ffeeB...</code> em C++ \u00e9 falso (Endere\u00e7o L\u00f3gico).</p> <p>O HW (Hardware MMU no processador) mais as planilhas do Sistema Operacional (Page Tables) formencem a liga\u00e7\u00e3o din\u00e2mica e escondida pra sua aplica\u00e7\u00e3o.</p> <pre><code>graph LR\n    A[Ponteiro em C++&lt;br/&gt;(Virtual 0x01)] --&gt; B{\"MMU e&lt;br/&gt;Page Table\"}\n    B --&gt; C(\"Mem\u00f3ria RAM&lt;br/&gt;(F\u00edsica Pente 1)\")\n    B -. \"Se n\u00e3o houver espa\u00e7o\" .-&gt; D(\"Swap / Pagefile&lt;br/&gt;(SSD)\")</code></pre>"},{"location":"slides/slide-08/#2-tlb-mmu-e-a-traducao-da-pagina","title":"\ud83d\udcc4 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina","text":"<p>Cada tradu\u00e7\u00e3o do falso ponteiro visual com base nas tabelas em RAM \u00e9 custoso (Cycle Penalty).</p> <p>Para driblar isso, a arquitetura moderna usa a TLB (Translation Lookaside Buffer). A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso vira bloco 344 do pente de DDR5 real\".</p> <pre><code>- **Page Hit:** A tradu\u00e7\u00e3o ocorreu instat\u00e2neamente pela cache veloz na CPU (a TLB validou o ponteiro do C++ localizando logo onde est\u00e1 no metal a vari\u00e1vel no chip Kingston).\n- **Page Fault Limitrofico:** A TLB errou e teve que rolar pra Main RAM puxando o endere\u00e7o mapeado localizando num novo cluster na pilha. (100+ ciclos)\n- **Page Fault Cr\u00edtico (SWAP):** A m\u00e1quina n\u00e3o acha e entra em Swapping com o SSD (SSD Swap). \u00c9 ali que ocorre as quedas colossais para \"Travamento de Janela\", a CPU foi pro SSD buscar um arquivo gigante que o Linux ejetou l\u00e1, pra trazer e rebotar pra cima pra Mem\u00f3ria RAM f\u00edsica real, jogando pro seu c\u00f3digo que achava estar \"na mem\u00f3ria\" e dormiu (Milh\u00f5es de ciclos).\n</code></pre>"},{"location":"slides/slide-08/#3-driblando-a-paginacao-como-programador","title":"\ud83d\udcaa 3. Driblando a Pagina\u00e7\u00e3o como Programador","text":"<p>Ao iterarmos matrizes massivas (Matrizes 2D em C++) na ordem invertida ou em l\u00f3gicas dispersas <code>LinkedList-&gt;prox</code>, voc\u00ea n\u00e3o causa apenas Cache Miss da Aula 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes TLB Misses! Voc\u00ea induzir\u00e1 Page Faults insanos que derrubar\u00e3o o throughput (taxa de transfer\u00eancia de dados) em N fatores.</p> <p>Portanto: Localidade Espacial \u00e9 sagrada em Dados C/C++.</p>"},{"location":"slides/slide-08/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>O ponteiro que o dev manipula com um <code>int *ptr = &amp;value</code> em qualquer IDE \u00e9 puramente 100% Virtual. \u00c9 o passaporte intermedi\u00e1rio.</li> <li>Nunca dependa da pagina\u00e7\u00e3o e arquivo local de Swap do Disco: os mil\u00e9simos de segundo viram minutos na Nuvem se o app \"estourar a cota da cloud\", sofrendo <code>Thrashing</code> com o Disco local para falsificar a RAM que ele acreditou ter num loop mal codificado ou em Leaks do M\u00f3dulo/Aula anterior.</li> </ul>"},{"location":"slides/slide-09/","title":"Slide 09","text":""},{"location":"slides/slide-09/#processos-e-threads","title":"Processos e Threads","text":""},{"location":"slides/slide-09/#aula-09","title":"Aula 09","text":""},{"location":"slides/slide-09/#1-processos-isolamento-forte","title":"\ud83c\udfc3 1. Processos (Isolamento Forte)","text":"<p>O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>).</p> <ul> <li>O S.O. d\u00e1 ao Processo sua pr\u00f3pria e exclusiva Mem\u00f3ria Virtual (visto na Aula 8).</li> <li>O Processo tem sua exclusiva Pilha e n\u00e3o se mistura nunca. E isso isola falhas: se um Chrome (processo isolado) trava, n\u00e3o d\u00e1 tela azul na outra aba.</li> <li>A comunica\u00e7\u00e3o entre Processos (IPC - Inter-process Communication) \u00e9 pesada e necessita do S.O. atrav\u00e9s de Pipes ou Redes. </li> </ul>"},{"location":"slides/slide-09/#2-threads-isolamento-fraco-partilha","title":"\ud83e\uddf5 2. Threads (Isolamento Fraco / Partilha)","text":"<p>Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para Multithreading!</p> <pre><code>graph TD\n    A(\"Processo (ID: 5599) - Backend Web\") --&gt; B[(\"Heap Memory (Compartilhado)\")]\n    A --&gt; C[Thread 01 (Rota A)]\n    A --&gt; D[Thread 02 (Rota B)]\n    A --&gt; E[Thread 03 (Pool C)]\n\n    C --&gt; F((Stack Exclusiva T1))\n    D --&gt; G((Stack Exclusiva T2))\n    E --&gt; H((Stack Exclusiva T3))\n\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E</code></pre> <p>Uma Thread \u00e9 simplesmente uma subdivis\u00e3o leve controlada do processo. Elas todas orbitam e vivem na exata MESMA MEM\u00d3RIA VIRTUAL (Heap) DO PROCESSO MESTRE.</p> <pre><code>Duas `std::thread` manipulando os ponteiros apontam rigorosamente r\u00e1pido ao mesmo endere\u00e7o na RAM sem nenhuma barreira do S.O., o que traz milisegundos imbat\u00edveis versus IPC!\n</code></pre>"},{"location":"slides/slide-09/#3-context-switch-a-faca-de-dois-gumes","title":"\u2699\ufe0f 3. Context Switch (A Faca de Dois Gumes)","text":"<p>Quando escrevemos <code>\"Hello World\"</code>, achamos que a CPU roda por horas sem interrup\u00e7\u00f5es. Engano.</p> <p>O S.O. possui um n\u00facleo (Kernel Scheduler) que fatia mil\u00e9simos de mil\u00e9simos de segundos distribuindo uma core <code>i7-P</code> para a aba do Google, logo retira o Google e taca nos frames do VS-Code, em micro-loop alternante de Context Switches. O problema? Puxar e devolver o estado (registradores, program counter) na cache \u00e9 hiper custoso e derruba o Pipeline se abusado (overhead em CPU bound apps).</p>"},{"location":"slides/slide-09/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se a tarefa for CPU-Bound (requerer Matem\u00e1tica Bruta Massiva / Machine Learning), voc\u00ea cria Threads numerando-as pr\u00f3ximo n\u00famero oficial de n\u00facleos estritos da CPU, evitando desperd\u00edcio de overhead com Context Switches ilus\u00f3rios.</li> <li>\u00c9 muito f\u00e1cil em C/C++ estragar a vida financeira do cliente numa Race Condition compartilhada pelo Heap se n\u00e3o protegida... mas isso \u00e9 o tema da pr\u00f3xima aula!</li> </ul>"},{"location":"slides/slide-10/","title":"Slide 10","text":""},{"location":"slides/slide-10/#sincronizacao-e-concorrencia","title":"Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":""},{"location":"slides/slide-10/#aula-10","title":"Aula 10","text":""},{"location":"slides/slide-10/#1-o-data-race-uma-colisao-inevitavel","title":"\ud83c\udfce\ufe0f 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel","text":"<p>Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\". O HW (Processador) traduz internamente num RMW: Read (Puxa os 100 da RAM para o Registrador EAX), Modify (Adiciona +10 e vira 110 na ALU), e Write (Substitui na RAM os antigos 100 por 110).</p> <p>Se na fresta entre a Thread 1 preencher o EAX e depois descer ao RAM o valor 110... a Thread 2 rodar e \"puxar os mesm\u00edssimos originais 100\" para outro registrador (Context Switch), quando abas enviarem pra RAM final as sobreposi\u00e7\u00f5es as contas, um dos <code>10</code> desvanecer\u00e1, o banco perde e a vari\u00e1vel fica logicamente corrompida.</p>"},{"location":"slides/slide-10/#2-mutex-e-the-critical-section","title":"\ud83d\udee1\ufe0f 2. Mutex e The Critical Section","text":"<p>A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As Locks (Travas) como padr\u00e3o Ouro C++: <code>std::mutex</code> (Mutual Exclusion).</p> <pre><code>$ # Em C++, protege-se a vari\u00e1vel central assim:\n$ cat bank.cpp\nstd::mutex portaCorredor;\n\nvoid adiciona_10() {\n    portaCorredor.lock();   // O Hardware garante atomicamente exclus\u00e3o\n    balance += 10;          // Apenas UM transita aqui adentro. \n    portaCorredor.unlock(); // O primeiro sai da sala, e notifica o Kernel\n}\n</code></pre>"},{"location":"slides/slide-10/#3-o-dilema-deadlock","title":"\ud83d\udea6 3. O Dilema: Deadlock","text":"<p>Mas e se o programador de Backend C/C++ prender (usou lock() ou Mutex) em A esperando que B seja terminado.. mas B s\u00f3 termina porque B precisa pegar lock() em A que t\u00e1 bloqueado?</p> <p>Ambos processos morrem na tela, dormindo inertes (Blocked State), enquanto a barra de % CPU despenca lentamente para ZERO! Seu Sistema Paralelo entrou em Deadlock. (O Abra\u00e7o Mortal Padr\u00e3o The Dining Philosophers). Um design multi-thread exige uma heuristica sagrada de adquirir as trancas Lock C++ em id\u00eantica e constante ordem arquitetural atrav\u00e9s dos sistemas, ou apelar a mec\u00e2nicas <code>std::lock()</code> que aplicam garantias subjacentes do Kernel.</p>"},{"location":"slides/slide-10/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Mutex:   Usa o sistema do n\u00facleo para trancar \u00e1reas exclusivas do Hardware (RAM).</li> <li>Se a concorr\u00eancia n\u00e3o tiver \"Se\u00e7\u00e3o Cr\u00edtica\" que lida com Grava\u00e7\u00e3o e tiver \"S\u00f3 Read-only\", n\u00e3o aplique trancas (Mutex) para n\u00e3o serializar as Threads da m\u00e1quina.</li> </ul>"},{"location":"slides/slide-11/","title":"Slide 11","text":""},{"location":"slides/slide-11/#paralelismo-no-hardware","title":"Paralelismo no Hardware","text":""},{"location":"slides/slide-11/#aula-11","title":"Aula 11","text":""},{"location":"slides/slide-11/#1-multi-core-multiplos-nucleos","title":"\ud83c\udfd7\ufe0f 1. Multi-Core (M\u00faltiplos N\u00facleos)","text":"<p>Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip).</p> <ul> <li>Core F\u00edsico: \u00c9 uma CPU completa e independente, com sua pr\u00f3pria ALU, Unidade de Controle e Caches L1/L2 particulares.</li> <li>Cache L3 Compartilhado: Na maioria dos designs AMD e Intel reais, os M\u00faltiplos Cores (Ex: 8 Cores) conversam e trocam estados atrav\u00e9s de uma suntuosa e lenta \u00e1rea comum L3 que circunda todos os processadores ali impressos no wafer.</li> </ul> <p>[!TIP] Em Backend pesado: Se o banco mapear duas Threads puras <code>backend</code> em dois Cores puramente isolados (Ex: Core 0 e Core 1), e elas lerem/trabalharem na mesma matriz cont\u00ednua, o Hardware for\u00e7ar\u00e1 interc\u00e2mbios el\u00e9tricos no Cache Coherence Protocol (MESI) rodando por toda placa m\u00e3e. Fiquem espertos com o False Sharing! </p>"},{"location":"slides/slide-11/#2-hyper-threading-smt-symmetrical-multi-threading","title":"\ud83e\uddec 2. Hyper-Threading (SMT - Symmetrical Multi-Threading)","text":"<p>A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux?</p> <p>Na aula 03, vimos que a execu\u00e7\u00e3o cruza pelo Pipeline ou pode esbarrar em ciclos ociosos na CU aguardando a Mem\u00f3ria Principal. O Hyper-Threading espeta um Segundo conjunto de Registradores e Hardware de Estado no mesmo Core. Enquanto o c\u00f3digo da Thread \"A\" est\u00e1 0.5 nanosegundo travada esperando chegar o dado lento da L3, o Core troca instantaneamente para o contexto da Thread \"B\", executando-o usando as mesmas Unidades L\u00f3gicas (ALU) num aproveitamento fabril monstruoso de 100%.</p> <pre><code>$ # Lendo o processador em Linux (Ex: i7 4-Core com HyperThreading)\n$ lscpu\nCPU(s):                  8\nOn-line CPU(s) list:     0-7\nThread(s) per core:      2\nCore(s) per socket:      4\n</code></pre>"},{"location":"slides/slide-11/#3-gpus-o-paralelismo-macico","title":"\ud83c\udfae 3. GPUs: O Paralelismo Maci\u00e7o","text":"<p>CPUs (Processadores) foram feitos para \"Serem R\u00e1pidos executando sequ\u00eancias l\u00f3gicas e IFs complexos\". Possuem Caches gigantes. GPUs (Placas de V\u00eddeo) foram feitas para \"Executar a MESM\u00cdSSIMA MIN\u00daSCULA matem\u00e1tica simultaneamente em milhares de pixels fracos\". Sem grandes condicionais, focando no Throughput. </p> <p>NVIDIA e CUDA (plataforma de C++) reinam supremas em Deep Learning e Criptografia exatamente porque pegam Loops For gigantescos de \u00c1lgebra Linear, e fracionam em 8.000 mini-n\u00facleos (CUDA cores) esmagando qualquer Intel Core i9 na lat\u00eancia matem\u00e1tica cont\u00ednua pura.</p>"},{"location":"slides/slide-11/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Task Paralelism:   Se tens l\u00f3gica variada, use a CPU Multi-Core C++ thread pool.</li> <li>Data Paralelism:   Se a conta for a repeti\u00e7\u00e3o retumbante de um algoritmo id\u00eantico sobre 2 milh\u00f5es de dados sem depend\u00eancia de saltos complexos, mova-a da RAM \u00e0 VRAM da GPU via CUDA/OpenCL. A m\u00e9trica vai das horas paras os d\u00e9cimos de segundo.</li> </ul>"},{"location":"slides/slide-12/","title":"Slide 12","text":""},{"location":"slides/slide-12/#o-modelo-de-memoria","title":"O Modelo de Mem\u00f3ria","text":""},{"location":"slides/slide-12/#aula-12","title":"Aula 12","text":""},{"location":"slides/slide-12/#1-a-reordenacao-do-compilador-e-cpu-out-of-order-execution","title":"\ud83d\udd00 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution)","text":"<p>Voc\u00ea codifica: </p><pre><code>int x = 0;\nint FLAG = false;\n\n// Em uma Thread Secund\u00e1ria\nx = 42;         // PASSO A\nFLAG = true;    // PASSO B\n</code></pre><p></p> <p>Um programador esperan\u00e7oso diz: \"Vou ler a v\u00e1riavel na Thread Oposta (Main)... e quando <code>FLAG</code> for true, sei que <code>X</code> \u00e9 impreterivelmente 42 pois executei a linha acima primeiro na tela!\"</p> <p>FALSO! MORTALMENTE FALSO!</p>"},{"location":"slides/slide-12/#2-o-memory-model-consistencias-e-barreiras","title":"\ud83d\udea7 2. O Memory Model (Consist\u00eancias e Barreiras)","text":"<p>O C++11 emitiu formalmente o seu universal Memory Model definindo atrav\u00e9s da biblioteca <code>std::atomic</code> o que o Hardware tem permi\u00e7\u00f5es para Adiantar vs Trancar.</p> <ol> <li>Relaxed Consistensy (<code>std::memory_order_relaxed</code>): A CPU \u00e9 dona, reordene como quiser em torno da sua vizinhan\u00e7a na RAM, apenas aplique na thread isolada em seguran\u00e7a. Performance brutal.</li> <li>Release / Acquire (<code>std::memory_order_acquire / release</code>): O padr\u00e3o para transferir fardos (como ler a Fila sem locks e sem medo da Out-Of-Order embaralhar flags finalizadoras de Loop C++ no hardware alheio do *Core 2).</li> <li>Sequential Consistency (<code>std::memory_order_seq_cst</code>): O C++ por default invoca barreiras completas absolutas el\u00e9tricas. For\u00e7a todas as cores (L1/L2) da CPU e do compilador a n\u00e3o alterarem NADA a ordem que seu texto determinou. Seguro, mas castrador de velocidade em processadores ARM.</li> </ol>"},{"location":"slides/slide-12/#3-memory-barriers-fences-nas-cpus","title":"\ud83e\uddf1 3. Memory Barriers (Fences) nas CPUs","text":"<p>Se n\u00e3o tivessemos essa lei <code>std::atomic</code> no standard oficial do GCC, program\u00e1vamos via \"Gambiarra Intrinseca\" de Processador (Ex: Comando Assembler MFENCE ou SFENCE no Intel). Os Fences pro\u00edbem categoricamente a travessia de saltos das sub-opera\u00e7\u00f5es em Assembly, estancando a execu\u00e7\u00e3o como um sinaleiro fechado.</p> <p>[!INFO] \u00c9 por isso que programar Software Infra-estrutural de Baixo N\u00edvel (Databases, Motores de Redes Socket, SO Kernel Driver) \u00e9 extremamente dif\u00edcil: As reordena\u00e7\u00f5es da CPU nunca acontecem quando voc\u00ea depura linha a linha na IDE (pois a paralela n\u00e3o \u00e9 instigada). Elas s\u00f3 geram corrup\u00e7\u00f5es bizarras rand\u00f4micas 1x na vida e morrem meses na escura neblina de servidores reais operando 100 mil Requests por Minuto no DataCenter. Onde a press\u00e3o el\u00e1stica exaure as Caches e exp\u00f5e seus Bugs de Memory Models relaxados.</p>"},{"location":"slides/slide-12/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se duas \"Threads\" conversam atrav\u00e9s das mesmas vari\u00e1veis limpas de C e n\u00e3o possuam <code>std::mutex</code> da aula 10 as blindando, USE <code>std::atomic&lt;bool&gt;</code>. Do contr\u00e1rio voc\u00ea \u00e9 uma v\u00edtima da Superscalar Out Of Order Intel Architecture Pipeline (a reordena\u00e7\u00e3o el\u00e9trica).</li> </ul> <p>Isso enterra as nuances sombrias das mem\u00f3rias RAM + Cache. Agora mergulhemos no escuro do \"Lento Discovoador\": Os Armazenamentos (Avan\u00e7ar).</p>"},{"location":"slides/slide-13/","title":"Slide 13","text":""},{"location":"slides/slide-13/#dispositivos-de-armazenamento","title":"Dispositivos de Armazenamento","text":""},{"location":"slides/slide-13/#aula-13","title":"Aula 13","text":""},{"location":"slides/slide-13/#1-hdd-hard-disk-drive-vs-ssd-sata","title":"\ud83d\udcbd 1. HDD (Hard Disk Drive) vs SSD (SATA)","text":"<pre><code>O disco de pratos girat\u00f3rios com uma agulha f\u00edsica. \n**Lat\u00eancia**: O motor precisa literalmente girar (Seek Time e Lat\u00eancia Rotacional) at\u00e9 o bloco desejado. As leituras sequenciais (filmes grandes cont\u00ednuos) s\u00e3o aceit\u00e1veis, mas *Random Access* (leitura rand\u00f4mica de pequenos arquivos) \u00e9 catastr\u00f3fica, beirando a eternidade computacional.\n\nArmazenamento em chips de mem\u00f3ria Flash (NAND). Zero partes m\u00f3veis.\n**Lat\u00eancia**: Mil vezes superior ao HDD em acesso Rand\u00f4mico. Seu Banco de Dados Relacional MySQL renasce num SSD porque consegue varrer os \u00edndices disparatadamente sem esperar \"O disco girar\". Ele satura, por\u00e9m, a banda do Barramento SATA (m\u00e1x. 600 MB/s).\n</code></pre>"},{"location":"slides/slide-13/#2-nvme-o-limite-pcie","title":"\u26a1 2. NVMe (O Limite PCIe)","text":"<p>Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em que passam Gigabytes por segundo (ex: Gen4 cruza 7.000 MB/s).</p> <p>Isto alterou para sempre o Backend moderno: Os Softwares de Mem\u00f3ria In-Memory (Redis) est\u00e3o repensando paradigmas pois o Disco NVMe moderno \u00e0s vezes responde com velocidade que ro\u00e7a a velha mem\u00f3ria RAM DDR3!</p>"},{"location":"slides/slide-13/#3-iops-a-metrica-real-do-servidor","title":"\ud83d\udcc8 3. IOPS - A M\u00e9trica Real do Servidor","text":"<p>Se a banda (MB/s) diz o volume da mangueira, os IOPS (Input/Output Operations Per Second) dizem quantos golpes a mangueira d\u00e1 por segundo. </p> <ul> <li>Quando voc\u00ea hospeda um App Node/Python que grava 1 milh\u00e3o de pequenos logs <code>.txt</code> de 1KB, n\u00e3o importa se voc\u00ea tem 7000 MB/s. Voc\u00ea precisa de IOPS Alt\u00edssimos, para que a fila matem\u00e1tica de Write Requests n\u00e3o trave seu servidor (<code>I/O Wait / Blocked</code>). </li> </ul> <p>[!CAUTION] Ao configurar a AWS (Amazon Cloud), inst\u00e2ncias EBS (Discos el\u00e1sticos anexados) cobram mais caro pela volumetria de IOPS. O gargalo da sua API lenta de CRUD nunca \u00e9 a CPU, geralmente \u00e9 porque o Disco Estourou sua cota de Burst de IOPS.</p>"},{"location":"slides/slide-13/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<p>O desenvolvedor C++ entende isso programando a I/O por grandes lotes (<code>Buffers</code>). N\u00e3o escreva no disco <code>1 byte</code> no la\u00e7o for por <code>1 milh\u00e3o de vezes</code> (Destrui\u00e7\u00e3o de IOPS). Acumule os dados num Buffer gig\u00e2ntico de <code>1 MB</code> na RAM, e comande gravar os dados no SSD em \u00fanico e massivo Request! (Otimiza\u00e7\u00e3o m\u00e1xima de Throughput).</p>"},{"location":"slides/slide-14/","title":"Slide 14","text":""},{"location":"slides/slide-14/#sistemas-de-arquivos","title":"Sistemas de Arquivos","text":""},{"location":"slides/slide-14/#aula-14","title":"Aula 14","text":""},{"location":"slides/slide-14/#1-o-v-node-inode","title":"\ud83d\uddc2\ufe0f 1. O V-Node / Inode","text":"<p>Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster.  O FS usa de \u00edndices num\u00e9ricos ultra-r\u00e1pidos: os Inodes. </p> <pre><code>graph LR\n    A[Diret\u00f3rio /Docs] --&gt;|12345| B(\"Inode 12345\")\n    B --&gt; C[Tamanho: 2MB]\n    B --&gt; D[Permiss\u00f5es: rwxr-xr-x]\n    B --&gt; E[Blocos F\u00edsicos de Dados]\n    E --&gt; F[Cluster 80 no SSD]\n    E --&gt; G[Cluster 89 no SSD]</code></pre> <p>[!INFO] Por que o comando de Deletar (rm) um arquivo grande \u00e9 quase instant\u00e2neo, mas copiar \u00e9 lento? O <code>rm</code> apaga apenas a entrada no \u00cdndice (Inode), fingindo pro SO que o espa\u00e7o t\u00e1 livre. O dado mesmo ainda t\u00e1 l\u00e1 magnetizado at\u00e9 algo escrever por cima (Por isso existem softwares de recupera\u00e7\u00e3o de dados!)</p>"},{"location":"slides/slide-14/#2-journaling-a-prova-contra-quedas","title":"\ud83d\udee1\ufe0f 2. Journaling (A Prova contra Quedas)","text":"<p>Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode. E se faltar luz na etapa 2? A parti\u00e7\u00e3o corromperia inteiramente para sempre (Problema antigo do FAT32).</p> <p>FSs modernos (NTFS, EXT4) usam Journaling. Antes de aplicar qualquer mudan\u00e7a no Inode oficial, eles \"anotam a inten\u00e7\u00e3o do que v\u00e3o fazer\" num Di\u00e1rio Oculto (Journal). Se a luz cai, ao ligar o PC, ele l\u00ea o di\u00e1rio oculto incompleto, reverte o estrago e devolve sua m\u00e1quina salva! \u00c9 a ess\u00eancia do conceito Atomicidade.</p>"},{"location":"slides/slide-14/#3-buffers-e-page-cache-por-que-linux-e-rapido","title":"\ud83d\ude84 3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido)","text":"<p>\"Escrever no disco\" via SysCall C++ <code>write()</code> ou <code>fwrite()</code> raramente vai pro HD! O Linux usa de forma abusiva toda a RAM ociosa do seu computador como um gigantesco Cache File. Ele capta suas writes e diz \"Gravei amig\u00e3o!\" mas jogou na RAM (Page Cache). Posteriormente ele realiza os envios reais para o Hardware agrupados (Flush / Sync).</p> <p>Essa m\u00e1gica salva a Morte do seu SSD (menos grava\u00e7\u00f5es simult\u00e2neas em desgaste das celulas NAND) e simula uma ilus\u00e3o de lentid\u00e3o zero ao usu\u00e1rio.</p>"},{"location":"slides/slide-14/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Ao usar C/C++, chame o instr\u00ednseco <code>fsync()</code> se seu App for um Banco de Dados ou Software Cr\u00edtico Banc\u00e1rio for\u00e7ando a Cache RAM descarregar a for\u00e7a e salvar permanentemente no sil\u00edcio do disco.</li> <li>Nunca dependa da nomenclatura C: <code>/usr/foto.jpg</code>. Leia descritores de arquivo, file-pointers e fluxos bin\u00e1rios se for transitar redes em baixo n\u00edvel.</li> </ul>"},{"location":"slides/slide-15/","title":"Slide 15","text":""},{"location":"slides/slide-15/#entrada-e-saida-io","title":"Entrada e Sa\u00edda (I/O)","text":""},{"location":"slides/slide-15/#aula-15","title":"Aula 15","text":""},{"location":"slides/slide-15/#1-system-calls-o-pedagio-do-kernel","title":"\ud83d\udeaa 1. System Calls (O Ped\u00e1gio do Kernel)","text":"<p>Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminante encerramento compuls\u00f3rio pelo Processador atrav\u00e9s do bloqueio de An\u00e9is de Prote\u00e7\u00e3o.</p> <p>Para acionar a Rede, o C++ precisa paralisar, invocar a sagrada System Call (Syscall, ex: write, sendto, read) que abre o portal para o S.O (Kernel Space). \u00c9 o Kernel Linux quem vai orquestrar a placa C de Ethernet.</p>"},{"location":"slides/slide-15/#2-interrupcoes-vs-polling","title":"\u26a0\ufe0f 2. Interrup\u00e7\u00f5es vs Polling","text":"<p>Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\". 1. Polling (Desastroso): A CPU fica travada rodando <code>while(mouse_is_empty) {}</code> perguntando de nano em nanosegundo \"Chegou? E agora? E Agora?\". (Suga 100% da CPU por um mouse inerte). 2. Interrupts (Moderno): A CPU delega para o controlador USB rodar a escuta passiva, e a CPU volta a fechar os frames de Game. Quando o usu\u00e1rio clica com o dedo, o Controlador injeta um choque el\u00e9trico no pino do Processador. Interrupt request (IRQ)! A CPU congela subitamente o Game, salva o contexto, trata o clique do Mouse rapidamente, e exuma a cena do Game novamente do congelamento.</p>"},{"location":"slides/slide-15/#3-dma-memoria-com-acesso-direto","title":"\ud83d\ude80 3. DMA (Mem\u00f3ria com Acesso Direto)","text":"<p>Mesmo com as Interrup\u00e7\u00f5es ajudando a n\u00e3o ficar paralisado Polling... Fazer a Placa de Rede encher a placa RAM transitando Bit a Bit passando pelo miolo doloroso da CPU era impratic\u00e1vel em Gigabit Ethernets.</p> <p>A revolu\u00e7\u00e3o moderna chama-se Direct Memory Access (DMA). Placas de Captura, NVMe e Placas de Rede conversam Diretamente com a Mem\u00f3ria RAM por vias de bypass.</p> <pre><code>graph BT\n    A[Placa de Rede] -- \"Caminho Direto (DMA)\" --&gt; B[Mem\u00f3ria RAM]\n    A -. \"Aviso via IRQ\\n(Terminei!)\" .-&gt; C[CPU]\n    C -. \"Ordens Lentas\" .-&gt; B</code></pre> <p>A CPU diz: \"Placa, baixe o NetFlix do Ponto P pro Q na RAM\". A Placa faz todo os trabalho violento por tr\u00e1s. A CPU usa seu pipeline pra c\u00e1lculos e matem\u00e1tica puros, enquanto sua mem\u00f3ria vai sendo injetada pela placa de v\u00eddeo via t\u00faneis secretos pelas pontes.</p>"},{"location":"slides/slide-15/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se a sua aplica\u00e7\u00e3o Web Framework ass\u00edncrona (como NodeJS ou Nginx C++) trava muito com \"I/O\", isso significa que o Sistema delega opera\u00e7\u00f5es custosas pelo DMA ao Kernel, enquanto orquestra Event-Loops aguardando os famigerados Interrupts de retorno. </li> </ul> <p>Fim do estudo base te\u00f3rico, chegamos ao final. \u00c9 hora de compilar conhecimento na Otimiza\u00e7\u00e3o Pura (Aula Final).</p>"},{"location":"slides/slide-16/","title":"Slide 16","text":""},{"location":"slides/slide-16/#projeto-final-otimizacao-baseada-em-hardware","title":"Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":""},{"location":"slides/slide-16/#aula-16","title":"Aula 16","text":""},{"location":"slides/slide-16/#1-profiling-classico-a-vida-real","title":"\u23f1\ufe0f 1. Profiling Cl\u00e1ssico (A Vida Real)","text":"<p>Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. Usamos ferramentas robustas para que a Arquitetura Linux diga-nos onde os gargalos fervem a CPU.</p> <ul> <li>gprof:   O padr\u00e3o antigo C++. Ele recompila injetando marca\u00e7\u00f5es cont\u00e1beis nas idas e vindas de fun\u00e7\u00f5es, revelando \"Quais chamadas consumiram O Tempo Global\".</li> <li>Valgrind (Callgrind / Cachegrind): Ferramenta extrema rodando seu execut\u00e1vel numa sandbox virtual que mapeia cada instru\u00e7\u00e3o assembly. Traz gr\u00e1ficos massivos de onde Ocorreram os Caches Misses da Mem\u00f3ria L1 de nossa Aula 06!</li> <li>Perf:   O utilit\u00e1rio nativo dos programadores Linux Kernel, extraindo informa\u00e7\u00f5es m\u00e9tricas em Eventos de Desvio (Branch Mispired da Aula 03) usando rel\u00f3gios internos dos registradores ocultos <code>PMU</code> do seu pr\u00f3prio Processador em tempo real, sem overhead sint\u00e9tico.</li> </ul>"},{"location":"slides/slide-16/#2-o-grande-desafio-mini-projeto-pratico","title":"\ud83d\udd2c 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico)","text":"<p>O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware:</p> <pre><code>$ # Desafio do Iterador de Matriz Cont\u00ednua\n$ g++ matriz_opt.cpp -O3 -o matriz\n$ ./matriz \nItera\u00e7\u00e3o Horizontal (Hit L1): Tempo 140ms\nItera\u00e7\u00e3o Vertical (Miss L1): Tempo 2100ms\n</code></pre>"},{"location":"slides/slide-16/#3-conclusao-da-trilha","title":"\ud83c\udfc6 3. Conclus\u00e3o da Trilha","text":"<p>Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada. Um engenheiro de Backend jamais olhar\u00e1 para <code>int x;</code> ou <code>for()</code> sem recordar os impactos t\u00e9rmicos, cache hits mortais de linha, L1 local, reordena\u00e7\u00f5es do std::atomic Memory Model ou Page Faults nos clusters de Sistema e Processos em Swap.</p> <p>Parab\u00e9ns pela resili\u00eancia no vale do Sil\u00edcio e da Matem\u00e1tica discreta profunda. Nunca pare de medir e Otimizar. O Hardware dita as leis; o Software obedece.</p> <p> Finalizar e Visitar Projetos{ .md-button .md-button--primary }</p>"},{"location":"slides/src/slide-01/","title":"Slide 01","text":""},{"location":"slides/src/slide-01/#como-o-software-roda-no-hardware","title":"Como o Software Roda no Hardware","text":""},{"location":"slides/src/slide-01/#aula-01","title":"Aula 01","text":""},{"location":"slides/src/slide-01/#1-o-abismo-entre-codigo-e-silicio","title":"\ud83c\udfd7\ufe0f 1. O Abismo entre C\u00f3digo e Sil\u00edcio","text":"<p>Escrevemos software (como C/C++, Java, Python) usando linguagens compreens\u00edveis a humanos, por\u00e9m processadores processam apenas Sinais El\u00e9tricos ou, abstraindo para o dom\u00ednio digital, Bin\u00e1rios (0 e 1).</p> <p>Como a sua frase <code>printf(\"Hello World\");</code> chega aos pinos do processador? Atrav\u00e9s de uma cadeia de ferramentas (Toolchain).</p>"},{"location":"slides/src/slide-01/#o-processo-de-compilacao-cc","title":"O Processo de Compila\u00e7\u00e3o (C/C++)","text":"<p>Linguagens compiladas de baixo n\u00edvel seguem um caminho determin\u00edstico. Veja o diagrama abaixo de como um arquivo <code>.c</code> \u00e9 fatiado:</p>"},{"location":"slides/src/slide-01/#2-compiladores-vs-interpretadores","title":"\ud83d\udee0\ufe0f 2. Compiladores vs Interpretadores","text":"<p>A forma como seu c\u00f3digo vira m\u00e1quina dita o perfil da performance:</p> <pre><code>O c\u00f3digo \u00e9 100% transformado em bin\u00e1rio *antes* de executar (AOT - Ahead of Time).\n**Pr\u00f3**: Alta velocidade de execu\u00e7\u00e3o. Hardware direto.\n**Contra**: O execut\u00e1vel constru\u00eddo em Linux-x86 n\u00e3o roda nativamente em Windows-ARM sem ser recompilado.\n\n\nUm programa (Interpretador) l\u00ea o seu c\u00f3digo fonte em tempo de execu\u00e7\u00e3o e executa as a\u00e7\u00f5es simulando o comando subjacente para o S.O.\n**Pr\u00f3**: Roda em qualquer SO que tiver o interpretador.\n**Contra**: Muito mais lento, por sofrer *overhead* da interpreta\u00e7\u00e3o.\n\n\nCompilam para um formato intermedi\u00e1rio (*Bytecode*), e a JVM ou CLR as compila JIT (Just-In-Time) na m\u00e1quina cliente no instante de executar.\n</code></pre>"},{"location":"slides/src/slide-01/#3-isa-o-contrato-do-processador","title":"\ud83d\udcd0 3. ISA: O Contrato do Processador","text":"<p>ISA (Instruction Set Architecture) \u00e9 o dicion\u00e1rio de um processador. \u00c9 o conjunto de comandos num\u00e9ricos que o CPU sabe, fisicamente, executar:</p> <ul> <li>Puxar da Mem\u00f3ria (LOAD)</li> <li>Somar (ADD)</li> <li>Gravar na Mem\u00f3ria (STORE)</li> </ul> <p>Todo c\u00f3digo, por mais sofisticado que seja, precisa ser reduzido a estas poucas opera\u00e7\u00f5es ditadas pela ISA para rodar.</p>"},{"location":"slides/src/slide-01/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Ao usar C/C++, voc\u00ea n\u00e3o lida com um motor intermedi\u00e1rio te cobrindo (como a JVM), voc\u00ea escreve algoritmos cuja gest\u00e3o \u00e9 delegada ao S.O. e rodada pura em metal.</li> <li>O programador backend / performance critica deve inspecionar eventuais outputs em Assembly para verificar se a abordagem da linguagem otimiza tempo de registrador.</li> </ul> <p>Pronto para entender profundamente os dados no M\u00f3dulo Bin\u00e1rio?</p>"},{"location":"slides/src/slide-02/","title":"Slide 02","text":""},{"location":"slides/src/slide-02/#representacao-de-dados","title":"Representa\u00e7\u00e3o de Dados","text":""},{"location":"slides/src/slide-02/#aula-02","title":"Aula 02","text":""},{"location":"slides/src/slide-02/#1-sistema-binario-e-hexadecimal","title":"\ud83d\udd22 1. Sistema Bin\u00e1rio e Hexadecimal","text":"<p>O computador compreende nativamente a base 2 (Bin\u00e1rio). Como a escrita bin\u00e1ria \u00e9 muito longa para os humanos, n\u00f3s a agrupamos em Blocos de 4 (Base 16 - Hexadecimal).</p> <ul> <li>Bit: 0 ou 1</li> <li>Byte: 8 bits (<code>00000000</code> a <code>11111111</code>, indo de 0 a 255 no decimal)</li> </ul> <p>Por que <code>Hexadecimal</code> \u00e9 amado pelos desenvolvedores C/C++? Um Byte (8 bits) pode ser perfeitamente representado por exatos dois caracteres Hexadecimais. <code>FF</code> \u00e9 o mesmo que <code>11111111</code>.</p>"},{"location":"slides/src/slide-02/#2-inteiros-com-e-sem-sinal-unsigned","title":"\ud83d\udd0b 2. Inteiros com e sem Sinal (Unsigned)","text":"<p>Em C/C++, o rigor nos tipos prov\u00e9m diretamente do hardware:</p> <pre><code>int x = 255;           // Geralmente um int \u00e9 32 bits, comportando valores grandes, podendo ser negativo (signed).\nunsigned char y = 255; // 8 bits sem sinal (0 a 255)\nsigned char z = -1;    // 8 bits com sinal (-128 a 127)\n</code></pre> <p>No hardware, inteiros negativos s\u00e3o representados usando a regra de Complemento de 2. Para obtermos o bin\u00e1rio do <code>-1</code>, invertemos todos os bits de <code>1</code> e somamos <code>1</code>.</p> <p>[!WARNING] Sempre avalie Overshoot. Um loop usando <code>unsigned int i = 10; while(i &gt;= 0)</code> ser\u00e1 um loop infinito, porque quando <code>i</code> atingir 0 e for subtra\u00eddo, ele NUNCA ficar\u00e1 negativo; ele executar\u00e1 o \"Wrap-around\" arquitetural, voltando ao valor limite de (<code>4.294.967.295</code>).</p>"},{"location":"slides/src/slide-02/#3-ponto-flutuante-ieee-754","title":"\ud83e\uddee 3. Ponto Flutuante (IEEE 754)","text":"<p>Os famosos tipos <code>float</code> e <code>double</code>. O processador possui normalmente um setor dedicado de FPU (Floating Point Unit) para eles.</p> <p>A representa\u00e7\u00e3o oficial IEEE 754 os divide em 3 por\u00e7\u00f5es:</p> <pre><code>flowchart LR\n    A[\"Sinal (1 bit)\"] --- B[\"Expoente (8 bits)\"] --- C[\"Fra\u00e7\u00e3o/Mantissa (23 bits)\"]\n    style A fill:#ff9999\n    style B fill:#99ccff\n    style C fill:#ccffcc</code></pre>"},{"location":"slides/src/slide-02/#o-perigo-da-precisao","title":"O Perigo da Precis\u00e3o!","text":""},{"location":"slides/src/slide-02/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<p>A maneira como voc\u00ea escolhe o tipo primitivo da vari\u00e1vel modela a fisionomia do registrador acionado na m\u00e1quina durante o fetch. Entender o Overflow \u00e9 a prote\u00e7\u00e3o b\u00e1sica contra corrup\u00e7\u00e3o l\u00f3gica do c\u00f3digo.</p>"},{"location":"slides/src/slide-03/","title":"Slide 03","text":""},{"location":"slides/src/slide-03/#cpu-estrutura-e-funcionamento","title":"CPU: Estrutura e Funcionamento","text":""},{"location":"slides/src/slide-03/#aula-03","title":"Aula 03","text":""},{"location":"slides/src/slide-03/#1-o-triangulo-de-ouro-alu-cu-e-registradores","title":"\ud83c\udfd7\ufe0f 1. O Tri\u00e2ngulo de Ouro: ALU, CU e Registradores","text":"<p>A arquitetura interna da CPU possui 3 \u00f3rg\u00e3os vitais:</p> <ol> <li>ALU (Unidade L\u00f3gica e Aritm\u00e9tica): O m\u00fasculo. Onde as somas, subtra\u00e7\u00f5es e portas l\u00f3gicas (AND/OR/XOR) acontecem fisicamente usando transistores.</li> <li>CU (Unidade de Controle): O supervisor. Ela diz \u00e0 ALU o que fazer lendo os \"Opcodes\" (comandos bin\u00e1rios ISA).</li> <li>Registradores: Pequenos e ultra-r\u00e1pidos blocos de mem\u00f3ria embutidos diretamente no chip. (ex: EAX, EBX, RSP).</li> </ol> <pre><code>$ # Como voc\u00ea l\u00ea valores do processador direto em C?\n$ cat register.c\nint main() {\n    register int i = 10; // \"Dica\" para o compilador usar um registrador direto!\n    return i;\n}\n</code></pre>"},{"location":"slides/src/slide-03/#2-o-ciclo-de-instrucao-fetch-decode-execute","title":"\ud83d\udd04 2. O Ciclo de Instru\u00e7\u00e3o (Fetch-Decode-Execute)","text":"<p>Cada opera\u00e7\u00e3o ou linha de c\u00f3digo C/C++ que voc\u00ea escreve \u00e9 processada na cad\u00eancia do Clock pelo ciclo cl\u00e1ssico:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Fetch\n    Fetch --&gt; Decode\n    Decode --&gt; Execute\n    Execute --&gt; Store\n    Store --&gt; Fetch</code></pre> <ol> <li>Fetch (Busca): A CU vai na Mem\u00f3ria RAM e busca qual o pr\u00f3ximo byte de comando, guiando-se pelo Program Counter (PC).</li> <li>Decode (Decodifica): A CU traduz o comando para entender o que \u00e9 (\"Ah, \u00e9 para Somar 5!\").</li> <li>Execute: A ALU recebe os par\u00e2metros e faz a conta f\u00edsica el\u00e9tron a el\u00e9tron.</li> <li>Store (Armazena): O resultado volta para um registrador ou para a Mem\u00f3ria RAM.</li> </ol>"},{"location":"slides/src/slide-03/#3-pipeline-e-previsao-de-desvio-branch-prediction","title":"\u26a1 3. Pipeline e Previs\u00e3o de Desvio (Branch Prediction)","text":"<p>Seu processador n\u00e3o faz essas 4 etapas de forma burra (uma por vez). Ele usa Pipelining: Enquanto a Instru\u00e7\u00e3o A est\u00e1 em Execute, a Instru\u00e7\u00e3o B j\u00e1 est\u00e1 em Decode e a Instru\u00e7\u00e3o C est\u00e1 em Fetch!</p>"},{"location":"slides/src/slide-03/#o-perigo-do-if","title":"O perigo do \"IF\"","text":"<p>Quando voc\u00ea usa muitos <code>if()</code>, o processador tenta \"Adivinhar\" o lado do if usando heur\u00edsticas para n\u00e3o frear o Pipeline (Isso \u00e9 o Branch Prediction).</p> <p>[!WARNING] Errar a adivinha\u00e7\u00e3o do <code>if</code> corrompe todo o Pipeline que foi pr\u00e9-carregado. Em c\u00f3digo de alta performance C++, tentamos escrever loops minimizando saltos condicionais imprevistos.</p>"},{"location":"slides/src/slide-03/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<p>Registradores s\u00e3o seus maiores amigos de performance. C\u00f3digos C++ que permitem ao compilador prender c\u00e1lculos pesados 100% dentro dos Registradores rodam em Nanossegundos, contra Milissegundos lendo sempre pela RAM.</p>"},{"location":"slides/src/slide-04/","title":"Slide 04","text":""},{"location":"slides/src/slide-04/#arquiteturas-risc-vs-cisc","title":"Arquiteturas RISC vs CISC","text":""},{"location":"slides/src/slide-04/#aula-04","title":"Aula 04","text":""},{"location":"slides/src/slide-04/#1-entendendo-a-batalha","title":"\ud83e\udd4a 1. Entendendo a Batalha","text":"<p>A grande revolu\u00e7\u00e3o do backend \u00e9: Seu deploy de aplica\u00e7\u00e3o na AWS/Azure precisa ser em inst\u00e2ncias baseadas em AMD/Intel x86 (CISC) ou inst\u00e2ncias AWS Graviton ARM (RISC), que normalmente s\u00e3o mais baratas?</p> <pre><code>**Fios de Cabelo**: Possui instru\u00e7\u00f5es complexas que podem realizar tarefas gigantescas de uma vez (ex: \"Leia da mem\u00f3ria X, mude o bit Y, grave em Z\" em apenas UMA instru\u00e7\u00e3o assembly).\n**Reis do peda\u00e7o**: Processadores Intel e AMD (x86_64).\n**Caracter\u00edsticas**: Hardware muito complexo, consome mais energia para decodificar instru\u00e7\u00f5es multiformes.\n\n\n**L\u00e2mina Fina**: Possui pouqu\u00edssimas instru\u00e7\u00f5es, todas r\u00e1pidas, simples e uniformes. Fazer \"Leia da mem\u00f3ria X, mude o bit Y, grave em Z\" leva 3 a 4 comandos curtos no assembly.\n**Reis do peda\u00e7o**: Arquitetura ARM (Snapdragon, Apple Silicon M1-M3, AWS Graviton).\n**Caracter\u00edsticas**: Consome pouca bateria e se destaca muito em *Pipelines* agressivos.\n</code></pre>"},{"location":"slides/src/slide-04/#2-como-isso-afeta-o-compilador-cc","title":"\ud83d\udda8\ufe0f 2. Como isso afeta o Compilador C/C++?","text":"<p>Como programador, ao compilar nosso software, a Target Architecture \u00e9 o divisor de \u00e1guas:</p> <pre><code>$ # Compilando para a m\u00e1quina local (digamos, x86_64 CISC)\n$ gcc app.c -o app\n$ # Compilando Cruzado (Cross-Compiling) de um PC x86 para rodar num Raspberry Pi (ARMv8):\n$ aarch64-linux-gnu-gcc app.c -o app_arm\n</code></pre>"},{"location":"slides/src/slide-04/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Historicamente, servidores eram puramente CISC (Intel).</li> <li>Hoje, o mercado clama por RISC gra\u00e7as \u00e0 sustentabilidade t\u00e9rmica (menos energia e calor).</li> <li>Um bom engenheiro percebe que a ISA (aula anterior) CISC vai conter milhares de comandos Assembly, requerendo compiladores muito agressivos, enquanto a ISA RISC exigir\u00e1 compiladores muito detalhistas e otimizados linearmente na aloca\u00e7\u00e3o de registradores C/C++.</li> </ul> <p>Caminho livre at\u00e9 aqui? Ent\u00e3o agora vamos adentrar nas dores da \"Mem\u00f3ria\".</p>"},{"location":"slides/src/slide-05/","title":"Slide 05","text":""},{"location":"slides/src/slide-05/#hierarquia-de-memoria","title":"Hierarquia de Mem\u00f3ria","text":""},{"location":"slides/src/slide-05/#aula-05","title":"Aula 05","text":""},{"location":"slides/src/slide-05/#1-a-piramide-de-alta-performance","title":"\ud83c\udfdb\ufe0f 1. A Pir\u00e2mide de Alta Performance","text":"<p>Um programador ing\u00eanuo acha que \"vari\u00e1vel vai na mem\u00f3ria\". Um engenheiro de software C/C++ sabe em qual camada a vari\u00e1vel se hospeda:</p> <pre><code>graph TD\n    A(\"Registradores&lt;br/&gt;(1 Ciclo - Alguns Bytes)\") --&gt; B[\"Cache L1&lt;br/&gt;(~4 Ciclos - ~64KB a 128KB)\"]\n    B --&gt; C[\"Cache L2 e L3&lt;br/&gt;(~12 a ~40 Ciclos - Megabytes)\"]\n    C --&gt; D[[\"RAM (Mem\u00f3ria Principal)&lt;br/&gt;(~200 a ~300 Ciclos - Gigabytes)\"]]\n    D --&gt; E[(\"Armazenamento (SSD / HDD)&lt;br/&gt;(Milh\u00f5es de Ciclos - Terabytes)\")]\n\n    style A fill:#ff9999\n    style B fill:#ffcc99\n    style C fill:#ffff99\n    style D fill:#ccffcc\n    style E fill:#99ccff</code></pre> <p>[!IMPORTANT] A lat\u00eancia \u00e9 o tempo que demora da CPU pedir um dado at\u00e9 ele chegar. Buscar um byte da RAM demora ~200 ciclos. Buscar do SSD demora centenas de milhares. Essa diferen\u00e7a grotesca \u00e9 mitigada pelo uso de Caches.</p>"},{"location":"slides/src/slide-05/#2-os-impactos-da-latencia-lado-do-codigo","title":"\u23f3 2. Os Impactos da Lat\u00eancia (Lado do C\u00f3digo)","text":"<p>Quando escrevemos um c\u00f3digo com constantes consultas n\u00e3o linearizadas ao Banco de Dados (ou SSD local), pagamos a mais cara taxa processual: o I/O disk penalty.</p> <pre><code>$ # Como consultar as camadas do processador Linux\n$ lscpu | grep Cache\nL1d cache:                       64 KiB\nL1i cache:                       64 KiB\nL2 cache:                        1 MiB\nL3 cache:                        12 MiB\n</code></pre>"},{"location":"slides/src/slide-05/#3-optimizando-uso","title":"\ud83c\udfaf 3. Optimizando Uso","text":"<p>Por que linguagens como C e C++ dominam infraestrutura de servidores High Frequency Trading? Porque elas permitem <code>Aloca\u00e7\u00e3o Est\u00e1tica e Constante</code> que \u00e9 perfeitamente \"encaixada\" pelo compilador diretamente na mem\u00f3ria Cache.</p> <p>Ao inv\u00e9s de carregar gigabytes de Strings na lenta RAM, as linguagens de baixo n\u00edvel incentivam o uso de matrizes de tamanho delimitado (arrays fixos), cujo agrupamento cont\u00edguo for\u00e7a a arquitetura de Hardware Prefetching a adiantar os bytes do Array para a Cache nativamente, antes mesmo de voc\u00ea rodar a linha do c\u00f3digo!</p>"},{"location":"slides/src/slide-05/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se processadores hoje s\u00e3o m\u00edsseis atingindo +4GHz, a RAM parou no tempo (Lat\u00eancia de CAS n\u00e3o baixa proporcionalmente).</li> <li>Tudo recai na t\u00e9cnica humana de amarrar dados juntos (Caches L1 e L2) e escrever data-oriented code se quiser ultra-lat\u00eancia C++.</li> </ul>"},{"location":"slides/src/slide-06/","title":"Slide 06","text":""},{"location":"slides/src/slide-06/#cache-e-localidade","title":"Cache e Localidade","text":""},{"location":"slides/src/slide-06/#aula-06","title":"Aula 06","text":""},{"location":"slides/src/slide-06/#1-cache-hit-e-cache-miss","title":"\u2705 1. Cache Hit e Cache Miss","text":"<p>O desempenho do seu loop <code>for()</code> depende maci\u00e7amente da Cache Hit Rate.</p> <ul> <li>Cache Hit: Acerto! A CPU pediu a posi\u00e7\u00e3o <code>[1]</code>, ela j\u00e1 estava na Cache e a conta foi resolvida quase imediatamente.</li> <li>Cache Miss: Erro! O processador precisou parar o Pipeline, ir at\u00e9 a RAM lenta, injetar o bloco de bytes na lenta escalada D-Cache/L3/L2/L1 e prosseguir.</li> </ul> <pre><code>sequenceDiagram\n    participant P as Programador\n    participant C as Cache L1\n    participant R as RAM\n\n    P-&gt;&gt;C: Quero array[0]!\n    Note right of C: \"Cache Hit\" (Sucesso imediato)\n\n    P-&gt;&gt;C: Quero NodeLink-&gt;prox!\n    Note right of C: N\u00e3o est\u00e1 aqui...\n    C-&gt;&gt;R: Buscar Posi\u00e7\u00e3o Lenta na RAM...\n    R--&gt;&gt;C: Traz o bloco de 64bytes inteiro\n    Note right of C: \"Cache Miss\" (Atraso)</code></pre>"},{"location":"slides/src/slide-06/#2-localidade-espacial-vs-temporal","title":"\ud83d\uddfa\ufe0f 2. Localidade Espacial vs Temporal","text":"<p>As duas premissas arquiteturais da Localidade em Sistemas de Computa\u00e7\u00e3o (que fundamentam toda escrita C/C++ otimizada):</p> <pre><code>Se o programa acessou a vari\u00e1vel na posi\u00e7\u00e3o de mem\u00f3ria `X`, h\u00e1 extrema probabilidade de que no ciclo de CPU seguinte ele acesse a vari\u00e1vel de mem\u00f3ria `X + 1`.\n*O cl\u00e1ssico caso dos **Arrays Continuos (std::vector)**, garantindo varredura limpa em Hit sequencial absoluto de 64 em 64 bytes.*\n\n\nSe o programa visitou a vari\u00e1vel `Y` agora, h\u00e1 enorme probabilidade dele visit\u00e1-la nos pr\u00f3ximos ms.\n*O cl\u00e1ssico caso das **Vari\u00e1veis Locais e Contadores Padr\u00f5es (`int i = 0`)** retidos brutalmente no Registrador ou na L1.*\n</code></pre>"},{"location":"slides/src/slide-06/#3-false-sharing-e-logica-invertida-a-morte-do-c","title":"\ud83e\udde8 3. False Sharing e L\u00f3gica Invertida (A Morte do C++)","text":"<p>[!WARNING] O vil\u00e3o m\u00e1ximo da performance: Iterar sobre matrizes pela Coluna ao inv\u00e9s da Linha. A imagem matriz na RAM C/C++ (Row-major order) exige saltos. E False Sharing ocorre quando threads isoladas atualizam vari\u00e1veis cont\u00edguas da mesma linha de Cache de 64 bytes, for\u00e7ando o Hardware (Cache Coherence Protocol) a invalidar repetitivas vezes L1/L2, triturando toda m\u00e9trica.</p> <p>A estrutura define a localidade espacial. Prefira dezenas de min\u00fasculas vari\u00e1veis sequenciais nos m\u00e9todos a usar longos grafos com saltos rand\u00f4micos baseados em ponteiros, se for iterar a esmo.</p>"},{"location":"slides/src/slide-07/","title":"Slide 07","text":""},{"location":"slides/src/slide-07/#stack-vs-heap","title":"Stack vs Heap","text":""},{"location":"slides/src/slide-07/#aula-07","title":"Aula 07","text":""},{"location":"slides/src/slide-07/#1-a-pilha-stack","title":"\ud83e\uddf1 1. A Pilha (Stack)","text":"<p>A Stack \u00e9 a funda\u00e7\u00e3o natural de blocos de toda vari\u00e1vel ordinariamente declarada dentro do escopo de fun\u00e7\u00f5es em C/C++ (<code>int x</code>, <code>float y</code>). Ela trabalha rigorosamente sob o conceito LIFO (Last In, First Out). </p> <pre><code>- **Performance Imediata**: N\u00e3o sofre do atraso monumental do Sistema Operacional rodando scripts para achar buracos vazios. A CPU avan\u00e7a 1 pino de hardware no SP (Stack Pointer) e empilha na RAM. Retirou, ele decrementa. Super r\u00e1pido.\n- **Anti-Vazamento Autom\u00e1tico**: Fun\u00e7\u00f5es extintas s\u00e3o imediatamente retiradas (*popped*) num clique at\u00f4mico LIFO e as fatias voltam a uso global. Mem\u00f3ria protegida contra vazamentos l\u00f3gicos (*memory leaks*) por defini\u00e7\u00e3o estrita.\n- **Quente da CPU**: Frequentemente preza por Cache Hit. A Stack costuma viver majoritariamente no limiar da L1 Data Cache.\n</code></pre> <p>[!CAUTION] Stack Overflow! A Pilha nunca \u00e9 infinita, sendo tipicamente restrita pelo S.O. Windows/Linux (geralmente entre 1MB a 8MB max num Kernel Padr\u00e3o X86). Tentar criar um <code>int array[9999999]</code> puro no escopo sem aloca\u00e7\u00e3o din\u00e2mica explodir\u00e1 a Pilha e esmagar\u00e1 cruelmente (o temido <code>Segmentation Fault (core dumped)</code>).</p>"},{"location":"slides/src/slide-07/#2-o-monte-heap","title":"\ud83d\udce6 2. O Monte (Heap)","text":"<p>Enquanto a Pilha \u00e9 r\u00edgida, restrita e pr\u00e9-delimitada, o Monte (Heap) \u00e9 um vasto oceano ca\u00f3tico de Gigabytes gerenciado pelo Kernel do S.O. (Sistemas Operacionais). Voc\u00ea requer peda\u00e7os de mem\u00f3ria \"sob demanda\" (Aloca\u00e7\u00e3o Din\u00e2mica).</p> <pre><code>$ # Como voc\u00ea interage em baixo n\u00edvel (C/C++)\n$ cat code.c\n#include &lt;stdlib.h&gt;\n\nint main() {\n    // malloc vai no Sistema Operacional e chora pedindo: \"Me d\u00ea 10 inteiros!\"\n    int* array_gigante_dinamico = (int*)malloc(10 * sizeof(int));\n\n    // Se voc\u00ea n\u00e3o limpar usando free(), a RAM apodrecer\u00e1 lentamente (LEAK)\n    free(array_gigante_dinamico);\n}\n</code></pre>"},{"location":"slides/src/slide-07/#3-memory-leaks-vazamentos-de-memoria","title":"\ud83d\udc80 3. Memory Leaks (Vazamentos de Mem\u00f3ria)","text":"<p>Um cl\u00e1ssico e letal bug de engenharia C++. Quando o desenvolvedor executa <code>new</code> ou <code>malloc</code> solicitando mem\u00f3ria do Heap, mas quebra regras do fluxo perdendo o contato formal do ponteiro retornado do hardware sem antes ter reportado o fim via <code>delete</code> ou <code>free</code>. Resultado?  Aquela fatia na RAM f\u00edsica do servidor Linux ficar\u00e1 congelada, cega, retida unicamente pro seu app at\u00e9 que a nuvem AWS exaure toda a m\u00e1quina do container num erro de Kernel <code>OOM Killer (Out Of Memory)</code>.</p> <p>Em contra-partida: Dangling Pointers. Usar a \u00e1rea que o ponteiro apontava depois da liberta\u00e7\u00e3o formal do free provoca instabilidade instant\u00e2nea e corrup\u00e7\u00e3o silenciosa nos endere\u00e7os da placa-m\u00e3e.</p>"},{"location":"slides/src/slide-07/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se n\u00e3o sabe onde colocar: Bote no STACK.</li> <li>\u00c9 muito grande pra caber (Strings longas ou Arrays): Invoque HEAP com o <code>std::vector</code> (ele gerencia o malloc e free na destrui\u00e7\u00e3o de escopo).</li> </ul>"},{"location":"slides/src/slide-08/","title":"Slide 08","text":""},{"location":"slides/src/slide-08/#memoria-virtual","title":"Mem\u00f3ria Virtual","text":""},{"location":"slides/src/slide-08/#aula-08","title":"Aula 08","text":""},{"location":"slides/src/slide-08/#1-o-abismo-logico-a-memoria-virtual","title":"\ud83d\udd73\ufe0f 1. O Abismo L\u00f3gico: A Mem\u00f3ria Virtual","text":"<p>Nenhum aplicativo C/C++ ou interpretador em execu\u00e7\u00e3o roda interagindo fisicamente e sabendo explicitamente qual \u00e9 o transistor fixo l\u00e1 no pente da Kingston RAM na placa do data-center.</p> <p>Todo processo que o Linux constr\u00f3i roda dentro de uma gigante Ilus\u00e3o. O endere\u00e7o do seu ponteiro <code>0x7ffeeB...</code> em C++ \u00e9 falso (Endere\u00e7o L\u00f3gico).</p> <p>O HW (Hardware MMU no processador) mais as planilhas do Sistema Operacional (Page Tables) formencem a liga\u00e7\u00e3o din\u00e2mica e escondida pra sua aplica\u00e7\u00e3o.</p> <pre><code>graph LR\n    A[\"Ponteiro em C++&lt;br/&gt;(Virtual 0x01)\"] --&gt; B{\"MMU e&lt;br/&gt;Page Table\"}\n    B --&gt; C(\"Mem\u00f3ria RAM&lt;br/&gt;(F\u00edsica Pente 1)\")\n    B -. \"Se n\u00e3o houver espa\u00e7o\" .-&gt; D(\"Swap / Pagefile&lt;br/&gt;(SSD)\")</code></pre>"},{"location":"slides/src/slide-08/#2-tlb-mmu-e-a-traducao-da-pagina","title":"\ud83d\udcc4 2. TLB, MMU e a Tradu\u00e7\u00e3o da P\u00e1gina","text":"<p>Cada tradu\u00e7\u00e3o do falso ponteiro visual com base nas tabelas em RAM \u00e9 custoso (Cycle Penalty).</p> <p>Para driblar isso, a arquitetura moderna usa a TLB (Translation Lookaside Buffer). A TLB \u00e9 uma Cache dentro da CPU que guarda apenas os dicion\u00e1rios recentes das planilhas de refer\u00eancias que dizem se o \"0X7FFA falso vira bloco 344 do pente de DDR5 real\".</p> <pre><code>- **Page Hit:** A tradu\u00e7\u00e3o ocorreu instat\u00e2neamente pela cache veloz na CPU (a TLB validou o ponteiro do C++ localizando logo onde est\u00e1 no metal a vari\u00e1vel no chip Kingston).\n- **Page Fault Limitrofico:** A TLB errou e teve que rolar pra Main RAM puxando o endere\u00e7o mapeado localizando num novo cluster na pilha. (100+ ciclos)\n- **Page Fault Cr\u00edtico (SWAP):** A m\u00e1quina n\u00e3o acha e entra em Swapping com o SSD (SSD Swap). \u00c9 ali que ocorre as quedas colossais para \"Travamento de Janela\", a CPU foi pro SSD buscar um arquivo gigante que o Linux ejetou l\u00e1, pra trazer e rebotar pra cima pra Mem\u00f3ria RAM f\u00edsica real, jogando pro seu c\u00f3digo que achava estar \"na mem\u00f3ria\" e dormiu (Milh\u00f5es de ciclos).\n</code></pre>"},{"location":"slides/src/slide-08/#3-driblando-a-paginacao-como-programador","title":"\ud83d\udcaa 3. Driblando a Pagina\u00e7\u00e3o como Programador","text":"<p>Ao iterarmos matrizes massivas (Matrizes 2D em C++) na ordem invertida ou em l\u00f3gicas dispersas <code>LinkedList-&gt;prox</code>, voc\u00ea n\u00e3o causa apenas Cache Miss da Aula 06. Voc\u00ea tamb\u00e9m destr\u00f3i toda a cache de pontes TLB Misses! Voc\u00ea induzir\u00e1 Page Faults insanos que derrubar\u00e3o o throughput (taxa de transfer\u00eancia de dados) em N fatores.</p> <p>Portanto: Localidade Espacial \u00e9 sagrada em Dados C/C++.</p>"},{"location":"slides/src/slide-08/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>O ponteiro que o dev manipula com um <code>int *ptr = &amp;value</code> em qualquer IDE \u00e9 puramente 100% Virtual. \u00c9 o passaporte intermedi\u00e1rio.</li> <li>Nunca dependa da pagina\u00e7\u00e3o e arquivo local de Swap do Disco: os mil\u00e9simos de segundo viram minutos na Nuvem se o app \"estourar a cota da cloud\", sofrendo <code>Thrashing</code> com o Disco local para falsificar a RAM que ele acreditou ter num loop mal codificado ou em Leaks do M\u00f3dulo/Aula anterior.</li> </ul>"},{"location":"slides/src/slide-09/","title":"Slide 09","text":""},{"location":"slides/src/slide-09/#processos-e-threads","title":"Processos e Threads","text":""},{"location":"slides/src/slide-09/#aula-09","title":"Aula 09","text":""},{"location":"slides/src/slide-09/#1-processos-isolamento-forte","title":"\ud83c\udfc3 1. Processos (Isolamento Forte)","text":"<p>O Processo \u00e9 o cont\u00eainer mestre do Sistema Operacional. Quando a execu\u00e7\u00e3o do seu bin\u00e1rio em C/C++ se inicia via Terminal, vira um Processo (<code>PID 2900</code>).</p> <ul> <li>O S.O. d\u00e1 ao Processo sua pr\u00f3pria e exclusiva Mem\u00f3ria Virtual (visto na Aula 8).</li> <li>O Processo tem sua exclusiva Pilha e n\u00e3o se mistura nunca. E isso isola falhas: se um Chrome (processo isolado) trava, n\u00e3o d\u00e1 tela azul na outra aba.</li> <li>A comunica\u00e7\u00e3o entre Processos (IPC - Inter-process Communication) \u00e9 pesada e necessita do S.O. atrav\u00e9s de Pipes ou Redes. </li> </ul>"},{"location":"slides/src/slide-09/#2-threads-isolamento-fraco-partilha","title":"\ud83e\uddf5 2. Threads (Isolamento Fraco / Partilha)","text":"<p>Quando se est\u00e1 em um jogo e, ao mesmo tempo que carrega os gr\u00e1ficos na GPU, uma m\u00fasica de CD est\u00e1 lendo sem travar, estamos olhando para Multithreading!</p> <pre><code>graph TD\n    A(\"Processo (ID: 5599) - Backend Web\") --&gt; B[(\"Heap Memory (Compartilhado)\")]\n    A --&gt; C[\"Thread 01 (Rota A)\"]\n    A --&gt; D[\"Thread 02 (Rota B)\"]\n    A --&gt; E[\"Thread 03 (Pool C)\"]\n\n    C --&gt; F((Stack Exclusiva T1))\n    D --&gt; G((Stack Exclusiva T2))\n    E --&gt; H((Stack Exclusiva T3))\n\n    B --&gt; C\n    B --&gt; D\n    B --&gt; E</code></pre> <p>Uma Thread \u00e9 simplesmente uma subdivis\u00e3o leve controlada do processo. Elas todas orbitam e vivem na exata MESMA MEM\u00d3RIA VIRTUAL (Heap) DO PROCESSO MESTRE.</p> <pre><code>Duas `std::thread` manipulando os ponteiros apontam rigorosamente r\u00e1pido ao mesmo endere\u00e7o na RAM sem nenhuma barreira do S.O., o que traz milisegundos imbat\u00edveis versus IPC!\n</code></pre>"},{"location":"slides/src/slide-09/#3-context-switch-a-faca-de-dois-gumes","title":"\u2699\ufe0f 3. Context Switch (A Faca de Dois Gumes)","text":"<p>Quando escrevemos <code>\"Hello World\"</code>, achamos que a CPU roda por horas sem interrup\u00e7\u00f5es. Engano.</p> <p>O S.O. possui um n\u00facleo (Kernel Scheduler) que fatia mil\u00e9simos de mil\u00e9simos de segundos distribuindo uma core <code>i7-P</code> para a aba do Google, logo retira o Google e taca nos frames do VS-Code, em micro-loop alternante de Context Switches. O problema? Puxar e devolver o estado (registradores, program counter) na cache \u00e9 hiper custoso e derruba o Pipeline se abusado (overhead em CPU bound apps).</p>"},{"location":"slides/src/slide-09/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se a tarefa for CPU-Bound (requerer Matem\u00e1tica Bruta Massiva / Machine Learning), voc\u00ea cria Threads numerando-as pr\u00f3ximo n\u00famero oficial de n\u00facleos estritos da CPU, evitando desperd\u00edcio de overhead com Context Switches ilus\u00f3rios.</li> <li>\u00c9 muito f\u00e1cil em C/C++ estragar a vida financeira do cliente numa Race Condition compartilhada pelo Heap se n\u00e3o protegida... mas isso \u00e9 o tema da pr\u00f3xima aula!</li> </ul>"},{"location":"slides/src/slide-10/","title":"Slide 10","text":""},{"location":"slides/src/slide-10/#sincronizacao-e-concorrencia","title":"Sincroniza\u00e7\u00e3o e Concorr\u00eancia","text":""},{"location":"slides/src/slide-10/#aula-10","title":"Aula 10","text":""},{"location":"slides/src/slide-10/#1-o-data-race-uma-colisao-inevitavel","title":"\ud83c\udfce\ufe0f 1. O Data Race: Uma Colis\u00e3o Inevit\u00e1vel","text":"<p>Imaginemos uma vari\u00e1vel primitiva <code>int balance = 100;</code>. Em Assembly C/C++, aumentar uma quantia em <code>balance += 10;</code> n\u00e3o \u00e9 \"Um \u00danico Movimento\". O HW (Processador) traduz internamente num RMW: Read (Puxa os 100 da RAM para o Registrador EAX), Modify (Adiciona +10 e vira 110 na ALU), e Write (Substitui na RAM os antigos 100 por 110).</p> <p>Se na fresta entre a Thread 1 preencher o EAX e depois descer ao RAM o valor 110... a Thread 2 rodar e \"puxar os mesm\u00edssimos originais 100\" para outro registrador (Context Switch), quando abas enviarem pra RAM final as sobreposi\u00e7\u00f5es as contas, um dos <code>10</code> desvanecer\u00e1, o banco perde e a vari\u00e1vel fica logicamente corrompida.</p>"},{"location":"slides/src/slide-10/#2-mutex-e-the-critical-section","title":"\ud83d\udee1\ufe0f 2. Mutex e The Critical Section","text":"<p>A solu\u00e7\u00e3o em qualquer projeto multi-thread backend/C++ \u00e9 envolver as mem\u00f3rias ou o fluxo com objetos pesados at\u00f4micos do Kernel: As Locks (Travas) como padr\u00e3o Ouro C++: <code>std::mutex</code> (Mutual Exclusion).</p> <pre><code>$ # Em C++, protege-se a vari\u00e1vel central assim:\n$ cat bank.cpp\nstd::mutex portaCorredor;\n\nvoid adiciona_10() {\n    portaCorredor.lock();   // O Hardware garante atomicamente exclus\u00e3o\n    balance += 10;          // Apenas UM transita aqui adentro. \n    portaCorredor.unlock(); // O primeiro sai da sala, e notifica o Kernel\n}\n</code></pre>"},{"location":"slides/src/slide-10/#3-o-dilema-deadlock","title":"\ud83d\udea6 3. O Dilema: Deadlock","text":"<p>Mas e se o programador de Backend C/C++ prender (usou lock() ou Mutex) em A esperando que B seja terminado.. mas B s\u00f3 termina porque B precisa pegar lock() em A que t\u00e1 bloqueado?</p> <p>Ambos processos morrem na tela, dormindo inertes (Blocked State), enquanto a barra de % CPU despenca lentamente para ZERO! Seu Sistema Paralelo entrou em Deadlock. (O Abra\u00e7o Mortal Padr\u00e3o The Dining Philosophers). Um design multi-thread exige uma heuristica sagrada de adquirir as trancas Lock C++ em id\u00eantica e constante ordem arquitetural atrav\u00e9s dos sistemas, ou apelar a mec\u00e2nicas <code>std::lock()</code> que aplicam garantias subjacentes do Kernel.</p>"},{"location":"slides/src/slide-10/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Mutex: Usa o sistema do n\u00facleo para trancar \u00e1reas exclusivas do Hardware (RAM).</li> <li>Se a concorr\u00eancia n\u00e3o tiver \"Se\u00e7\u00e3o Cr\u00edtica\" que lida com Grava\u00e7\u00e3o e tiver \"S\u00f3 Read-only\", n\u00e3o aplique trancas (Mutex) para n\u00e3o serializar as Threads da m\u00e1quina.</li> </ul>"},{"location":"slides/src/slide-11/","title":"Slide 11","text":""},{"location":"slides/src/slide-11/#paralelismo-no-hardware","title":"Paralelismo no Hardware","text":""},{"location":"slides/src/slide-11/#aula-11","title":"Aula 11","text":""},{"location":"slides/src/slide-11/#1-multi-core-multiplos-nucleos","title":"\ud83c\udfd7\ufe0f 1. Multi-Core (M\u00faltiplos N\u00facleos)","text":"<p>Diferente do passado, onde havia um \u00fanico n\u00facleo saltando entre aplicativos (Context Switch), hoje temos v\u00e1rios n\u00facleos f\u00edsicos no mesmo inv\u00f3lucro (Chip).</p> <ul> <li>Core F\u00edsico: \u00c9 uma CPU completa e independente, com sua pr\u00f3pria ALU, Unidade de Controle e Caches L1/L2 particulares.</li> <li>Cache L3 Compartilhado: Na maioria dos designs AMD e Intel reais, os M\u00faltiplos Cores (Ex: 8 Cores) conversam e trocam estados atrav\u00e9s de uma suntuosa e lenta \u00e1rea comum L3 que circunda todos os processadores ali impressos no wafer.</li> </ul> <p>[!TIP] Em Backend pesado: Se o banco mapear duas Threads puras <code>backend</code> em dois Cores puramente isolados (Ex: Core 0 e Core 1), e elas lerem/trabalharem na mesma matriz cont\u00ednua, o Hardware for\u00e7ar\u00e1 interc\u00e2mbios el\u00e9tricos no Cache Coherence Protocol (MESI) rodando por toda placa m\u00e3e. Fiquem espertos com o False Sharing! </p>"},{"location":"slides/src/slide-11/#2-hyper-threading-smt-symmetrical-multi-threading","title":"\ud83e\uddec 2. Hyper-Threading (SMT - Symmetrical Multi-Threading)","text":"<p>A m\u00e1gica comercial da Intel e AMD nos anos 2000. Como fazer \"1 Core F\u00edsico\" fingir ser \"2 Cores L\u00f3gicos\" para o Windows/Linux?</p> <p>Na aula 03, vimos que a execu\u00e7\u00e3o cruza pelo Pipeline ou pode esbarrar em ciclos ociosos na CU aguardando a Mem\u00f3ria Principal. O Hyper-Threading espeta um Segundo conjunto de Registradores e Hardware de Estado no mesmo Core. Enquanto o c\u00f3digo da Thread \"A\" est\u00e1 0.5 nanosegundo travada esperando chegar o dado lento da L3, o Core troca instantaneamente para o contexto da Thread \"B\", executando-o usando as mesmas Unidades L\u00f3gicas (ALU) num aproveitamento fabril monstruoso de 100%.</p> <pre><code>$ # Lendo o processador em Linux (Ex: i7 4-Core com HyperThreading)\n$ lscpu\nCPU(s):                  8\nOn-line CPU(s) list:     0-7\nThread(s) per core:      2\nCore(s) per socket:      4\n</code></pre>"},{"location":"slides/src/slide-11/#3-gpus-o-paralelismo-macico","title":"\ud83c\udfae 3. GPUs: O Paralelismo Maci\u00e7o","text":"<p>CPUs (Processadores) foram feitos para \"Serem R\u00e1pidos executando sequ\u00eancias l\u00f3gicas e IFs complexos\". Possuem Caches gigantes. GPUs (Placas de V\u00eddeo) foram feitas para \"Executar a MESM\u00cdSSIMA MIN\u00daSCULA matem\u00e1tica simultaneamente em milhares de pixels fracos\". Sem grandes condicionais, focando no Throughput. </p> <p>NVIDIA e CUDA (plataforma de C++) reinam supremas em Deep Learning e Criptografia exatamente porque pegam Loops For gigantescos de \u00c1lgebra Linear, e fracionam em 8.000 mini-n\u00facleos (CUDA cores) esmagando qualquer Intel Core i9 na lat\u00eancia matem\u00e1tica cont\u00ednua pura.</p>"},{"location":"slides/src/slide-11/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Task Paralelism: Se tens l\u00f3gica variada, use a CPU Multi-Core C++ thread pool.</li> <li>Data Paralelism: Se a conta for a repeti\u00e7\u00e3o retumbante de um algoritmo id\u00eantico sobre 2 milh\u00f5es de dados sem depend\u00eancia de saltos complexos, mova-a da RAM \u00e0 VRAM da GPU via CUDA/OpenCL. A m\u00e9trica vai das horas paras os d\u00e9cimos de segundo.</li> </ul>"},{"location":"slides/src/slide-12/","title":"Slide 12","text":""},{"location":"slides/src/slide-12/#o-modelo-de-memoria","title":"O Modelo de Mem\u00f3ria","text":""},{"location":"slides/src/slide-12/#aula-12","title":"Aula 12","text":""},{"location":"slides/src/slide-12/#1-a-reordenacao-do-compilador-e-cpu-out-of-order-execution","title":"\ud83d\udd00 1. A Reordena\u00e7\u00e3o do Compilador e CPU (Out-Of-Order Execution)","text":"<p>Voc\u00ea codifica: </p><pre><code>int x = 0;\nint FLAG = false;\n\n// Em uma Thread Secund\u00e1ria\nx = 42;         // PASSO A\nFLAG = true;    // PASSO B\n</code></pre><p></p> <p>Um programador esperan\u00e7oso diz: \"Vou ler a v\u00e1riavel na Thread Oposta (Main)... e quando <code>FLAG</code> for true, sei que <code>X</code> \u00e9 impreterivelmente 42 pois executei a linha acima primeiro na tela!\"</p> <p>FALSO! MORTALMENTE FALSO!</p>"},{"location":"slides/src/slide-12/#2-o-memory-model-consistencias-e-barreiras","title":"\ud83d\udea7 2. O Memory Model (Consist\u00eancias e Barreiras)","text":"<p>O C++11 emitiu formalmente o seu universal Memory Model definindo atrav\u00e9s da biblioteca <code>std::atomic</code> o que o Hardware tem permi\u00e7\u00f5es para Adiantar vs Trancar.</p> <ol> <li>Relaxed Consistensy (<code>std::memory_order_relaxed</code>): A CPU \u00e9 dona, reordene como quiser em torno da sua vizinhan\u00e7a na RAM, apenas aplique na thread isolada em seguran\u00e7a. Performance brutal.</li> <li>Release / Acquire (<code>std::memory_order_acquire / release</code>): O padr\u00e3o para transferir fardos (como ler a Fila sem locks e sem medo da Out-Of-Order embaralhar flags finalizadoras de Loop C++ no hardware alheio do *Core 2).</li> <li>Sequential Consistency (<code>std::memory_order_seq_cst</code>): O C++ por default invoca barreiras completas absolutas el\u00e9tricas. For\u00e7a todas as cores (L1/L2) da CPU e do compilador a n\u00e3o alterarem NADA a ordem que seu texto determinou. Seguro, mas castrador de velocidade em processadores ARM.</li> </ol>"},{"location":"slides/src/slide-12/#3-memory-barriers-fences-nas-cpus","title":"\ud83e\uddf1 3. Memory Barriers (Fences) nas CPUs","text":"<p>Se n\u00e3o tivessemos essa lei <code>std::atomic</code> no standard oficial do GCC, program\u00e1vamos via \"Gambiarra Intrinseca\" de Processador (Ex: Comando Assembler MFENCE ou SFENCE no Intel). Os Fences pro\u00edbem categoricamente a travessia de saltos das sub-opera\u00e7\u00f5es em Assembly, estancando a execu\u00e7\u00e3o como um sinaleiro fechado.</p> <p>[!INFO] \u00c9 por isso que programar Software Infra-estrutural de Baixo N\u00edvel (Databases, Motores de Redes Socket, SO Kernel Driver) \u00e9 extremamente dif\u00edcil: As reordena\u00e7\u00f5es da CPU nunca acontecem quando voc\u00ea depura linha a linha na IDE (pois a paralela n\u00e3o \u00e9 instigada). Elas s\u00f3 geram corrup\u00e7\u00f5es bizarras rand\u00f4micas 1x na vida e morrem meses na escura neblina de servidores reais operando 100 mil Requests por Minuto no DataCenter. Onde a press\u00e3o el\u00e1stica exaure as Caches e exp\u00f5e seus Bugs de Memory Models relaxados.</p>"},{"location":"slides/src/slide-12/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se duas \"Threads\" conversam atrav\u00e9s das mesmas vari\u00e1veis limpas de C e n\u00e3o possuam <code>std::mutex</code> da aula 10 as blindando, USE <code>std::atomic&lt;bool&gt;</code>. Do contr\u00e1rio voc\u00ea \u00e9 uma v\u00edtima da Superscalar Out Of Order Intel Architecture Pipeline (a reordena\u00e7\u00e3o el\u00e9trica).</li> </ul> <p>Isso enterra as nuances sombrias das mem\u00f3rias RAM + Cache. Agora mergulhemos no escuro do \"Lento Discovoador\": Os Armazenamentos (Avan\u00e7ar).</p>"},{"location":"slides/src/slide-13/","title":"Slide 13","text":""},{"location":"slides/src/slide-13/#dispositivos-de-armazenamento","title":"Dispositivos de Armazenamento","text":""},{"location":"slides/src/slide-13/#aula-13","title":"Aula 13","text":""},{"location":"slides/src/slide-13/#1-hdd-hard-disk-drive-vs-ssd-sata","title":"\ud83d\udcbd 1. HDD (Hard Disk Drive) vs SSD (SATA)","text":"<pre><code>O disco de pratos girat\u00f3rios com uma agulha f\u00edsica. \n**Lat\u00eancia**: O motor precisa literalmente girar (Seek Time e Lat\u00eancia Rotacional) at\u00e9 o bloco desejado. As leituras sequenciais (filmes grandes cont\u00ednuos) s\u00e3o aceit\u00e1veis, mas *Random Access* (leitura rand\u00f4mica de pequenos arquivos) \u00e9 catastr\u00f3fica, beirando a eternidade computacional.\n\nArmazenamento em chips de mem\u00f3ria Flash (NAND). Zero partes m\u00f3veis.\n**Lat\u00eancia**: Mil vezes superior ao HDD em acesso Rand\u00f4mico. Seu Banco de Dados Relacional MySQL renasce num SSD porque consegue varrer os \u00edndices disparatadamente sem esperar \"O disco girar\". Ele satura, por\u00e9m, a banda do Barramento SATA (m\u00e1x. 600 MB/s).\n</code></pre>"},{"location":"slides/src/slide-13/#2-nvme-o-limite-pcie","title":"\u26a1 2. NVMe (O Limite PCIe)","text":"<p>Para ultrapassar o gargalo da conex\u00e3o SATA antiga, a tecnologia moveu os SSDs diretamente para injetarem dados nas pistas ultra-r\u00e1pidas da placa-m\u00e3e (PCI-Express). M\u00f3dulos NVMe M.2 se comunicam fisicamente por canais em que passam Gigabytes por segundo (ex: Gen4 cruza 7.000 MB/s).</p> <p>Isto alterou para sempre o Backend moderno: Os Softwares de Mem\u00f3ria In-Memory (Redis) est\u00e3o repensando paradigmas pois o Disco NVMe moderno \u00e0s vezes responde com velocidade que ro\u00e7a a velha mem\u00f3ria RAM DDR3!</p>"},{"location":"slides/src/slide-13/#3-iops-a-metrica-real-do-servidor","title":"\ud83d\udcc8 3. IOPS - A M\u00e9trica Real do Servidor","text":"<p>Se a banda (MB/s) diz o volume da mangueira, os IOPS (Input/Output Operations Per Second) dizem quantos golpes a mangueira d\u00e1 por segundo. </p> <ul> <li>Quando voc\u00ea hospeda um App Node/Python que grava 1 milh\u00e3o de pequenos logs <code>.txt</code> de 1KB, n\u00e3o importa se voc\u00ea tem 7000 MB/s. Voc\u00ea precisa de IOPS Alt\u00edssimos, para que a fila matem\u00e1tica de Write Requests n\u00e3o trave seu servidor (<code>I/O Wait / Blocked</code>). </li> </ul> <p>[!CAUTION] Ao configurar a AWS (Amazon Cloud), inst\u00e2ncias EBS (Discos el\u00e1sticos anexados) cobram mais caro pela volumetria de IOPS. O gargalo da sua API lenta de CRUD nunca \u00e9 a CPU, geralmente \u00e9 porque o Disco Estourou sua cota de Burst de IOPS.</p>"},{"location":"slides/src/slide-13/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<p>O desenvolvedor C++ entende isso programando a I/O por grandes lotes (<code>Buffers</code>). N\u00e3o escreva no disco <code>1 byte</code> no la\u00e7o for por <code>1 milh\u00e3o de vezes</code> (Destrui\u00e7\u00e3o de IOPS). Acumule os dados num Buffer gig\u00e2ntico de <code>1 MB</code> na RAM, e comande gravar os dados no SSD em \u00fanico e massivo Request! (Otimiza\u00e7\u00e3o m\u00e1xima de Throughput).</p>"},{"location":"slides/src/slide-14/","title":"Slide 14","text":""},{"location":"slides/src/slide-14/#sistemas-de-arquivos","title":"Sistemas de Arquivos","text":""},{"location":"slides/src/slide-14/#aula-14","title":"Aula 14","text":""},{"location":"slides/src/slide-14/#1-o-v-node-inode","title":"\ud83d\uddc2\ufe0f 1. O V-Node / Inode","text":"<p>Se no seu PC existe a pasta <code>Docs/foto.jpg</code>, no fundo, o Linux n\u00e3o rastreia o texto \"foto.jpg\" para pular de cluster em cluster.  O FS usa de \u00edndices num\u00e9ricos ultra-r\u00e1pidos: os Inodes. </p> <pre><code>graph LR\n    A[\"Diret\u00f3rio /Docs\"] --&gt;|12345| B(\"Inode 12345\")\n    B --&gt; C[\"Tamanho: 2MB\"]\n    B --&gt; D[\"Permiss\u00f5es: rwxr-xr-x\"]\n    B --&gt; E[\"Blocos F\u00edsicos de Dados\"]\n    E --&gt; F[\"Cluster 80 no SSD\"]\n    E --&gt; G[\"Cluster 89 no SSD\"]</code></pre> <p>[!INFO] Por que o comando de Deletar (rm) um arquivo grande \u00e9 quase instant\u00e2neo, mas copiar \u00e9 lento? O <code>rm</code> apaga apenas a entrada no \u00cdndice (Inode), fingindo pro SO que o espa\u00e7o t\u00e1 livre. O dado mesmo ainda t\u00e1 l\u00e1 magnetizado at\u00e9 algo escrever por cima (Por isso existem softwares de recupera\u00e7\u00e3o de dados!)</p>"},{"location":"slides/src/slide-14/#2-journaling-a-prova-contra-quedas","title":"\ud83d\udee1\ufe0f 2. Journaling (A Prova contra Quedas)","text":"<p>Mudar um arquivo \u00e9 uma transa\u00e7\u00e3o: Apagar o velho, escrever o novo, mudar o Inode. E se faltar luz na etapa 2? A parti\u00e7\u00e3o corromperia inteiramente para sempre (Problema antigo do FAT32).</p> <p>FSs modernos (NTFS, EXT4) usam Journaling. Antes de aplicar qualquer mudan\u00e7a no Inode oficial, eles \"anotam a inten\u00e7\u00e3o do que v\u00e3o fazer\" num Di\u00e1rio Oculto (Journal). Se a luz cai, ao ligar o PC, ele l\u00ea o di\u00e1rio oculto incompleto, reverte o estrago e devolve sua m\u00e1quina salva! \u00c9 a ess\u00eancia do conceito Atomicidade.</p>"},{"location":"slides/src/slide-14/#3-buffers-e-page-cache-por-que-linux-e-rapido","title":"\ud83d\ude84 3. Buffers e Page Cache (Por que Linux \u00e9 R\u00e1pido)","text":"<p>\"Escrever no disco\" via SysCall C++ <code>write()</code> ou <code>fwrite()</code> raramente vai pro HD! O Linux usa de forma abusiva toda a RAM ociosa do seu computador como um gigantesco Cache File. Ele capta suas writes e diz \"Gravei amig\u00e3o!\" mas jogou na RAM (Page Cache). Posteriormente ele realiza os envios reais para o Hardware agrupados (Flush / Sync).</p> <p>Essa m\u00e1gica salva a Morte do seu SSD (menos grava\u00e7\u00f5es simult\u00e2neas em desgaste das celulas NAND) e simula uma ilus\u00e3o de lentid\u00e3o zero ao usu\u00e1rio.</p>"},{"location":"slides/src/slide-14/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Ao usar C/C++, chame o instr\u00ednseco <code>fsync()</code> se seu App for um Banco de Dados ou Software Cr\u00edtico Banc\u00e1rio for\u00e7ando a Cache RAM descarregar a for\u00e7a e salvar permanentemente no sil\u00edcio do disco.</li> <li>Nunca dependa da nomenclatura C: <code>/usr/foto.jpg</code>. Leia descritores de arquivo, file-pointers e fluxos bin\u00e1rios se for transitar redes em baixo n\u00edvel.</li> </ul>"},{"location":"slides/src/slide-15/","title":"Slide 15","text":""},{"location":"slides/src/slide-15/#entrada-e-saida-io","title":"Entrada e Sa\u00edda (I/O)","text":""},{"location":"slides/src/slide-15/#aula-15","title":"Aula 15","text":""},{"location":"slides/src/slide-15/#1-system-calls-o-pedagio-do-kernel","title":"\ud83d\udeaa 1. System Calls (O Ped\u00e1gio do Kernel)","text":"<p>Programas nativos de C/C++ rodando na zona abstratamente segura (User Space) N\u00c3O T\u00caM permiss\u00e3o f\u00edsica el\u00e9tron-el\u00e9tron para dar ordens ao cabo de Rede de imprimir um byte TCP. Tentar burlar isso gera um sum\u00e1rio e fulminante encerramento compuls\u00f3rio pelo Processador atrav\u00e9s do bloqueio de An\u00e9is de Prote\u00e7\u00e3o.</p> <p>Para acionar a Rede, o C++ precisa paralisar, invocar a sagrada System Call (Syscall, ex: write, sendto, read) que abre o portal para o S.O (Kernel Space). \u00c9 o Kernel Linux quem vai orquestrar a placa C de Ethernet.</p>"},{"location":"slides/src/slide-15/#2-interrupcoes-vs-polling","title":"\u26a0\ufe0f 2. Interrup\u00e7\u00f5es vs Polling","text":"<p>Seu App em Python/C diz: \"Puxe o dado que est\u00e1 vindo no mouse\". 1. Polling (Desastroso): A CPU fica travada rodando <code>while(mouse_is_empty) {}</code> perguntando de nano em nanosegundo \"Chegou? E agora? E Agora?\". (Suga 100% da CPU por um mouse inerte). 2. Interrupts (Moderno): A CPU delega para o controlador USB rodar a escuta passiva, e a CPU volta a fechar os frames de Game. Quando o usu\u00e1rio clica com o dedo, o Controlador injeta um choque el\u00e9trico no pino do Processador. Interrupt request (IRQ)! A CPU congela subitamente o Game, salva o contexto, trata o clique do Mouse rapidamente, e exuma a cena do Game novamente do congelamento.</p>"},{"location":"slides/src/slide-15/#3-dma-memoria-com-acesso-direto","title":"\ud83d\ude80 3. DMA (Mem\u00f3ria com Acesso Direto)","text":"<p>Mesmo com as Interrup\u00e7\u00f5es ajudando a n\u00e3o ficar paralisado Polling... Fazer a Placa de Rede encher a placa RAM transitando Bit a Bit passando pelo miolo doloroso da CPU era impratic\u00e1vel em Gigabit Ethernets.</p> <p>A revolu\u00e7\u00e3o moderna chama-se Direct Memory Access (DMA). Placas de Captura, NVMe e Placas de Rede conversam Diretamente com a Mem\u00f3ria RAM por vias de bypass.</p> <pre><code>graph BT\n    A[\"Placa de Rede\"] -- \"Caminho Direto (DMA)\" --&gt; B[\"Mem\u00f3ria RAM\"]\n    A -. \"Aviso via IRQ\\n(Terminei!)\" .-&gt; C[\"CPU\"]\n    C -. \"Ordens Lentas\" .-&gt; B</code></pre> <p>A CPU diz: \"Placa, baixe o NetFlix do Ponto P pro Q na RAM\". A Placa faz todo os trabalho violento por tr\u00e1s. A CPU usa seu pipeline pra c\u00e1lculos e matem\u00e1tica puros, enquanto sua mem\u00f3ria vai sendo injetada pela placa de v\u00eddeo via t\u00faneis secretos pelas pontes.</p>"},{"location":"slides/src/slide-15/#resumo-pratico","title":"\ud83d\ude80 Resumo Pr\u00e1tico","text":"<ul> <li>Se a sua aplica\u00e7\u00e3o Web Framework ass\u00edncrona (como NodeJS ou Nginx C++) trava muito com \"I/O\", isso significa que o Sistema delega opera\u00e7\u00f5es custosas pelo DMA ao Kernel, enquanto orquestra Event-Loops aguardando os famigerados Interrupts de retorno. </li> </ul> <p>Fim do estudo base te\u00f3rico, chegamos ao final. \u00c9 hora de compilar conhecimento na Otimiza\u00e7\u00e3o Pura (Aula Final).</p>"},{"location":"slides/src/slide-16/","title":"Slide 16","text":""},{"location":"slides/src/slide-16/#projeto-final-otimizacao-baseada-em-hardware","title":"Projeto Final: Otimiza\u00e7\u00e3o Baseada em Hardware","text":""},{"location":"slides/src/slide-16/#aula-16","title":"Aula 16","text":""},{"location":"slides/src/slide-16/#1-profiling-classico-a-vida-real","title":"\u23f1\ufe0f 1. Profiling Cl\u00e1ssico (A Vida Real)","text":"<p>Adivinhar onde o c\u00f3digo est\u00e1 lento \u00e9 a armadilha suprema do j\u00fanior. Usamos ferramentas robustas para que a Arquitetura Linux diga-nos onde os gargalos fervem a CPU.</p> <ul> <li>gprof: O padr\u00e3o antigo C++. Ele recompila injetando marca\u00e7\u00f5es cont\u00e1beis nas idas e vindas de fun\u00e7\u00f5es, revelando \"Quais chamadas consumiram O Tempo Global\".</li> <li>Valgrind (Callgrind / Cachegrind): Ferramenta extrema rodando seu execut\u00e1vel numa sandbox virtual que mapeia cada instru\u00e7\u00e3o assembly. Traz gr\u00e1ficos massivos de onde Ocorreram os Caches Misses da Mem\u00f3ria L1 de nossa Aula 06!</li> <li>Perf: O utilit\u00e1rio nativo dos programadores Linux Kernel, extraindo informa\u00e7\u00f5es m\u00e9tricas em Eventos de Desvio (Branch Mispired da Aula 03) usando rel\u00f3gios internos dos registradores ocultos <code>PMU</code> do seu pr\u00f3prio Processador em tempo real, sem overhead sint\u00e9tico.</li> </ul>"},{"location":"slides/src/slide-16/#2-o-grande-desafio-mini-projeto-pratico","title":"\ud83d\udd2c 2. O Grande Desafio (Mini-Projeto Pr\u00e1tico)","text":"<p>O curso desafia todo programador C/C++ a desenvolver a Prova de Fogo do Hardware:</p> <pre><code>$ # Desafio do Iterador de Matriz Cont\u00ednua\n$ g++ matriz_opt.cpp -O3 -o matriz\n$ ./matriz \nItera\u00e7\u00e3o Horizontal (Hit L1): Tempo 140ms\nItera\u00e7\u00e3o Vertical (Miss L1): Tempo 2100ms\n</code></pre>"},{"location":"slides/src/slide-16/#3-conclusao-da-trilha","title":"\ud83c\udfc6 3. Conclus\u00e3o da Trilha","text":"<p>Voc\u00ea navegou nas extremas profundezas da arquitetura da Computa\u00e7\u00e3o Modernizada. Um engenheiro de Backend jamais olhar\u00e1 para <code>int x;</code> ou <code>for()</code> sem recordar os impactos t\u00e9rmicos, cache hits mortais de linha, L1 local, reordena\u00e7\u00f5es do std::atomic Memory Model ou Page Faults nos clusters de Sistema e Processos em Swap.</p> <p>Parab\u00e9ns pela resili\u00eancia no vale do Sil\u00edcio e da Matem\u00e1tica discreta profunda. Nunca pare de medir e Otimizar. O Hardware dita as leis; o Software obedece.</p> <p> Finalizar e Visitar Projetos{ .md-button .md-button--primary }</p>"}]}